
<!-- saved from url=(0053)http://www.kuqin.com/grails-doc-1.0/guide/single.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
		  <title>Grails开源框架 1.0 - 使用指南</title>
		  <link rel="stylesheet" href="./Grails开源框架 1.0 - 使用指南_files/main.css" type="text/css" media="screen" title="Style" charset="gb2312">	
	</head>
    <body class="body">
		<div id="header">
				<div class="images"><br><br>
				   <a href="http://grails.org/" target="_blank"><img alt="The Grails Framework" src="./Grails开源框架 1.0 - 使用指南_files/grails.png" width="300" border="0"></a>
				   <span style="right:30px; top:20px; position:absolute;">
					<a href="http://www.kuqin.com/grails-doc-1.0/index.html" target="_top">Frames</a> | <a href="http://www.kuqin.com/grails-doc-1.0/guide/index.html" target="_top">No Frames</a><br><br>
					<a alt="G2One - The Groovy/Grails Company" href="http://g2one.com/" target="_blank"><img src="./Grails开源框架 1.0 - 使用指南_files/g2one.png" width="130" border="0"></a>
					</span>					
				</div>
				<div class="message">了解轻快敏捷，企业级Web应用的快速开发</div>
				<h1>Grails开源框架 - 使用指南</h1>
				<p><strong>作者:</strong> Graeme Rocher, Marc Palmer</p>
				<p><strong>版本:</strong> 1.0</p>				
				<em>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</em>
		</div>                       
		
		<div id="toc">  
			<h2> 目  录 </h2>
			<div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#1. 简介">1. 简介</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2. 起步">2. 起步</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.1 下载并安装Grails">2.1 下载并安装Grails</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.2 创建一个Grails应用">2.2 创建一个Grails应用</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.3 Hello World示例">2.3 Hello World示例</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.4 使用IDE">2.4 使用IDE</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.5 规约配置">2.5 规约配置</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.6 运行Grails应用">2.6 运行Grails应用</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.7 测试Grails应用">2.7 测试Grails应用</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.8 部署Grails应用">2.8 部署Grails应用</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.9 所支持的Java EE容器">2.9 所支持的Java EE容器</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.10 创建工件">2.10 创建工件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#2.11 生成Grails应用">2.11 生成Grails应用</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3. 配置">3. 配置</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.1 基本配置">3.1 基本配置</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.1.1 内置选项">3.1.1 内置选项</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.1.2 日志">3.1.2 日志</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.2 环境">3.2 环境</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3 数据源">3.3 数据源</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3.1 数据源和环境">3.3.1 数据源和环境</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3.2 JNDI数据源">3.3.2 JNDI数据源</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3.3 自动数据库移植">3.3.3 自动数据库移植</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.4 外部配置">3.4 外部配置</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.5 定义版本">3.5 定义版本</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4. 命令行">4. 命令行</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4.1 创建Gant脚本">4.1 创建Gant脚本</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4.2 可复用的Grails脚本">4.2 可复用的Grails脚本</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4.3 脚本中的事件">4.3 脚本中的事件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4.4 Ant和Maven">4.4 Ant和Maven</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)">5. 对象关系映射(GORM)</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.1 快速指南">5.1 快速指南</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.1.1 基本的CRUD">5.1.1 基本的CRUD</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2 在GORM中进行领域建模">5.2 在GORM中进行领域建模</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.1 GORM中的关联">5.2.1 GORM中的关联</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.1.1 一对一">5.2.1.1 一对一</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.1.2 一对多">5.2.1.2 一对多</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.1.3 多对多">5.2.1.3 多对多</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.2 GORM的组合">5.2.2 GORM的组合</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.3 GORM的继承">5.2.3 GORM的继承</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.4 集合、列表和映射">5.2.4 集合、列表和映射</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3 持久化基础">5.3 持久化基础</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.1 保存和更新">5.3.1 保存和更新</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.2 删除对象">5.3.2 删除对象</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.3 级联更新和删除">5.3.3 级联更新和删除</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 立即加载和延迟加载">5.3.4 立即加载和延迟加载</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 悲观锁和乐观锁">5.3.4 悲观锁和乐观锁</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4 GORM查询">5.4 GORM查询</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4.1 动态查找器">5.4.1 动态查找器</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4.2 条件查询">5.4.2 条件查询</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4.3 Hibernate查询语言">5.4.3 Hibernate查询语言</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5 高级GORM特性">5.5 高级GORM特性</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.1 事件和自动实现时间戳">5.5.1 事件和自动实现时间戳</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射">5.5.2 自定义ORM映射</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.1 表名和列名">5.5.2.1 表名和列名</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.2 缓存策略">5.5.2.2 缓存策略</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.3 继承策略">5.5.2.3 继承策略</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.4 自定义数据库标识符">5.5.2.4 自定义数据库标识符</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.5 复合主键">5.5.2.5 复合主键</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.6 数据库索引">5.5.2.6 数据库索引</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.7 乐观锁和版本定义">5.5.2.7 乐观锁和版本定义</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2.8 立即加载和延迟加载">5.5.2.8 立即加载和延迟加载</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.6 事务编程">5.6 事务编程</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.7 GORM和约束">5.7 GORM和约束</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6. Web层">6. Web层</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器">6.1 控制器</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.1 理解控制器和操作">6.1.1 理解控制器和操作</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.2 控制器和作用域">6.1.2 控制器和作用域</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.3 模型和视图">6.1.3 模型和视图</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.4 重定向和链">6.1.4 重定向和链</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.5 控制器拦截器">6.1.5 控制器拦截器</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.6 数据绑定">6.1.6 数据绑定</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.7 XML和JSON响应">6.1.7 XML和JSON响应</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.8 上传文件">6.1.8 上传文件</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.9 命令对象">6.1.9 命令对象</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2 Groovy Server Pages">6.2 Groovy Server Pages</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.1 GSP基础">6.2.1 GSP基础</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.1.1 变量和作用域">6.2.1.1 变量和作用域</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.1.2 逻辑和迭代">6.2.1.2 逻辑和迭代</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.1.3 页面指令">6.2.1.3 页面指令</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.1.4 表达式">6.2.1.4 表达式</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2 GSP标签">6.2.2 GSP标签</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.1 变量和作用域">6.2.2.1 变量和作用域</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.2 逻辑和迭代">6.2.2.2 逻辑和迭代</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.3 搜索和过滤">6.2.2.3 搜索和过滤</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.4 链接和资源">6.2.2.4 链接和资源</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.5 表单和字段">6.2.2.5 表单和字段</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.6 标签作为方法调用">6.2.2.6 标签作为方法调用</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.3 视图和模板">6.2.3 视图和模板</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.4 使用Sitemesh布局">6.2.4 使用Sitemesh布局</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库">6.3 标签库</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.1 简单标签">6.3.1 简单标签</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.2 逻辑标签">6.3.2 逻辑标签</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.3 迭代标签">6.3.3 迭代标签</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.4 标签命名空间">6.3.4 标签命名空间</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射">6.4 URL映射</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.1 映射到控制器和操作">6.4.1 映射到控制器和操作</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.2 嵌入式变量">6.4.2 嵌入式变量</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.3 映射到视图">6.4.3 映射到视图</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.4 映射到响应代码">6.4.4 映射到响应代码</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.5 映射到HTTP方法">6.4.5 映射到HTTP方法</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.6 映射通配符">6.4.6 映射通配符</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.7 自动重写链接">6.4.7 自动重写链接</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.8 应用约束">6.4.8 应用约束</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5 Web Flow">6.5 Web Flow</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.1 开始和结束状态">6.5.1 开始和结束状态</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.2 操作状态和视图状态">6.5.2 操作状态和视图状态</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.3 流执行事件">6.5.3 流执行事件</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.4 流的作用域">6.5.4 流的作用域</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.5 数据绑定和验证">6.5.5 数据绑定和验证</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.6 子流程和会话">6.5.6 子流程和会话</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6 过滤器">6.6 过滤器</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6.1 应用过滤器">6.6.1 应用过滤器</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6.2 过滤器的类型">6.6.2 过滤器的类型</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6.3 过滤器的功能">6.6.3 过滤器的功能</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7 Ajax">6.7 Ajax</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.1 用Prototype实现Ajax">6.7.1 用Prototype实现Ajax</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.1.1 异步链接">6.7.1.1 异步链接</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.1.2 更新内容">6.7.1.2 更新内容</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.1.3 异步表单提交">6.7.1.3 异步表单提交</a></div><div class="tocItem" style="margin-left:30px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.1.4 Ajax事件">6.7.1.4 Ajax事件</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.2 用Dojo实现Ajax">6.7.2 用Dojo实现Ajax</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.3 用GWT实现Ajax">6.7.3 用GWT实现Ajax</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7.4 服务端的Ajax">6.7.4 服务端的Ajax</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.8 内容协商">6.8 内容协商</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7. 验证">7. 验证</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束">7.1 声明约束</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.2 验证约束">7.2 验证约束</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.3 客户端验证">7.3 客户端验证</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.4 验证和国际化">7.4 验证和国际化</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8. 服务层">8. 服务层</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8.1 声明式事务">8.1 声明式事务</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8.2 服务的作用域">8.2 服务的作用域</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8.3 依赖注入和服务">8.3 依赖注入和服务</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8.4 使用Java的服务">8.4 使用Java的服务</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9. 测试">9. 测试</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9.1 单元测试">9.1 单元测试</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9.2 集成测试">9.2 集成测试</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9.3 功能测试">9.3 功能测试</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10. 国际化">10. 国际化</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10.1 理解信息绑定">10.1 理解信息绑定</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10.2 改变Locales">10.2 改变Locales</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10.3 读取信息">10.3 读取信息</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11. 安全">11. 安全</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.1 预防攻击">11.1 预防攻击</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码">11.2 字符串的编码和解码</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.3 身份验证">11.3 身份验证</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.4 关于安全的插件">11.4 关于安全的插件</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.4.1 Acegi">11.4.1 Acegi</a></div><div class="tocItem" style="margin-left:20px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.4.2 JSecurity">11.4.2 JSecurity</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12 插件">12 插件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.1 创建和安装插件">12.1 创建和安装插件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.2 理解插件的结构">12.2 理解插件的结构</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.3 提供基础的工件">12.3 提供基础的工件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.4 评估规约">12.4 评估规约</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.5 参与构建事件">12.5 参与构建事件</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.6 参与运行时配置">12.6 参与运行时配置</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.7 运行时添加动态方法">12.7 运行时添加动态方法</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.8 参与自动重载">12.8 参与自动重载</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12.9 理解插件加载的顺序">12.9 理解插件加载的顺序</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13. Web服务">13. Web服务</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13.1 REST">13.1 REST</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13.2 SOAP">13.2 SOAP</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13.3 RSS和Atom">13.3 RSS和Atom</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14. Grails和Spring">14. Grails和Spring</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.1 Grails的支柱">14.1 Grails的支柱</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.2 配置其他Bean">14.2 配置其他Bean</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.3 通过Beans DSL运行Spring">14.3 通过Beans DSL运行Spring</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.4 配置属性占位">14.4 配置属性占位</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.5 配置属性重载">14.5 配置属性重载</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#15. Grails和Hibernate">15. Grails和Hibernate</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#15.1 通过Hibernate注释进行映射">15.1 通过Hibernate注释进行映射</a></div><div class="tocItem" style="margin-left:10px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#15.2 深入了解">15.2 深入了解</a></div><div class="tocItem" style="margin-left:0px"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架">16.脚手架</a></div>
		</div>     
		<div id="content">
			<h1><a name="1. 简介">1. 简介</a></h1>如今的Java Web开发对于需求来说已经变得过于复杂。当今众多Java领域的Web开发框架不仅使用复杂，而且并没有很好的遵循Don’t Repeat Yourself（DRY）原则。<p class="paragraph">像Rails，Django和TurboGears这样的动态框架在Web开发领域开辟了一条新的道路，Grails基于这些概念之上，采用动态方法减小了Java平台上进行Web开发的复杂度，不过与那些框架不同的是，Grails是构建在Spring和Hibernate等Java已有的技术之上的。</p><p class="paragraph">Grails是一个full-stack框架，它借助于核心技术与相关的插件（plug-in）来解决Web开发中方方面面的问题，其中包括：
</p><ul class="star">
<li>易于使用的基于<a href="http://www.hibernate.org/" target="blank">Hibernate</a>的对象-关系映射(ORM)层</li>
<li>称为Groovy Server Pages (GSP)的表现层技术</li>
<li>基于<a href="http://www.springframework.org/" target="blank">Spring</a> MVC的控制器层</li>
<li>构建于<a href="http://groovy.codehaus.org/Gant" target="blank">Gant</a> 上的命令行脚本运行环境</li>
<li>内置Jetty服务器，不用重新启动服务器就可以进行重新加载</li>
<li>利用内置的<a href="http://www.springframework.org/" target="blank">Spring</a> 容器实现依赖注入</li>
<li>基于Spring的MessageSource核心概念，提供了对国际化（i18n）的支持</li>
<li>基于Spring事务抽象概念，实现事务服务层</li>
</ul><p class="paragraph">借助于功能强大的Groovy动态语言和领域特定语言（Domain Specific Language，DSL），以上那些特性变得非常易用。</p><p class="paragraph">这篇文档会向你介绍如何使用Grails框架来搭建Web应用程序。
</p><h1><a name="2. 起步">2. 起步</a></h1><h2><a name="2.1 下载并安装Grails">2.1 下载并安装Grails</a></h2>首先需要下载Grails的发行包并进行安装，执行步骤如下：
<ul class="star">
<li><a href="http://grails.org/Download" target="blank">下载</a> Grails二进制发行包并解压到指定的文件目录下。</li>
<li>在环境变量中添加GRAILS_HOME,值为上一步解压的文件目录。</li>
<ul class="star">
<li>Unix/Linux系统上运行export GRAILS_HOME=/path/to/grails。</li>
<li>Windows系统上右击“我的电脑”/“属性”/“高级”/“环境变量”，点击新建。</li>
</ul>
<li>将解压目录下的bin目录路径添加到path中</li>
<ul class="star">
<li>Unix/Linux系统上运行export PATH="$PATH:$GRAILS_HOME/bin。</li>
<li>Windows系统上右击“我的电脑”/“属性”/“高级”/“环境变量”，修改path的值。</li>
</ul></ul><p class="paragraph">如果环境变量设置无误，此时可以打开终端（window下为命令提示符，Unix/Linux下为Shell），输入grails，如果屏幕上显示如下提示则说明安装成功。</p><p class="paragraph"></p><pre class="bq"><code>
Welcome to Grails 1.0 - http://grails.org/
Licensed under Apache Standard License 2.0
Grails home is set to: /Developer/grails-1.0
No script name specified. Use 'grails help' for more info</code></pre><p class="paragraph">
</p><h2><a name="2.2 创建一个Grails应用">2.2 创建一个Grails应用</a></h2>在创建应用程序之前，先熟悉一下grails命令的使用（grails中的命令都在终端中输入，请参考上面的讲解）。
<pre class="bq"><code>
grails command name</code></pre><p class="paragraph">现在我们为了创建一个Grails应用，需要输入的命令是create-app
</p><pre class="bq"><code>
grails create-app helloworld</code></pre><p class="paragraph">这样就在当前目录下创建了一个名为helloworld（即我们的应用程序名）的文件夹，在这个文件夹中包含了我们这个项目的整个文件目录，可以使用如下命令进入这个目录中查看：
</p><pre class="bq"><code>
cd helloworld</code></pre><p class="paragraph"></p><h2><a name="2.3 Hello World示例">2.3 Hello World示例</a></h2>为了完成这个经典的Hello World示例，我们需要运行create-controller命令
<pre class="bq"><code>
grails create-controller hello  </code></pre><p class="paragraph">运行该命令后会在<code>grails-app/controller</code>目录下创建一个名为<code>HelloController.groovy</code>的控制器（更多关于控制器的内容请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>一节）</p><p class="paragraph">控制器主要用来完成对Web请求的处理，我们稍微修改一下控制器的内容，使它能够在页面上输出"Hello World!"的字样，代码如下:
</p><pre class="bq"><code>
class HelloController {
	def world = {
		render "Hello World!"
	}
}                           </code></pre><p class="paragraph">现在控制器已经完成了，接下来要使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/run-app.html" class="commandLine">run-app</a>来启动内置的jetty服务器运行刚刚创建的helloworld程序
</p><pre class="bq"><code>
grails run-app</code></pre><p class="paragraph">运行后会在8080端口（默认，可以使用-Dserver.port来指定端口）启动服务器，然后在浏览器中输入http://localhost:8080/helloworld来启动应用程序.</p><p class="paragraph">运行结果如下图所示：</p><p class="paragraph"><img border="0" class="center" src="./Grails开源框架 1.0 - 使用指南_files/intropage.png"></p><p class="paragraph">这个Grails简介页面是由web-app/index.gsp来显示的。从上图可以看见刚才创建的控制器，点击链接之后会在浏览器中显示Hello World!的字样。
</p><h2><a name="2.4 使用IDE">2.4 使用IDE</a></h2><h4>IntelliJ IDEA</h4><p class="paragraph">至今为止最成熟、最全面的Groovy&amp;Grails开发集成工具就是<a href="http://www.jetbrains.com/idea" target="blank">IntelliJ IDEA 7.0</a>和它的<a href="http://www.jetbrains.net/confluence/display/GRVY/Groovy+Home" target="blank">JetGroovy</a>插件。对于大型项目，Grails团队优先推荐使用IntelliJ。</p><p class="paragraph"></p><h4>TextMate</h4><p class="paragraph">由于Grails目标集中于如何更简洁，所以我们可以使用一些更简单的编辑器进行Groovy&amp;Grails的开发，例如在Mac上可以使用<a href="http://macromates.com/" target="blank">TextMate</a> ，下载地址 <a href="http://macromates.com/wiki/Main/SubversionCheckout%E3%80%82" target="blank">Texmate bundles SVN</a></p><p class="paragraph"></p><h4>Eclipse</h4><p class="paragraph"><a href="http://www.eclipse.org/" target="blank">Eclipse</a> 的<a href="http://groovy.codehaus.org/Eclipse+Plugin" target="blank">Groovy插件</a> 也可以支持语法高亮，代码自动完成等特性。
</p><blockquote class="note">
在Grails的Wiki上有更多关于<a href="http://grails.org/Eclipse+IDE+Integration" target="blank">Eclipse插件</a>的谈论。
</blockquote><p class="paragraph">Grails在创建应用时会自动创建Eclipse的工程文件<code>.project</code>和<code>classpath</code>，这样如果要在Eclipse中导入一个Grails工程只需要在Eclipse中右击Package Explorer，选择Import，然后选择Existing project into Workspace，最后指定Grails的项目目录位置。</p><p class="paragraph">点击OK，Finish后会自动将Grails工程导入到Eclipse中。
并自动创建合适的运行配置（Run Configuration），这样在Eclipse中直接点击Run就可以运行Grails的项目。 
</p><h2><a name="2.5 规约配置">2.5 规约配置</a></h2>Grails中的配置遵循“规约优于配置”的原则，即通过文件的名称和位置来替代显式的配置，因此需要熟悉以下几个目录结构的用途。<p class="paragraph">此处仅仅为一个分类，具体的请参考相关章节：
</p><ul class="star">
<li><code>grails-app</code> - Groovy源文件的顶级目录</li>
<ul class="star">
<li><code>conf</code> - 配置文件目录,详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3. 配置" class="guide">配置</a>.</li>
<li><code>controllers</code> - 控制器目录（MVC模型中的C），详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a></li>
<li><code>domain</code> - 领域模型目录（MVC模型中的M），详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM</a></li>
<li><code>i18n</code> - 国际化目录，用来支持i18n，详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10. 国际化" class="guide">国际化</a></li>
<li><code>services</code> - 服务目录，详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8. 服务层" class="guide">服务层</a></li>
<li><code>taglib</code> - 标签库目录，详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库" class="guide">标签库</a></li>
<li><code>views</code> - 视图GSP目录（MVC中的V），详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2 Groovy Server Pages" class="guide">GSP</a></li>
</ul>
<li><code>scripts</code> - Gant脚本目录,详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4. 命令行" class="guide">Gant脚本</a></li>
<li><code>src</code> - 源文件目录</li>
<ul class="star">
<li><code>groovy</code> - 其他的Groovy源文件目录</li>
<li><code>java</code> - 其他的Java源文件目录</li>
</ul>
<li><code>test</code> - 单元和集成测试目录,详细参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9. 测试" class="guide">测试</a></li>
</ul><p class="paragraph"></p><h2><a name="2.6 运行Grails应用">2.6 运行Grails应用</a></h2>可以运行<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/run-app.html" class="commandLine">run-app</a>命令来启动Grails内置的Jetty服务器，默认启动端口为8080
<div class="code"><pre>grails run-app</pre></div><p class="paragraph">如果8080端口已经被占用，可以通过 <code>server.port</code> 参数指定其他端口
</p><div class="code"><pre>grails -Dserver.port=8090 run-app</pre></div><p class="paragraph">更多关于<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/run-app.html" class="commandLine">run-app</a>的内容可以参照参考指南。
</p><h2><a name="2.7 测试Grails应用">2.7 测试Grails应用</a></h2><code>create-*</code> 命令会在 <code>test/integration</code>目录下自动创建相应的测试文件，可以在这些测试文件中编写测试用例来进行单元测试和集成测试，关于测试的内容可以参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9. 测试" class="guide">测试</a>章节。运行这些测试可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/test-app.html" class="commandLine">test-app</a>命令。
<div class="code"><pre>grails test-app</pre></div><p class="paragraph">Grails会自动创建Ant的<code>build.xml</code>文件，也可以通过Ant来运行测试(其实运行的是Grails的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/test-app.html" class="commandLine">test-app</a>)。
</p><div class="code"><pre>ant test</pre></div><p class="paragraph">这样当Grails应用作为持续集成平台，例如CruiseControl的一部分时就会十分方便
</p><h2><a name="2.8 部署Grails应用">2.8 部署Grails应用</a></h2>Grails应用程序以Web应用归档（.WAR）文件的形式进行部署，并且Grails还提供了<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/war.html" class="commandLine">war</a>命令来执行生成归档文件。
<div class="code"><pre>grails war</pre></div><p class="paragraph">这条命令会生成当前应用的war文件，可以按照服务器容器的不同进行相应的配置.
</p><blockquote class="warning">
一定不要使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/run-app.html" class="commandLine">run-app</a>命令来部署Grails，因为此命令会在运行时自动加载，这样会对服务器的性能和可扩展性有严重影响。
</blockquote><p class="paragraph">当部署时应当通JVM的<code>-server</code>参数来为服务器分配足够的内存空间，推荐的VM参数是：</p><p class="paragraph"></p><div class="code"><pre>-server -Xmx512M</pre></div>
<h2><a name="2.9 所支持的Java EE容器">2.9 所支持的Java EE容器</a></h2>Grails可以支持的相当多的Web容器，包括:
<ul class="star">
<li>Tomcat 5.5</li>
<li>Tomcat 6.0</li>
<li>GlassFish v1 (Sun AS 9.0)</li>
<li>GlassFish v2 (Sun AS 9.1)</li>
<li>Sun App Server 8.2</li>
<li>Websphere 6.1</li>
<li>Websphere 5.1</li>
<li>Resin 3.2</li>
<li>Oracle AS</li>
<li>JBoss 4.2</li>
<li>Jetty 6.1</li>
<li>Jetty 5</li>
<li>Weblogic 7/8/9/10</li>
</ul><p class="paragraph">虽然在一些服务器上运行还存在Bug，但是大部分情况下都可以工作的很好。在Grails的Wiki上可以找到关于<a href="http://grails.org/Deployment" target="blank">已知部署问题的清单</a>。
</p><h2><a name="2.10 创建工件">2.10 创建工件</a></h2>除了以上介绍的命令，Grails还有一系列用来创建其他工件类型的命令，例如可以使用 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-controller.html" class="commandLine">create-controller</a>,<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-domain-class.html" class="commandLine">create-domain-class</a>等等。
<blockquote class="note">
为了方便可以使用IDE或者其他你喜欢的编辑器来创建
</blockquote>
比如说，为了创建一个应用的基础，你至少需要一个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">领域模型</a>，命令如下：
<div class="code"><pre>grails create-domain-class book</pre></div><p class="paragraph">这样会在<code>grails-app/domain/Book.groovy</code>中创建一个领域类，其内容如下:
</p><div class="code"><pre>class Book {	
}</pre></div><p class="paragraph">更多的<code>create-*</code>命令可以在参考指南的命令行中被探索。
</p><h2><a name="2.11 生成Grails应用">2.11 生成Grails应用</a></h2>在创建完Grails应用后通常会使用“<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架" class="guide">脚手架</a>”来生成整个应用程序的骨架。这是通过使用<code>generate-*</code>命令来完成的，例如使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/generate-all.html" class="commandLine">generate-all</a>命令来根据领域模型生成<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>及其相应<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2 Groovy Server Pages" class="guide">视图</a>。由于之前我们创建了一个Book.groovy的领域模型，因此在这里运行如下命令。
<div class="code"><pre>grails generate-all Book</pre></div><p class="paragraph">更多关于脚手架的内容请参考用户指南的后边章节。
</p><h1><a name="3. 配置">3. 配置</a></h1>也许在这里谈论配置对于一个遵循“规约优于配置”的框架来说，会让人感到比较奇怪，但是实际上我们这里所说的配置是两个不同的概念，请不要混淆。<p class="paragraph">实际上Grails的默认配置已经足以我们进行开发，并且它内置了容器和内存模式的HSQL数据库，这样我们几乎连数据库都不用配置了。</p><p class="paragraph">不过，在将来你肯定是想要配置一个真正的数据库的，下面的章节将介绍如何实现。
</p><h2><a name="3.1 基本配置">3.1 基本配置</a></h2>Grails提供了一个<code>grails-app/conf/Config.groovy</code>配置文件，用来完成一般通常的配置。这个文件使用非常类似于Java属性（propertiese）文件、不过是纯Groovy的<a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> ，这样就可以重用（re-use）变量以及指定合适的Java类型。<p class="paragraph">例如，可以在文件中加上自己定义的配置信息。
</p><div class="code"><pre>foo.bar.hello = <span class="java-quote">"world"</span></pre></div><p class="paragraph">这样在应用程序中有两种方式可以访问这些配置信息。最常用的一种方式是通过<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a>对象，它在控制器和标签库中都可以作为变量来使用。
</p><div class="code"><pre>assert <span class="java-quote">"world"</span> == grailsApplication.config.foo.bar.hello</pre></div>
<h2><a name="3.1.1 内置选项">3.1.1 内置选项</a></h2>Grails同样提供了如下配置选项：
<ul class="star">
<li><code>grails.config.locations</code>  - 属性（properties）文件的位置或者Grails将同主配置合并的额外配置文件。</li>
<li><code>grails.enable.native2ascii</code>-如果不需要对Grails的i18n配置文件使用默认的native2ascii约定，可以将该选项设为false。</li>
<li><code>grails.views.default.codec</code> - 设置GSP缺省的字符编码，可以是：'none', 'html', 或者 'base64' (缺省为'none'). 为了减少XSS攻击的风险，建议设置成'html'.</li>
<li><code>grails.views.gsp.encoding</code> - GSP源文件的字符编码（缺省是'utf-8'）</li>
<li><code>grails.war.destFile</code> - 设置<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/war.html" class="commandLine">war</a>生成WAR文件的位置</li>
<li><code>grails.mime.file.extensions</code> - 是否使用文件的扩展名表示<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.8 内容协商" class="guide">内容协商</a>中的媒体类型(mime type)</li>
<li><code>grails.mime.types</code> - <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.8 内容协商" class="guide">内容协商</a>所支持的媒体类型</li>
<li><code>grails.serverURL</code> - 一个指向服务器URL的绝对连接，包括服务器名称比如grails.serverURL="http://my.yourportal.com". 详细请看<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/createLink.html" class="Tags">createLink</a>.</li>
</ul><p class="paragraph"></p><h2><a name="3.1.2 日志">3.1.2 日志</a></h2><h4>日志基础</h4><p class="paragraph">Grails通过自身的配置机制来配置<a href="http://logging.apache.org/log4j/1.2/index.html" target="blank">Log4j</a> 日志系统。要使用日志记录功能，需要修改位于<code>grails-app/conf</code>目录下的<code>Config.groovy</code>文件。在这个文件中可以指定不同环境，例如<code>development</code>,<code>test</code>和<code>production</code><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.2 环境" class="guide">环境</a>下的日志方式。Grails会自动处理该文件并在<code>web-app/WEB-INF/classes</code>目录下生成相应的<code>log4j.properties</code>文件。</p><p class="paragraph">例如，在Grails中可以按照如下方式配置Log4j：
</p><div class="code"><pre>log4j {
    appender.stdout = <span class="java-quote">"org.apache.log4j.ConsoleAppender"</span>
	appender.'stdout.layout'=<span class="java-quote">"org.apache.log4j.PatternLayout"</span>
    rootLogger=<span class="java-quote">"error,stdout"</span>
    logger {
        grails=<span class="java-quote">"info,stdout"</span>
        org {
            grails.spring=<span class="java-quote">"info,stdout"</span>
            codehaus.groovy.grails.web=<span class="java-quote">"info,stdout"</span>
            codehaus.groovy.grails.commons=<span class="java-quote">"info,stdout"</span>
            …
        }
}</pre></div><p class="paragraph">如果想使用Log4j文件的标准风格进行配置，可以使用Groovy中的多行字符串，例如：
</p><div class="code"><pre>log4j = '''
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
# ...remaining configuration
'''</pre></div><p class="paragraph">其他一些有用的日志记录器包括：
</p><ul class="star">
<li><code>org.codehaus.groovy.grails.commons</code> - 用来记录核心工件的信息，例如类的加载等等。</li>
<li><code>org.codehaus.groovy.grails.web</code> - 用来记录Grails web请求处理</li>
<li><code>org.codehaus.groovy.grails.web.mapping</code> - 用来调试URL映射</li>
<li><code>org.codehaus.groovy.grails.plugins</code> - 用来记录插件的活动状况</li>
<li><code>org.springframework</code> - 用来记录Spring的活动</li>
<li><code>org.hibernate</code> - 用来记录Hibernate的活动</li>
</ul><p class="paragraph"></p><h4>完整的信息跟踪</h4><p class="paragraph">当异常发生的时候，可能由于Java和Groovy内部的错误而产生一大堆的无用信息。Grails对这些不需要的信息进行了过滤，保证对非Grails/Groovy核心类包的信息跟踪。</p><p class="paragraph">通常这些信息都会通过StackTrace日志记录器记录到stacktrace.log文件中。不过通过修改Config.groovy可以改变其记录方式，例如如果要将跟踪信息直接输出到标准输出（standard out），需要将如下配置:
</p><div class="code"><pre>StackTrace=<span class="java-quote">"error,errors"</span></pre></div><p class="paragraph">修改为:
</p><div class="code"><pre>StackTrace=<span class="java-quote">"error,stdout"</span></pre></div><p class="paragraph">也可以通过设置<code>grails.full.stacktrace</code>虚拟机属性为<code>true</code>来禁用对跟踪信息的过滤，例如
</p><div class="code"><pre>grails -Dgrails.full.stacktrace=<span class="java-keyword">true</span> run-app</pre></div><p class="paragraph"></p><h4>按照规约的日志记录</h4><p class="paragraph">所有的应用程序工件都动态地增加了<code>log</code>属性，其中包括<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">领域模型（Domain Class）</a>，<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>以及标签库等等。使用方法如下所示:
</p><div class="code"><pre>def foo = <span class="java-quote">"bar"</span>
log.debug <span class="java-quote">"The value of foo is $foo"</span></pre></div><p class="paragraph">在Grails中使用<code>grails.app.&lt;artefactType&gt;.ClassName</code>的命名规约来命名日志记录器。例如
</p><div class="code"><pre># Set level <span class="java-keyword">for</span> all application artefacts
log4j.logger.grails.app=<span class="java-quote">"info, stdout"</span><p class="paragraph"># Set <span class="java-keyword">for</span> a specific controller
log4j.logger.grails.app.controller.YourController=<span class="java-quote">"debug, stdout"</span></p><p class="paragraph"># Set <span class="java-keyword">for</span> a specific domain class
log4j.logger.grails.app.domain.Book=<span class="java-quote">"debug, stdout"</span></p><p class="paragraph"># Set <span class="java-keyword">for</span> a specific taglib
log4j.logger.grails.app.tagLib.FancyAjax=<span class="java-quote">"debug, stdout"</span></p><p class="paragraph"># Set <span class="java-keyword">for</span> all taglibs
log4j.logger.grails.app.tagLib=<span class="java-quote">"info, stdout"</span></p></pre></div><p class="paragraph">其中的工件名（即&lt;artefactType&gt;）也是按照规约来命名的，一些常见的如下所示:
</p><ul class="star">
<li><code>bootstrap</code> - 用于启动时的加载类</li>
<li><code>dataSource</code> - 用于数据源</li>
<li><code>tagLib</code> - 用于标签库</li>
<li><code>service</code> - 用于服务类</li>
<li><code>controller</code> - 用于控制器</li>
<li><code>domain</code> - 用于领域模型类</li>
</ul><p class="paragraph"></p><h2><a name="3.2 环境">3.2 环境</a></h2><h4>各个环境的配置</h4><p class="paragraph">Grails支持针对不同的环境进行不同的配置，这样不管是<code>Config.groovy</code>文件还是<code>grails-app/conf</code>目录下的<code>DataSource.groovy</code>文件，都可以借助于<a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 来随时改变所处的环境。例如，默认Grails中的<code>DataSource</code>定义如下：
</p><div class="code"><pre>dataSource {
    pooling = <span class="java-keyword">false</span>                          
    driverClassName = <span class="java-quote">"org.hsqldb.jdbcDriver"</span>	
    username = <span class="java-quote">"sa"</span>
    password = <span class="java-quote">""</span>				
}
environments {
    development {
        dataSource {
            dbCreate = <span class="java-quote">"create-drop"</span> // one of 'create', 'createeate-drop','update'
            url = <span class="java-quote">"jdbc:hsqldb:mem:devDB"</span>
        }
    }   
    test {
        dataSource {
            dbCreate = <span class="java-quote">"update"</span>
            url = <span class="java-quote">"jdbc:hsqldb:mem:testDb"</span>
        }
    }   
    production {
        dataSource {
            dbCreate = <span class="java-quote">"update"</span>
            url = <span class="java-quote">"jdbc:hsqldb:file:prodDb;shutdown=<span class="java-keyword">true</span>"</span>
        }
    }
}</pre></div><p class="paragraph">注意，在文件的最开始提供了一个通用的配置，然后在<code>environments</code>代码块中针对不同的环境下的<code>DataSource</code>，配置了对应的<code>dbCreate</code>和<code>url</code>属性。在<code>Config.groovy</code>中也可以使用这样的语法。
</p><h4>打包以及切换环境</h4><p class="paragraph">grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4. 命令行" class="guide">命令行</a>中可以指定运行时的环境，形式如下：
</p><div class="code"><pre>grails [environment] [command name]</pre></div><p class="paragraph">其中的environment参数分别用<code>dev</code>,<code>prod</code>,<code>test</code>指代开发环境（development），产品环境（production）以及测试环境（test），例如我们想在测试环境中创建war文件，可以执行如下命令：
</p><div class="code"><pre>grails test war</pre></div><p class="paragraph">如果自定义了其他的环境，可以在命令行中通过<code>grails.env</code>参数指定环境，例如:
</p><div class="code"><pre>grails -Dgrails.env=UAT run-app</pre></div><p class="paragraph"></p><h4>在程序中检测环境</h4><p class="paragraph">在Gant脚本或者启动类中，可以通过<a href="http://www.kuqin.com/grails-doc-1.0/api/grails/util/GrailsUtil.html" class="api">GrailsUtil</a>类来判断运行的环境，例如：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.util.GrailsUtil<p class="paragraph">...</p><p class="paragraph"><span class="java-keyword">switch</span>(GrailsUtil.environment) {
	<span class="java-keyword">case</span> <span class="java-quote">"development"</span>:
	   configureForDevelopment()
	<span class="java-keyword">break</span>
	<span class="java-keyword">case</span> <span class="java-quote">"production"</span>:
	   configureForProduction()
	<span class="java-keyword">break</span> 
}</p></pre></div>
<h2><a name="3.3 数据源">3.3 数据源</a></h2>由于Grails是基于Java之上的，所以需要读者有一定的关于JDBC的知识。<p class="paragraph">首先，如果要使用HSQL之外其它的数据库，需要有相应的JDBC Driver（驱动），例如对于MySQL需要有 <a href="http://www.mysql.com/products/connector/j/%E3%80%82" target="blank">Connector/J</a></p><p class="paragraph">这些数据库驱动一般都是JAR的形式发布，只需要把这些JAR文件放到工程下的<code>lib</code>目录下即可。</p><p class="paragraph">在放置完JDBC驱动后，我们需要熟悉以下位于<code>grails-app/conf/</code>下的Grails数据库配置文件<code>DataSoruce.groovy</code>。初始状态下该文件会包括如下选项:
</p><ul class="star">
<li><code>driverClassName</code> - JDBC 驱动（driver）的类名</li>
<li><code>username</code> - 用来创建JDBC连接的用户名</li>
<li><code>password</code> - 用来创建JDBC连接的密码</li>
<li><code>url</code> - 数据库的 JDBC URL</li>
<li><code>dbCreate</code> - 是否根据域模型类自动创建数据库</li>
<li><code>pooling</code> - 是否使用数据连接池(默认设置为true)</li>
<li><code>logSql</code> - 启动sql日志记录</li>
</ul><p class="paragraph">一个典型的MySQL的配置如下：
</p><pre class="bq"><code>                             
dataSource {
	pooling = true
	dbCreate = "update"
	url = "jdbc:mysql://localhost/yourDB"
	driverClassName = "com.mysql.jdbc.Driver"
	username = "yourUser"
	password = "yourPassword"	
}</code></pre><p class="paragraph"></p><h2><a name="3.3.1 数据源和环境">3.3.1 数据源和环境</a></h2>之前的示例前提是假设我们在development,production和test等环境下的配置一样。<p class="paragraph">不过Grails中的数据源是可以根据不同环境来进行不同的配置，例如：
</p><div class="code"><pre>dataSource {
	// common settings here
}                     
environments {
  production {
     dataSource {
          url = <span class="java-quote">"jdbc:mysql://liveip.com/liveDb"</span>					
     }			
  }
}</pre></div>
<h2><a name="3.3.2 JNDI数据源">3.3.2 JNDI数据源</a></h2>由于J2EE容器一般都支持根据<a href="http://java.sun.com/products/jndi/" target="blank">Java Naming and Directory Interface</a> (JNDI)来查找数据源。<p class="paragraph">所以Grails也提供了根据JNDI来配置数据源的方式,示例如下：
</p><pre class="bq"><code>
dataSource {
    jndiName = "java:comp/env/myDataSource"
}</code></pre><p class="paragraph">虽然J2EE容器间定义JNDI名称格式差别很大，但是你定义<code>DataSource</code>的方式依旧是相同的。
</p><h2><a name="3.3.3 自动数据库移植">3.3.3 自动数据库移植</a></h2><code>DataSource.groovy</code>文件中的<code>dbCreate</code>属性十分重要，因为它可以用来指定是否自动根据<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM</a>类来创建数据库表。其可选值为：
<ul class="star">
<li><code>create-drop</code> - 当Grails运行时删除并重新建立数据库</li>
<li><code>create</code> - 如果数据库不存在则创建数据库，存在则不作任何修改</li>
<li><code>update</code> - 如果数据库不存在则创建数据库，存在则进行修改</li>
</ul><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.2 环境" class="guide">开发环境（development）</a>下<code>dbCreate</code>属性默认设置为create-drop:
</p><div class="code"><pre>dataSource {
	dbCreate = <span class="java-quote">"create-drop"</span> // one of 'create', 'create-drop','update'
}</pre></div><p class="paragraph">这样在Grails应用程序启动的时候会删除掉原来的数据库并重新建立，在production环境中通常需要修改该值。
</p><blockquote class="note">
虽然Grails暂时不支持Rails方式的移植，不过可以通过安装<a href="http://www.liquibase.org/manual/latest/grails.html" target="blank">LiquiBase</a>和<a href="http://code.google.com/p/dbmigrate/wiki/Grails" target="blank">DbMigrate</a>两个插件来实现，在控制台中可以通过<code>grails list-plugins</code>命令来查看这两个插件。
</blockquote>
<h2><a name="3.4 外部配置">3.4 外部配置</a></h2>对于大多数情况来说，使用位于<code>grails-app/conf</code>目录下的<code>DataSource.groovy</code>文件中的默认配置已经够用了。不过有些情况下需要在工程项目以外来保存这些配置。例如在打包WAR时，有时候需要将配置文件放置于工程之外来避免由于配置的修改导致WAR包的重新打包。<p class="paragraph">为了支持这种外部配置，需要在<code>Config.groovy</code>文件中首先指定<code>grails.config.locations</code>选项，以便告诉Grails应该到何处去加载外部配置文件。
</p><div class="code"><pre>grails.config.locations = [ <span class="java-quote">"classpath:${appName}-config.properties"</span>,
                            <span class="java-quote">"classpath:${appName}-config.groovy"</span>,
                            <span class="java-quote">"file:${userHome}/.grails/${appName}-config.properties"</span>,
                            <span class="java-quote">"file:${userHome}/.grails/${appName}-config.groovy"</span>]</pre></div><p class="paragraph">在上例中，我们加载了不同classpath下以及USER_HOME下的配置文件，包括Java属性文件和<a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 配置文件。</p><p class="paragraph">最终可以通过<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a>对象的<code>config</code>属性来获得这些配置文件中的值。</p><p class="paragraph"></p><blockquote class="note">
Grails还支持<a href="http://www.springframework.org/" target="blank">Spring</a> 中的属性占位（property place holders）和属性重载（property override）配置，关于这些方面的详细内容请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14. Grails和Spring" class="guide">Grails和Spring</a>章节。
</blockquote>
<h2><a name="3.5 定义版本">3.5 定义版本</a></h2><h4>版本定义基础</h4><p class="paragraph">Grails内置支持应用程序的版本定义。当使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-app.html" class="commandLine">create-app</a>创建一个应用程序的时候，该应用程序的版本即被设置为<code>0.1</code>。版本是存储在项目文件的根目录下的<code>application.properties</code>元文件中。</p><p class="paragraph">要改变应用程序的版本可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/set-version.html" class="commandLine">set-version</a>命令，例如；
</p><div class="code"><pre>grails set-version 0.2</pre></div><p class="paragraph">Grials在很多的命令中都会使用到版本，例如<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/war.html" class="commandLine">war</a>命令就会在生成的WAR文件最后加上应用程序的版本。
</p><h4>运行时判断版本</h4><p class="paragraph">由于Grails支持应用程序元数据（metadata），所以可以通过<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a>类来得到当前的版本信息。例如在控制其中可以使用内置的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/grailsApplication.html" class="controllers">grailsApplication</a>变量。
</p><div class="code"><pre>def version = grailsApplication.metadata['app.version']</pre></div><p class="paragraph">如果想查看Grails的版本，可以有两种方式：
</p><div class="code"><pre>def grailsVersion = grailsApplication.metadata['app.grails.version']</pre></div><p class="paragraph">或者 <code>GrailsUtil</code>类：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.util.*
def grailsVersion = GrailsUtil.grailsVersion</pre></div><p class="paragraph"></p><p class="paragraph"></p><h1><a name="4. 命令行">4. 命令行</a></h1>Grails的命令行是基于<a href="http://groovy.codehaus.org/Gant" target="blank">Gant</a>--用Groovy对<a href="http://ant.apache.org/" target="blank">Apache Ant</a>进行的简单封装之上的。<p class="paragraph">不过Grails通过使用规约以及grails命令进一步对其进行了扩展。当输入:
</p><div class="code"><pre>grails [command name]</pre></div>              
时，Grails会在以下目录中搜索相应的Gant脚本并执行：
<ul class="star">
<li><code>USER_HOME/.grails/scripts</code></li>
<li><code>PROJECT_HOME/scripts</code></li>
<li><code>PROJECT_HOME/plugins/*/scripts</code></li>
<li><code>GRAILS_HOME/scripts</code></li>
</ul><p class="paragraph">Grails会自动将命令名称从小写形式转换成驼峰形式（camel case）来查找相应脚本文件，例如如果输入:</p><p class="paragraph"></p><div class="code"><pre>grails run-app</pre></div><p class="paragraph">那么Grails会去搜索以下脚本文件：
</p><ul class="star">
<li><code>USER_HOME/.grails/scripts/RunApp.groovy</code></li>
<li><code>PROJECT_HOME/scripts/RunApp.groovy</code></li>
<li><code>PROJECT_HOME/plugins/*/scripts/RunApp.groovy</code></li>
<li><code>GRAILS_HOME/scripts/RunApp.groovy</code></li>
</ul><p class="paragraph">如果有多个匹配文件，Grails会让你选择其中的一个来执行。当Gant脚本执行的时候，“default”目标（Target）也会一同执行。</p><p class="paragraph">要想获得有效命令的清单，可以输入:
</p><div class="code"><pre>grails help</pre></div><p class="paragraph">这样会列出Grails中可以使用命令清单，如：
</p><div class="code"><pre>Usage (optionals marked with *): 
grails [environment]* [target] [arguments]*<p class="paragraph">Examples: 
grails dev run-app	
grails create-app books</p><p class="paragraph">Available Targets (type grails help 'target-name' <span class="java-keyword">for</span> more info):
grails bootstrap
grails bug-report
grails clean
grails compile
...</p></pre></div><p class="paragraph"></p><blockquote class="note">
关于单个命令的更多详细信息请参考左边菜单的命令行指南。
</blockquote>
<h2><a name="4.1 创建Gant脚本">4.1 创建Gant脚本</a></h2>通过在项目的根目录下运行<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-script.html" class="commandLine">create-script</a>命令可以创建Gant脚本。例如：
<div class="code"><pre>grails create-script compile-sources</pre></div><p class="paragraph">这条命令会在<code>scripts</code>目录下创建一个名为<code>CompileSources.groovy</code>的脚本文件。Gant脚本本身类似于Groovy代码，但是它可以支持目标（Target）以及它们之间的依赖关系。
</p><div class="code"><pre>target(<span class="java-keyword">default</span>:<span class="java-quote">"The <span class="java-keyword">default</span> target is the one that gets executed by Grails"</span>) {
	depends(clean, compile)
}
target(clean:<span class="java-quote">"Clean out things"</span>) {
	Ant.delete(dir:<span class="java-quote">"output"</span>)
}
target(compile:<span class="java-quote">"Compile some sources"</span>) {
	Ant.mkdir(dir:<span class="java-quote">"mkdir"</span>)
	Ant.javac(srcdir:<span class="java-quote">"src/java"</span>, destdir:<span class="java-quote">"output"</span>)
}</pre></div><p class="paragraph">从如上脚本中可以看出，其中有一个默认可以访问<a href="http://ant.apache.org/manual/index.html" target="blank">Apache Ant API</a>的<code>Ant</code>变量。</p><p class="paragraph">如上<code>default</code>目标中所使用的一样，你也可以使用<code>depends</code>方法来指定其依赖的其他目标。
</p><h2><a name="4.2 可复用的Grails脚本">4.2 可复用的Grails脚本</a></h2>Grails的命令行中还可以重用许多有用的脚本代码(查看所有命令的入门指南请参考命令行指南)，其中最主要的有<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/compile.html" class="commandLine">compile</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/package.html" class="commandLine">package</a>和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/bootstrap.html" class="commandLine">bootstrap</a>脚本。<p class="paragraph">以<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/bootstrap.html" class="commandLine">bootstrap</a>脚本为例，以下代码可以在启动时调用Spring中的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>实例来访问数据源：
</p><div class="code"><pre>Ant.property(environment:<span class="java-quote">"env"</span>)                             
grailsHome = Ant.antProject.properties.<span class="java-quote">"env.GRAILS_HOME"</span><p class="paragraph">includeTargets &lt;&lt; <span class="java-keyword">new</span> File ( <span class="java-quote">"${grailsHome}/scripts/Bootstrap.groovy"</span> )</p><p class="paragraph">
target ('<span class="java-keyword">default</span>': <span class="java-quote">"Load the Grails interactive shell"</span>) {
	depends( configureProxy, packageApp, classpath, loadApp, configureApp )</p><p class="paragraph">	Connection c 
	<span class="java-keyword">try</span> {
		// <span class="java-keyword">do</span> something with connection
		c = appCtx.getBean('dataSource').getConnection()
	}
	<span class="java-keyword">finally</span> {
		c?.close()
	}
}</p></pre></div> 
<h2><a name="4.3 脚本中的事件">4.3 脚本中的事件</a></h2>Grails提供了调用脚本事件的能力，这些事件是在Grails目标（target）和插件脚本执行时所触发的。<p class="paragraph">此机制宗旨是简单和自由，因此无法得到所有可能触发事件的列表。这样当没有核心目标脚本触发事件的时候，就有可能调用插件脚本所触发的事件。
</p><h4>定义事件句柄</h4><p class="paragraph">事件句柄是在<code>scripts</code>/目录下（插件脚本）或者<code>USER_HOME</code>目录下的<code>.grails/scripts/</code>目录下的<code>Events.groovy</code>脚本中定义的。当一个事件触发的时候会调用所有的事件脚本，所以可以使用10个插件脚本或者使用一个用户自定义脚本来处理事件。</p><p class="paragraph">在<code>Events.groovy</code>中是通过以“event”开头命名的代码块来定义事件的。如下例所示，请将下例放入/scripts目录。
</p><div class="code"><pre>eventCreatedArtefact = { type, name -&gt;
   println <span class="java-quote">"Created $type $name"</span>
}<p class="paragraph">eventStatusUpdate = { msg -&gt;
   println msg
}</p><p class="paragraph">eventStatusFinal = { msg -&gt;
   println msg
}</p></pre></div><p class="paragraph">可以看到其中定义了三个句柄<code>eventCreatedArtefact</code>,<code>eventStatusUpdate</code>和<code>eventStatusFinal</code>。Grails也提供其他一些标准的事件，可以在命令行参考指南中找到。例如，<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/compile.html" class="commandLine">compile</a>命令会触发如下事件。
</p><ul class="star">
<li><code>CompileStart</code> - 当编译开始时触发，指定编译的类型??源文件或者测试</li>
<li><code>CompileEnd</code> - 当编译结束时触发，指定编译的类型??源文件或者测试</li>
</ul><p class="paragraph"></p><h4>触发事件</h4><p class="paragraph">如下例所示，要触发Init.groovy脚本的事件只需引入它并且调用event()闭包。
</p><div class="code"><pre>Ant.property(environment:<span class="java-quote">"env"</span>)
grailsHome = Ant.antProject.properties.<span class="java-quote">"env.GRAILS_HOME"</span>
includeTargets &lt;&lt; <span class="java-keyword">new</span> File ( <span class="java-quote">"${grailsHome}/scripts/Init.groovy"</span> )<p class="paragraph">
event(<span class="java-quote">"StatusFinal"</span>, [<span class="java-quote">"Super duper plugin action complete!"</span>])</p></pre></div><p class="paragraph"></p><h4>常用事件</h4><p class="paragraph">下表列出了一些常用的事件：
<table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tbody><tr><th>事件</th><th>参数</th><th>描述</th></tr><tr class="table-odd"><td>StatusUpdate</td><td>message</td><td>传入的字符串表明当前脚本的状态/进度</td></tr><tr class="table-even"><td>StatusError</td><td>message</td><td>传入的字符串表明当前脚本的错误信息</td></tr><tr class="table-odd"><td>StatusFinal</td><td>message</td><td>传入的字符串表明最后脚本的状态信息，比如当一个目标/任务（target）完成时，即便是脚本环境中并并存在目标，照样可以显示状态信息</td></tr><tr class="table-even"><td>CreatedArtefact</td><td>artefactType,artefactName</td><td>在一个create-xxxx脚本完成并且创建了一个工件的时候调用</td></tr><tr class="table-odd"><td>CreatedFile</td><td>fileName</td><td>在一个工程的源文件被创建的时候调用，但不包括被Grails管理的那些常量文件</td></tr><tr class="table-even"><td>Exiting</td><td>returnCode</td><td>在脚本环境即将完全终止的时候被调用</td></tr><tr class="table-odd"><td>PluginInstalled</td><td>pluginName</td><td>在一个插件被安装以后被调用</td></tr><tr class="table-even"><td>CompileStart</td><td>kind</td><td>在编译开始的时候调用，传入的参数是编译的源文件或者测试文件的种类</td></tr><tr class="table-odd"><td>CompileEnd</td><td>kind</td><td>在编译结束的时候调用，传入的参数是编译的源文件或者测试文件的种类</td></tr><tr class="table-even"><td>DocStart</td><td>kind</td><td>在生成文档即将开始的时候调用<strike class="strike">包括javadoc或者groovydoc</strike></td></tr><tr class="table-odd"><td>DocEnd</td><td>kind</td><td>在生成文档结束的时候调用包括javadoc或者groovydoc</td></tr><tr class="table-even"><td>SetClasspath</td><td>rootLoader</td><td>在classpath初始化其间调用，这样插件就可以使用rootLoader.addURL(...)来设置classpath参数。注意！此设置classpath参数是在事件脚本加载之后，因此你不能用此classpath来加载所需的类，即便是你在事件脚本中已经导入，但是如果你是通过名字来加载类，那是可以的。</td></tr><tr class="table-odd"><td>PackagingEnd</td><td>none</td><td>在打包完完毕的时候调用（在Jetty服务器启动之前，但在web.xml生成之后） at the end of packaging (which is called prior to the Jetty server being started and after web.xml is generated)</td></tr><tr class="table-even"><td>ConfigureJetty</td><td>Jetty Server object</td><td>在Jetty web服务器配置初始化之后调用</td></tr></tbody></table>
</p><h2><a name="4.4 Ant和Maven">4.4 Ant和Maven</a></h2><h4>Ant集成</h4><p class="paragraph">当通过create-app命令创建了一个Grails应用时，Grails会自动创建一个<a href="http://ant.apache.org/" target="blank">Apache Ant</a> 的<code>build.xml</code>文件，其中包括以下目标：
</p><ul class="star">
<li><code>clean</code> - 清除Grails应用</li>
<li><code>war</code> - 创建WAR文件</li>
<li><code>test</code> - 运行单元测试</li>
<li><code>deploy</code> - 缺省是空，但是可以被用来实现自动发布。</li>
</ul><p class="paragraph">这几个目标都可以通过Ant来运行，如:
</p><div class="code"><pre>ant war</pre></div><p class="paragraph">这个<code>build.xml</code>文件可以调用Grails中的命令，这样就可以将Grails应用与持续集成服务器，如<a href="http://cruisecontrol.sourceforge.net/" target="blank">CruiseControl</a> 和<a href="https://hudson.dev.java.net/">Hudson</a> 集成起来。
</p><h4>Maven 集成</h4><p class="paragraph">Grails暂时不支持<a href="http://maven.apache.org/" target="blank">Maven</a> ，但是已经有了一个名为<a href="http://forge.octo.com/confluence/display/MTG/Home" target="blank">Maven Tools for Grails</a> 的项目，它可以对当前的Grails应用创建一个POM，这样就可以将Grails集成到Maven 的生命周期中。</p><p class="paragraph">要获得更多信息请访问<a href="http://forge.octo.com/confluence/display/MTG/Home" target="blank">Maven Tools for Grails</a> 项目网站
</p><h1><a name="5. 对象关系映射(GORM)">5. 对象关系映射(GORM)</a></h1>领域类是任何商业应用的核心，它们保存这这些商业过程的状态并且实现相应的行为，它们还通过一对一或者一对多的关系相互联系在一起。<p class="paragraph">GORM是Grails的对象关系映射（ORM）的实现，实际上它使用的是Hibernate3（非常流行和灵活的开源ORM解决方案），但因为有Groovy的动态特性支持，因此GORM既支持动态类型也支持静态类型，再加上Grails的规约，现在创建Grails的领域类只需要更少的配置就可以了。</p><p class="paragraph">你也可以用Java类写Grails的领域类。集成Hibernate的相关章节介绍了如何使用Java来写Grails领域类，但又不失动态持久方法的优势。以下是GORM实践的预览：
</p><div class="code"><pre>def book = Book.findByTitle(<span class="java-quote">"Groovy in Action"</span>)<p class="paragraph">book
  .addToAuthors(name:<span class="java-quote">"Dierk Koenig"</span>)
  .addToAuthors(name:<span class="java-quote">"Guillaume LaForge"</span>)
  .save()</p></pre></div><p class="paragraph"></p><h2><a name="5.1 快速指南">5.1 快速指南</a></h2>用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-domain-class.html" class="commandLine">create-domain-class</a> 命令创建一个domain类:
<div class="code"><pre>grails create-domain-class Person</pre></div><p class="paragraph">这将在 <code>grails-app/domain/Person.groovy</code> 中创建下面的类： 
</p><div class="code"><pre>class Person {	
}</pre></div><p class="paragraph"></p><blockquote class="note">
如果你在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3 数据源" class="guide">数据源</a>中将 <code>dbCreate</code> 属性设置为"update", "create" 或 "create-drop"，Grails会自动生成或修改数据库中的表。
</blockquote><p class="paragraph">你可以通过添加属性来自定义类：
</p><div class="code"><pre>class Person {	
	<span class="java-object">String</span> name
	<span class="java-object">Integer</span> age
	Date lastVisit
}</pre></div><p class="paragraph">一旦你有了一个domain类，你可以通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/shell.html" class="commandLine">shell</a>或 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/console.html" class="commandLine">console</a> 中操纵它：</p><p class="paragraph"></p><div class="code"><pre>grails console</pre></div><p class="paragraph">这将会为你载入一个可以输入Groovy命令的交互式图形界面。</p><p class="paragraph"></p><h2><a name="5.1.1 基本的CRUD">5.1.1 基本的CRUD</a></h2>尝试执行一些基本的CRUD (Create/Read/Update/Delete)操作。
<h4>创建</h4><p class="paragraph">用Groovy的new 操作符创建一个domain类的实例，设置它的属性,然后调用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a>:</p><p class="paragraph"></p><div class="code"><pre>def p = <span class="java-keyword">new</span> Person(name:<span class="java-quote">"Fred"</span>, age:40, lastVisit:<span class="java-keyword">new</span> Date())
p.save()</pre></div><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a> 方法将会使用底层的Hibernate ORM将你的实例持久化到数据库。</p><p class="paragraph"></p><h4>读取</h4><p class="paragraph">Grails自动在你的domain类中添加了一个隐含的<code>id</code>属性，你可以用它来取回对象：
</p><div class="code"><pre>def p = Person.get(1)
assert 1 == p.id</pre></div><p class="paragraph">这里使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/get.html" class="domainClasses">get</a>方法，它会根据数据库标识符从数据库中取回一个<code>Person</code>对象。</p><p class="paragraph"></p><h4>更新</h4><p class="paragraph">要更新一个实例，只要设置一下属性，然后也是简单的调用一下<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a>：</p><p class="paragraph"></p><div class="code"><pre>def p = Person.get(1)
p.name = <span class="java-quote">"Bob"</span>
p.save()</pre></div><p class="paragraph"></p><h4>删除</h4><p class="paragraph">使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/delete.html" class="domainClasses">delete</a>来删除一个实例:
</p><div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph"></p><h2><a name="5.2 在GORM中进行领域建模">5.2 在GORM中进行领域建模</a></h2>当构建一个Grials应用的时候，你必须事先考虑需要解决的问题域（problem domain）。比如，如果你要构建一个<a href="http://www.amazon.com/" target="blank">Amazon</a> 书店，你就要考虑书，作者，顾客和出版商等等。<p class="paragraph">这些在GORM中是作为Groovy类来建模的，因此<code>Book</code>类要有title,release date,ISBN number等属性。在下面的几节将演示在GORM中如何为领域建模。</p><p class="paragraph">要创建一个领域类，运行 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-domain-class.html" class="commandLine">create-domain-class</a>:</p><p class="paragraph"></p><div class="code"><pre>grails create-domain-class Book</pre></div><p class="paragraph">生成了<code>grails-app/domain/Book.groovy</code>:
</p><div class="code"><pre>class Book {	
}</pre></div><p class="paragraph"></p><blockquote class="note">
如果你想使用包，你可以把Book.groovy类移入domain目录下的一个子目录，并根据Groovy(也是Java)的包规则添加一个合适的<code>package</code>声明。
</blockquote><p class="paragraph">上面的类将会在数据库中自动映射一个 <code>book</code> (跟类同名)的表。映射规则可以通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM的DSL</a>来自定义。</p><p class="paragraph">现在，你有了一个领域类，你可以把它的属性定义为Java语言的类型.比如:
</p><div class="code"><pre>class Book {
	<span class="java-object">String</span> title
	Date releaseDate
	<span class="java-object">String</span> ISBN
}</pre></div><p class="paragraph">
每个属性映射到数据库中的一个列，列名的规则命名规则是全部小写并用下划线分隔。比如<code>releaseDate</code>映射为列<code>release_date</code>上。SQL类型是根据Java类型来自动检测的，你也可以用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">约束</a> 或者<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM DSL</a>自定义映射类型。
</p><h2><a name="5.2.1 GORM中的关联">5.2.1 GORM中的关联</a></h2>关联定义了domain类之间如何互相交互。除非在两端都显式的指定，否则一个关联只存在于定义它的那端。<p class="paragraph"></p><h2><a name="5.2.1.1 一对一">5.2.1.1 一对一</a></h2>一对一的关联是最简单的关联。它只要定义一个属性的类型为另一个domain类就可以了。看下面的例子:<p class="paragraph"></p><h5>示例 A</h5><p class="paragraph"></p><div class="code"><pre>class Face {
    Nose nose
}
class Nose {	
}</pre></div><p class="paragraph">这样我们就有了一个从 <code>Face</code> 到 <code>Nose</code>的单向关联。要把这个关联变为双向的，只要在另一端定义一下:</p><p class="paragraph"></p><h5>示例 B</h5><p class="paragraph"></p><div class="code"><pre>class Face {
    Nose nose
}
class Nose {	
	Face face
}</pre></div><p class="paragraph">这样就是双向关联了。但是，这种情况下，关联的双方并不能级联更新。</p><p class="paragraph">看下面的变化:
</p><h5>示例 C</h5><p class="paragraph"></p><div class="code"><pre>class Face {
    Nose nose
}
class Nose {	
	<span class="java-keyword">static</span> belongsTo = [face:Face]
}</pre></div><p class="paragraph">在这里，我们使用<code>belongsTo</code> 表示<code>Nose</code> "属于" Face。其结果就是我们创建并保存它时，数据库可以_级联_更新/插入 <code>Nose</code>:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Face(nose:<span class="java-keyword">new</span> Nose()).save()</pre></div><p class="paragraph">上面这个例子会将face和nose都保存。注意反向的操作并不可行，它会导致一个对于临时<code>Face</code>对象的错误:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Nose(face:<span class="java-keyword">new</span> Face()).save() // will cause an error</pre></div><p class="paragraph"><code>belongsTo</code> 的另一个重要作用是，如果你删除了一个<code>Face</code> 实例，那么相关的<code>Nose</code>也会被删除:</p><p class="paragraph"></p><div class="code"><pre>def f = Face.get(1)
f.delete() // both Face and Nose deleted</pre></div><p class="paragraph">没有 <code>belongsTo</code> 的话，将不会级联删除，你会得到一个外键约束的错误，除非你手工去删除Nose:</p><p class="paragraph"></p><div class="code"><pre>// error here without belongsTo
def f = Face.get(1)
f.delete()<p class="paragraph">// no error as we explicitly delete both
def f = Face.get(1)
f.nose.delete()
f.delete()</p></pre></div><p class="paragraph">你可以保持前面那种单向关联的关系，并允许级联保存/更新:</p><p class="paragraph"></p><div class="code"><pre>class Face {
    Nose nose
}
class Nose {	
	<span class="java-keyword">static</span> belongsTo = Face
}</pre></div><p class="paragraph">注意，在这种情况下，因为我们没有在<code>belongsTo</code>声明中使用映射语法明确地声明这个关联,Grails将认为它是一个单向关联。下面是对这三个例子的总结:</p><p class="paragraph"><img border="0" class="center" src="./Grails开源框架 1.0 - 使用指南_files/GORM-1to1.png">
</p><h2><a name="5.2.1.2 一对多">5.2.1.2 一对多</a></h2>一对多的关系是指，当一个类(比如<code>Author</code>)拥有另一个类(<code>Book</code>)的多个实例这种情况。在Grails中，你可以使用 <code>hasMany</code> 来定义这种关联：<p class="paragraph"></p><div class="code"><pre>class Author {
    <span class="java-keyword">static</span> hasMany = [ books : Book ]<p class="paragraph">    <span class="java-object">String</span> name
}
class Book {
	<span class="java-object">String</span> title
}</p></pre></div><p class="paragraph">这样我们有了一个一对多的单向关联。Grails在数据库级别将默认使用外键映射来映射这种关联。</p><p class="paragraph"></p><blockquote class="note">
<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM DSL</a> 允许使用连接表作为代替来映射单向关联。
</blockquote><p class="paragraph">Grails 将会根据<code>hasMany</code> 设置为domain类自动注入一个类型为java.util.Set的属性。这个可以被用来遍历集合:</p><p class="paragraph"></p><div class="code"><pre>def a = Author.get(1)<p class="paragraph">a.books.each {
	println it.title
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
Grails使用的默认抓取策略是"lazy",这意味这集合将会被延迟初始化。如果你不小心的话,这可能导致 <a href="http://www.javalobby.org/java/forums/t20533.html" target="blank">n+1 问题</a> .<p class="paragraph">如果你需要"eager"抓取，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM DSL</a> 或者指定立即抓取作为<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4 GORM查询" class="guide">查询</a>的一部分。
</p></blockquote><p class="paragraph">
默认的级联行为是级联保存和更新，但不级联删除，除非你也指定了 <code>belongsTo</code> ：</p><p class="paragraph"></p><div class="code"><pre>class Author {
    <span class="java-keyword">static</span> hasMany = [ books : Book ]<p class="paragraph">    <span class="java-object">String</span> name
}
class Book {
	<span class="java-keyword">static</span> belongsTo = [author:Author]
	<span class="java-object">String</span> title
}</p></pre></div><p class="paragraph">如果你有两个相同类型的属性，他们都是一对多关系的多方，你必须用<code>mappedBy</code>来指定他们分别映射的是哪个集合:</p><p class="paragraph"></p><div class="code"><pre>class Airport {
	<span class="java-keyword">static</span> hasMany = [flights:Flight]
	<span class="java-keyword">static</span> mappedBy = [flights:<span class="java-quote">"departureAirport"</span>]
}
class Flight {
	Airport departureAirport
	Airport destinationAirport
}</pre></div><p class="paragraph">如果你有多个映射到不同属性的集合，也需要这样:
</p><div class="code"><pre>class Airport {
	<span class="java-keyword">static</span> hasMany = [outboundFlights:Flight, inboundFlights:Flight]
	<span class="java-keyword">static</span> mappedBy = [outboundFlights:<span class="java-quote">"departureAirport"</span>, inboundFlights:<span class="java-quote">"destinationAirport"</span>]
}
class Flight {
	Airport departureAirport
	Airport destinationAirport
}</pre></div><p class="paragraph"></p><h2><a name="5.2.1.3 多对多">5.2.1.3 多对多</a></h2>Grails支持多对多关联，这种关联需要在关联的两方都定义<code>hasMany</code>，并在关联的被拥有方定义<code>belongsTo</code>:
<div class="code"><pre>class Book {
   <span class="java-keyword">static</span> belongsTo = Author
   <span class="java-keyword">static</span> hasMany = [authors:Author]
   <span class="java-object">String</span> title
}
class Author {
   <span class="java-keyword">static</span> hasMany = [books:Book]
   <span class="java-object">String</span> name
}</pre></div><p class="paragraph">Grials在数据库层使用连接表来映射多对多关联。关联的拥有方，在这里是<code>Author</code>,负责持久化这个关联，并且它是唯一可以级联保存对方的一方。</p><p class="paragraph">比如下面的代码可以工作，并会级联保存:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Author(name:<span class="java-quote">"Stephen King"</span>)
		.addToBooks(<span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Stand"</span>))
		.addToBooks(<span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Shining"</span>))		
		.save()</pre></div><p class="paragraph">但是下面的代码只保存 <code>Book</code> 而不保存authors!
</p><div class="code"><pre><span class="java-keyword">new</span> Book(name:<span class="java-quote">"Groovy in Action"</span>)
		.addToAuthors(<span class="java-keyword">new</span> Author(name:<span class="java-quote">"Dierk Koenig"</span>))
		.addToAuthors(<span class="java-keyword">new</span> Author(name:<span class="java-quote">"Guillaume Laforge"</span>))		
		.save()</pre></div><p class="paragraph">这正是我们期望的行为，跟Hibernate中一样，多对多关联中只有一方可以管理关联。</p><p class="paragraph"></p><blockquote class="warning">
Grails的 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架" class="guide">脚手架</a> 特性当前还不支持多对多关联，因此你必须自己写代码来管理关联。 
</blockquote><p class="paragraph"></p><h2><a name="5.2.2 GORM的组合">5.2.2 GORM的组合</a></h2>跟<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.2.1 GORM中的关联" class="guide">关联</a>一样,Grails支持组合的概念。在这种情况下,要映射到一个独立的表的类,可以嵌入到当前表。比如:<p class="paragraph"></p><div class="code"><pre>class Person {
	Address homeAddress
	Address workAddress
	<span class="java-keyword">static</span> embedded = ['homeAddress', 'workAddress']
}
class Address {
	<span class="java-object">String</span> number
	<span class="java-object">String</span> code
}</pre></div><p class="paragraph">映射的结果看起来像下面这样:</p><p class="paragraph"><img border="0" class="center" src="./Grails开源框架 1.0 - 使用指南_files/5.2.2-composition.jpg"></p><p class="paragraph"></p><blockquote class="note">
如果你在<code>grails-app/domain</code> 目录下一个单独的Groovy文件中定义了 <code>Address</code> 类，你还是会得到一个 <code>address</code> 表。如果你不想这样，你可以使用Groovy可以在一个文件中定义多个类的特性，在<code>grails-app/domain/Person.groovy</code> 文件中在 <code>Person</code> 类的下面定义 <code>Address</code> 类。
</blockquote><p class="paragraph"></p><h2><a name="5.2.3 GORM的继承">5.2.3 GORM的继承</a></h2>GORM支持从抽象基类和从具体实体类继承。比如：<p class="paragraph"></p><div class="code"><pre>class Content {
     <span class="java-object">String</span> author
}
class BlogEntry <span class="java-keyword">extends</span> Content {
    URL url
}
class Book <span class="java-keyword">extends</span> Content {
    <span class="java-object">String</span> ISBN
}
class PodCast <span class="java-keyword">extends</span> Content {
    <span class="java-object">byte</span>[] audioStream
}</pre></div><p class="paragraph">在上面的例子中我们有个叫<code>Content</code> 的父类，然后不同的子类有更多它们各自特定的行为。</p><p class="paragraph"></p><h4>继承映射的思考</h4><p class="paragraph">在数据库级别Grails默认使用每个类分层结构一个表(uses table-per-hierarchy)的映射策略，有一个辨别标识(discriminator)列叫 <code>class</code> ，因此父类<code>Content</code> 和它的子类(<code>BlogEntry</code>, <code>Book</code> 等等.)共享同一个表。</p><p class="paragraph">每个类分层结构一个表(uses table-per-hierarchy)有一个副作用，就是你继承映射中的属性不能有非空约束。一个选择是使用每个子类一个表(table-per-subclass)映射，它可以通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM DSL</a>设置。</p><p class="paragraph">但是，过度的使用继承和每个子类一个表(table-per-subclass)的映射策略，会导致过度使用连接查询，使得查询性能很差。通常我们建议保持简单，只有在你确实需要继承的时候才用它。</p><p class="paragraph"></p><h4>多态查询</h4><p class="paragraph">使用继承的好处是你获得了多态查询的能力，比如在超类<code>Content</code> 上使用 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/list.html" class="domainClasses">list</a> 方法将会返回 <code>Content</code>的所有子类:</p><p class="paragraph"></p><div class="code"><pre>def content = Content.list() // list all blog entries, books and pod casts
content = Content.findAllByAuthor('Joe Bloggs') // find all by author<p class="paragraph">def podCasts = PodCast.list() // list only pod casts</p></pre></div>
<h2><a name="5.2.4 集合、列表和映射">5.2.4 集合、列表和映射</a></h2><h4>对象集合(Set)</h4><p class="paragraph">当你在GROM中定义一个关联的时候,默认地使用<code>java.util.Set</code> ,它是一个无序并不能包含重复对象的集合.换句话说,当你写了下面代码:</p><p class="paragraph"></p><div class="code"><pre>class Author {
   <span class="java-keyword">static</span> hasMany = [books:Book]
}</pre></div><p class="paragraph">GORM注入的books属性是一个<code>java.util.Set</code>.这里有一个问题，当访问这个集合时是无序的,这可能不是你想要的.为了获得自定义的顺序你可以将这个集合设置为<code>SortedSet</code>:</p><p class="paragraph"></p><div class="code"><pre>class Author {
   SortedSet books
   <span class="java-keyword">static</span> hasMany = [books:Book]
}</pre></div><p class="paragraph"> 在这里使用了<code>java.util.SortedSet</code> 实现,这就意味着你的Book类必须实现 <code>java.lang.Comparable</code> 接口:</p><p class="paragraph"></p><div class="code"><pre>class Book <span class="java-keyword">implements</span> Comparable {
   <span class="java-object">String</span> title
   Date releaseDate = <span class="java-keyword">new</span> Date()<p class="paragraph">   <span class="java-object">int</span> compareTo(obj) {
       releaseDate.compareTo(obj.releaseDate)
   }
}</p></pre></div><p class="paragraph">上面类的结果是Author类的books集合中所有的Book实例将按他们的发布日期排序.</p><p class="paragraph"></p><h4>对象列表</h4><p class="paragraph">如果你只是想能够简单的保持对象按照他们被加进去的顺序排序，并能像数组一样按照索引来引用他们,你可以定义你的集合类型为<code>List</code>:</p><p class="paragraph"></p><div class="code"><pre>class Author {
   List books
   <span class="java-keyword">static</span> hasMany = [books:Book]
}</pre></div><p class="paragraph">在这种情况下当你向books集合中添加一个新元素时,这个顺序将会保存在一个从0开始的列表索引中,因此你可以:</p><p class="paragraph"></p><div class="code"><pre>author.books[0] // get the first book</pre></div><p class="paragraph">这种方法在数据库层的工作原理是:为了在数据库层保存这个顺序,Hibernate创建一个叫做<code>books_idx</code>的列,它保存着该元素在集合中的索引.</p><p class="paragraph">当使用 <code>List</code> 时,元素在保存之前必须先添加到集合中,否则Hibernate会抛出异常(<code>org.hibernate.HibernateException</code>: null index column for collection):</p><p class="paragraph"></p><div class="code"><pre>// This won't work!
def book = <span class="java-keyword">new</span> Book(title: 'The Shining')
book.save()
author.addToBooks(book)<p class="paragraph">// Do it <span class="java-keyword">this</span> way instead.
def book = <span class="java-keyword">new</span> Book(title: 'Misery')
author.addToBooks(book)
author.save()</p></pre></div><p class="paragraph"></p><h4>映射(Maps)对象</h4><p class="paragraph">如果你想要一个简单的 string/value 对map,GROM可以用下面方法来映射:</p><p class="paragraph"></p><div class="code"><pre>class Author {
   Map books // my of ISBN:book names
}<p class="paragraph">def a = <span class="java-keyword">new</span> Author()
a.books = [<span class="java-quote">"1590597583"</span>:<span class="java-quote">"Grails Book"</span>]
a.save()</p></pre></div><p class="paragraph">这种情况map的键和值都必须是字符串.</p><p class="paragraph">如果你想用一个对象的map,那么你可以这样做:</p><p class="paragraph"></p><div class="code"><pre>class Book {
  Map authors
  <span class="java-keyword">static</span> hasMany = [authors:Author]
}<p class="paragraph">def a = <span class="java-keyword">new</span> Author(name:<span class="java-quote">"Stephen King"</span>)</p><p class="paragraph">def book = <span class="java-keyword">new</span> Book()
book.authors = [stephen:a]
book.save()</p></pre></div><p class="paragraph">static <code>hasMany</code> 属性定义了map中元素的类型,map中的key <strong class="bold">必须</strong> 是字符串
</p><h2><a name="5.3 持久化基础">5.3 持久化基础</a></h2>关于Grails要记住的很重要的一点就是，Grails的底层使用<a href="http://www.hibernate.org/" target="blank">Hibernate</a> 来进行持久化.如果您以前使用的是<a href="http://wiki.rubyonrails.org/rails/pages/ActiveRecord" target="blank">ActiveRecord</a> 或者 <a href="http://ibatis.apache.org/" target="blank">iBatis</a> , 您可能会对Hibernate的"session"模型感到有点陌生.<p class="paragraph">本质上,Grails自动绑定Hibernate session到当前正在执行的请求上.这允许你像使用GORM的其他方法一样很自然地使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/delete.html" class="domainClasses">delete</a>方法 .</p><p class="paragraph"></p><h2><a name="5.3.1 保存和更新">5.3.1 保存和更新</a></h2>下面看一个使用 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a> 方法的例子:
<div class="code"><pre>def p = Person.get(1)
p.save()</pre></div><p class="paragraph">Hibernate的一个主要的不同在于当你调用 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a> 时它不需要马上执行任何SQL操作.Hibernate通常将SQL语句分批,最后执行他们.对你来说,这些一般都是由Grails自动完成的,它管理着你的Hibernate session.</p><p class="paragraph">也有一些特殊情况,有时候你可能想自己控制那些语句什么时候被执行,或者用Hibernate的术语来说,就是什么时候session被"flushed".要这样的话,你可以对save方法使用flush参数:</p><p class="paragraph"></p><div class="code"><pre>def p = Person.get(1)
p.save(flush:<span class="java-keyword">true</span>)</pre></div><p class="paragraph">需要注意的是,这时包括保存之前所有等待执行的SQL语句都会同步到数据库中.你也可以捕获任何抛出的异常,这通常在包含了<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 悲观锁和乐观锁" class="guide">乐观锁</a>的高并发情况下非常有用.
</p><div class="code"><pre>def p = Person.get(1)
<span class="java-keyword">try</span> {
	p.save(flush:<span class="java-keyword">true</span>)
}
<span class="java-keyword">catch</span>(Exception e) {
	// deal with exception
}</pre></div>
<h2><a name="5.3.2 删除对象">5.3.2 删除对象</a></h2>下面是<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/delete.html" class="domainClasses">delete</a>方法的一个例子:
<div class="code"><pre>def p = Person.get(1)
p.delete()</pre></div><p class="paragraph">
<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/delete.html" class="domainClasses">delete</a> 方法也允许通过 <code>flush</code> 参数来控制flushing.
</p><div class="code"><pre>def p = Person.get(1)
p.delete(flush:<span class="java-keyword">true</span>)</pre></div><p class="paragraph">注意Grails没有提供 <code>deleteAll</code> 方法,因为删除数据是discouraged的，而且通常可以通过布尔标记/逻辑来避免.</p><p class="paragraph">如果你确实需要批量删除数据,你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/executeUpdate.html" class="domainClasses">executeUpdate</a>方法来执行批量的DML语句:
</p><div class="code"><pre>Customer.executeUpdate(<span class="java-quote">"delete Customer c where c.name = :oldName"</span>, [oldName:<span class="java-quote">"Fred"</span>])</pre></div><p class="paragraph"></p><h2><a name="5.3.3 级联更新和删除">5.3.3 级联更新和删除</a></h2>在使用GORM时,理解如何级联更新和删除是很重要的.需要记住的关键是 <code>belongsTo</code> 的设置控制着哪个类"拥有"这个关联.<p class="paragraph">无论是一对一,一对多还是多对多,如果你定义了<code>belongsTo</code> ,更新和删除将会从拥有类到被它拥有的类(关联的另一方)级联操作.</p><p class="paragraph">如果你没有定义 <code>belongsTo</code> ,那么就能级联操作,你将需要手工保存每个对象.</p><p class="paragraph">下面是一个例子:</p><p class="paragraph"></p><div class="code"><pre>class Airport {
	<span class="java-object">String</span> name
	<span class="java-keyword">static</span> hasMany = [flights:Flight]
}
class Flight {
	<span class="java-object">String</span> number
	<span class="java-keyword">static</span> belongsTo = [airport:Airport]
}</pre></div><p class="paragraph">如果我现在创建一个<code>Airport</code> 对象,并向它添加一些 <code>Flight</code>,它可以保存这个<code>Airport</code> 并级联保存每个flight,因此会保存整个对象图:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Airport(name:<span class="java-quote">"Gatwick"</span>)
	 .addToFlights(<span class="java-keyword">new</span> Flight(number:<span class="java-quote">"BA3430"</span>))
	 .addToFlights(<span class="java-keyword">new</span> Flight(number:<span class="java-quote">"EZ0938"</span>))
	 .save()</pre></div><p class="paragraph">相反的,如果稍后我删除了这个<code>Airport</code>,所有跟它关联的<code>Flight</code>也都将会被删除:</p><p class="paragraph"></p><div class="code"><pre>def airport = Airport.findByName(<span class="java-quote">"Gatwick"</span>)
airport.delete()</pre></div><p class="paragraph">然而,如果我将 <code>belongsTo</code> 去掉的话,上面的级联删除代码就不能工作了.
</p><h2><a name="5.3.4 立即加载和延迟加载">5.3.4 立即加载和延迟加载</a></h2>在GORM中,关联默认是lazy的.最好的解释是例子:<p class="paragraph"></p><div class="code"><pre>class Airport {
	<span class="java-object">String</span> name
	<span class="java-keyword">static</span> hasMany = [flights:Flight]
}
class Flight {
	<span class="java-object">String</span> number
	<span class="java-keyword">static</span> belongsTo = [airport:Airport]
}</pre></div><p class="paragraph">上面的domain类和下面的代码:</p><p class="paragraph"></p><div class="code"><pre>def airport = Airport.findByName(<span class="java-quote">"Gatwick"</span>)
airport.flights.each {
	println it.name
}</pre></div><p class="paragraph">GORM将会执行一个单独的SQL查询来抓取<code>Airport</code> 实例,然后再用一个额外的查询逐条迭代 <code>flights</code> 关联.换句话说,你得到了N+1条查询.</p><p class="paragraph">根据这个集合的使用频率,有时候这可能是最佳方案.因为你可以指定只有在特定的情况下才访问这个关联的逻辑.</p><p class="paragraph">一个可选的方案是使用立即抓取,它可以按照下面的方法来指定:</p><p class="paragraph"></p><div class="code"><pre>class Airport {
	<span class="java-object">String</span> name
	<span class="java-keyword">static</span> hasMany = [flights:Flight]
	<span class="java-keyword">static</span> fetchMode = [flights:<span class="java-quote">"eager"</span>]
}</pre></div><p class="paragraph">在这种情况下,<code>Airport</code>实例对应的<code>flights</code>关联会被一次性全部加载进来(依赖于映射).这样的好处是执行更少的查询,但是要小心使用,因为使用太多的eager关联可能会导致你将整个数据库加载进内存.</p><p class="paragraph"></p><blockquote class="note">
关联也可以用 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.2 自定义ORM映射" class="guide">ORM DSL</a> 将关联声明为 non-lazy 
</blockquote><p class="paragraph"></p><h2><a name="5.3.4 悲观锁和乐观锁">5.3.4 悲观锁和乐观锁</a></h2><h4>乐观锁</h4><p class="paragraph">默认的GORM类被配置为乐观锁。乐观锁实质上是Hibernate的一个特性，它在数据库里一个特别的 <code>version</code> 字段中保存了一个版本号。</p><p class="paragraph"><code>version</code>列读取包含当前你所访问的持久化实例的版本状态的<code>version</code>属性:</p><p class="paragraph"></p><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph">println airport.version</p></pre></div><p class="paragraph">当你执行更新操作时，Hibernate将自动检查version属性和数据库中version列，如果他们不同，将会抛出一个<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/StaleObjectStateException.html" class="api">StaleObjectException</a>异常，并且当前事物也会被回滚。</p><p class="paragraph">这是很有用的，因为它允许你不使用悲观锁(有一些性能上的损失)就可以获得一定的原子性。由此带来的负面影响是，如果你有一些高并发的写操作的话，你必须处理这个异常。这需要刷出(flushing)当前的session：
</p><div class="code"><pre>def airport = Airport.get(10)<p class="paragraph"><span class="java-keyword">try</span> {
	airport.name = <span class="java-quote">"Heathrow"</span>
	airport.save(flush:<span class="java-keyword">true</span>)
}
<span class="java-keyword">catch</span>(org.springframework.dao.OptimisticLockingFailureException e) {
	// deal with exception
}</p></pre></div><p class="paragraph">你处理异常的方法取决于你的应用。你可以尝试合并数据,或者返回给用户并让他们来处理冲突.</p><p class="paragraph">作为选择，如果它成了问题，你可以求助于悲观锁。</p><p class="paragraph"></p><h4>悲观锁。</h4><p class="paragraph">悲观锁等价于执行一个 SQL "SELECT * FOR UPDATE" 语句 并锁定数据库中的一行。这意味着其他的读操作将会被锁定直到这个锁放开。</p><p class="paragraph">在Grails中悲观锁通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/lock.html" class="domainClasses">lock</a> 方法执行:</p><p class="paragraph"></p><div class="code"><pre>def airport = Airport.get(10)
airport.lock() // lock <span class="java-keyword">for</span> update
airport.name = <span class="java-quote">"Heathrow"</span>
airport.save()</pre></div><p class="paragraph">一旦当前事物被提交，Grails会自动的为你释放锁。
</p><h2><a name="5.4 GORM查询">5.4 GORM查询</a></h2>GORM提供了从动态查询器到criteria到Hibernate面向对象查询语言HQL的一系列查询方式。<p class="paragraph">Groovy通过<a href="http://groovy.codehaus.org/GPath" target="blank">GPath</a> 操纵集合的能力，和GORM的像sort,findAll等方法结合起来，形成了一个强大的组合。</p><p class="paragraph">但是，让我们从基础开始吧。</p><p class="paragraph"></p><h4>获取实例列表</h4><p class="paragraph">如果你简单的需要获得给定类的所有实例，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/list.html" class="domainClasses">list</a>方法:
</p><div class="code"><pre>def books = Book.list()</pre></div><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/list.html" class="domainClasses">list</a> 方法支持分页参数:</p><p class="paragraph"></p><div class="code"><pre>def books = Book.list(offset:10, max:20)</pre></div><p class="paragraph">也可以排序:</p><p class="paragraph"></p><div class="code"><pre>def books = Book.list(sort:<span class="java-quote">"asc"</span>, order:<span class="java-quote">"title"</span>)</pre></div><p class="paragraph"></p><h4>根据数据库标识符取回</h4><p class="paragraph">第二个取回的基本形式是根据数据库标识符取回，使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/get.html" class="domainClasses">get</a> 方法:</p><p class="paragraph"></p><div class="code"><pre>def book = Book.get(23)</pre></div><p class="paragraph">你也可以根据一个标识符的集合使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/getAll.html" class="domainClasses">getAll</a>方法取得一个实例列表:</p><p class="paragraph"></p><div class="code"><pre>def books = Book.getAll(23, 93, 81)</pre></div><p class="paragraph"></p><h2><a name="5.4.1 动态查找器">5.4.1 动态查找器</a></h2>GORM支持动态查找器的概念。动态查找器看起来像一个静态方法的调用，但是这些方法本身在代码中实际上并不存在。<p class="paragraph">而是在运行时基于一个给定类的属性,自动生成一个方法。比如例子中的<code>Book</code>类:</p><p class="paragraph"></p><div class="code"><pre>class Book {
	<span class="java-object">String</span> title
	Date releaseDate
	Author author
}                
class Author {
	<span class="java-object">String</span> name
}</pre></div><p class="paragraph"> <code>Book</code> 类有一些属性，比如<code>title</code>, <code>releaseDate</code> 和 <code>author</code>. 这些都可以按照方法表达式的格式被用于<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/findBy.html" class="domainClasses">findBy</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/findAllBy.html" class="domainClasses">findAllBy</a> 方法。
</p><div class="code"><pre>def book = Book.findByTitle(<span class="java-quote">"The Stand"</span>)<p class="paragraph">book =
   Book
    .findByTitleLike(<span class="java-quote">"Harry Pot%"</span>)</p><p class="paragraph">book =
  Book
    .findByReleaseDateBetween( firstDate, secondDate )</p><p class="paragraph">book =
  Book
    .findByReleaseDateGreaterThan( someDate )</p><p class="paragraph">book =
  Book
   .findByTitleLikeOrReleaseDateLessThan( <span class="java-quote">"%Something%"</span>, someDate )</p></pre></div><p class="paragraph"></p><h4>方法表达式</h4><p class="paragraph">在GORM中一个方法表达式由前缀(比如<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/findBy.html" class="domainClasses">findBy</a>)后面跟一个表达式组成，这个表达式由一个或多个属性组成。基本形式是:</p><p class="paragraph"></p><div class="code"><pre>Book.findBy[Property][Suffix]*[<span class="java-object">Boolean</span> Operator]*[Property][Suffix]</pre></div><p class="paragraph">用*标记的部分是可选的。每个后缀都会改变查询的性质。例如:</p><p class="paragraph"></p><div class="code"><pre>def book = Book.findByTitle(<span class="java-quote">"The Stand"</span>)<p class="paragraph">book =  Book.findByTitleLike(<span class="java-quote">"Harry Pot%"</span>)</p></pre></div><p class="paragraph">在上面的例子中，第一个查询等价于等于后面的值。第二个因为增加了 <code>Like</code>后缀，它等价于SQL的<code>like</code>表达式。</p><p class="paragraph">可用的后缀包括:
</p><ul class="star">
<li><code>LessThan</code> - 小于给定值</li>
<li><code>LessThanEquals</code> -小于或等于给定值</li>
<li><code>GreaterThan</code> - 大于给定值</li>
<li><code>GreaterThanEquals</code> - 大于或等于给定值</li>
<li><code>Like</code> - 等价于 SQL like 表达式</li>
<li><code>Ilike</code> -类似于 <code>Like</code>, 但不是大小写敏感</li>
<li><code>NotEqual</code> - 不等于</li>
<li><code>Between</code> - 介于两个值之间 (需要两个参数)</li>
<li><code>IsNotNull</code> - 不为null的值(不需要参数)</li>
<li><code>IsNull</code> - 为null的值 (不需要参数)</li>
</ul><p class="paragraph">你会发现最后三个方法标注了参数的个数，他们的示例如下：</p><p class="paragraph"></p><div class="code"><pre>def now = <span class="java-keyword">new</span> Date()
def lastWeek = now - 7
def book =
  Book
    .findByReleaseDateBetween( lastWeek, now )</pre></div><p class="paragraph">同样的<code>isNull</code> 和 <code>isNotNull</code> 不需要参数:
</p><div class="code"><pre>def books = Book.findAllByReleaseDateIsNull()</pre></div><p class="paragraph"></p><h4>布尔逻辑(AND/OR)</h4><p class="paragraph">方法表达式也可以使用一个布尔操作符来组合两个criteria：</p><p class="paragraph"></p><div class="code"><pre>def books = 
	 Book
	   .findAllByTitleLikeAndReleaseDateGreaterThan(<span class="java-quote">"%Java%"</span>, <span class="java-keyword">new</span> Date()-30)</pre></div><p class="paragraph">在这里我们在查询中间使用 <code>And</code>来确保两个条件都满足，但是同样地你也可以使用 <code>Or</code>:
</p><div class="code"><pre>def books = 
	 Book
	   .findAllByTitleLikeOrReleaseDateGreaterThan(<span class="java-quote">"%Java%"</span>, <span class="java-keyword">new</span> Date()-30)</pre></div><p class="paragraph">显然这种情况下方法名会变得相当长，这时候你应该考虑使用 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.4.2 条件查询" class="guide">条件查询</a>.</p><p class="paragraph"></p><h4>查询关联</h4><p class="paragraph">关联也可以被用在查询中:</p><p class="paragraph"></p><div class="code"><pre>def author = Author.findByName(<span class="java-quote">"Stephen King"</span>)<p class="paragraph">def books = author ? Book.findAllByAuthor(author) : []</p></pre></div><p class="paragraph">在这里如果 <code>Author</code> 实例不为null,我们在查询中用它取得给定<code>Author</code>的所有 <code>Book</code> 实例.</p><p class="paragraph"></p><h4>分页和排序</h4><p class="paragraph">跟<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/list.html" class="domainClasses">list</a> 方法上可用的分页和排序参数一样，他们同样可以被提供为一个map用于动态查询器的最后一个参数。
</p><div class="code"><pre>def books = 
  Book.findAllByTitleLike(<span class="java-quote">"Harry Pot%"</span>, [max:3, 
                                         offset:2, 
                                         sort:<span class="java-quote">"asc"</span>, 
                                         order:<span class="java-quote">"title"</span>])</pre></div>
<h2><a name="5.4.2 条件查询">5.4.2 条件查询</a></h2>Criteria是一种类型安全的、高级的查询方法，它使用Groovy builder构造强大复杂的查询。它是一种比使用StringBuffer好得多的选择。<p class="paragraph">Criteria可以通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/createCriteria.html" class="domainClasses">createCriteria</a> 或者 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/withCriteria.html" class="domainClasses">withCriteria</a> 方法来使用。builder使用Hibernate的Criteria API,builder上的节点对应Hibernate Criteria API中 <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Restrictions.html" class="api">Restrictions</a> 类中的静态方法。用法示例:</p><p class="paragraph"></p><div class="code"><pre>def c = Account.createCriteria()
def results = c {
	like(<span class="java-quote">"holderFirstName"</span>, <span class="java-quote">"Fred%"</span>)
	and {
		between(<span class="java-quote">"balance"</span>, 500, 1000)
		eq(<span class="java-quote">"branch"</span>, <span class="java-quote">"London"</span>)
	}
	maxResults(10)
	order(<span class="java-quote">"holderLastName"</span>, <span class="java-quote">"desc"</span>)
}</pre></div><p class="paragraph"></p><h4>逻辑与（Conjunctions）和逻辑或（Disjunctions）</h4><p class="paragraph">如前面例子所演示的，你可以用<code>and { }</code> 块来分组criteria到一个逻辑AND:</p><p class="paragraph"></p><div class="code"><pre>and {
	between(<span class="java-quote">"balance"</span>, 500, 1000)
	eq(<span class="java-quote">"branch"</span>, <span class="java-quote">"London"</span>)
}</pre></div><p class="paragraph">逻辑OR也可以这么做:
</p><div class="code"><pre>or {
	between(<span class="java-quote">"balance"</span>, 500, 1000)
	eq(<span class="java-quote">"branch"</span>, <span class="java-quote">"London"</span>)
}</pre></div><p class="paragraph">你也可以用逻辑NOT来否定:
</p><div class="code"><pre>not {
	between(<span class="java-quote">"balance"</span>, 500, 1000)
	eq(<span class="java-quote">"branch"</span>, <span class="java-quote">"London"</span>)
}</pre></div><p class="paragraph"></p><h4>查询关联</h4><p class="paragraph">关联可以通过使用一个跟关联属性同名的节点来查询。比如我们说<code>Account</code>类有关联到多个 <code>Transaction</code> 对象:</p><p class="paragraph"></p><div class="code"><pre>class Account {
    …
    def hasMany = [transactions:Transaction]
    Set transactions
    …
}</pre></div><p class="paragraph">
我们可以使用属性名 <code>transaction</code> 作为builder的一个节点来查询这个关联:</p><p class="paragraph"></p><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java-keyword">new</span> Date()
def results = c.list {
       transactions {
            between('date',now-10, now)
       }
}</pre></div><p class="paragraph">
The above code will find all the <code>Account</code> instances that have performed <code>transactions</code> within the last 10 days.
上面的代码将会查找所有过去10天内执行过<code>transactions</code> 的 <code>Account</code>实例。你也可以在逻辑块中嵌套关联查询:</p><p class="paragraph"></p><div class="code"><pre>def c = Account.createCriteria()
def now = <span class="java-keyword">new</span> Date()
def results = c.list {
     or {
        between('created',now-10,now)
        transactions {
             between('date',now-10, now)
        }
     }
}</pre></div><p class="paragraph">
这里,我们将找出在最近10天内进行过交易或者最近10天内新创建的所有用户。</p><p class="paragraph"></p><h4>投影(Projections)查询</h4><p class="paragraph">投影被用于定制查询结果。要使用投影你需要在criteria builder树里定义一个"projections"节点。projections节点内可用的方法等同于 Hibernate 的<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/Projections.html" class="api">Projections</a> 类中的方法.</p><p class="paragraph"></p><div class="code"><pre>def c = Account.createCriteria()<p class="paragraph">def numberOfBranches = c.get {
	projections {
		countDistinct('branch')
	}
}</p></pre></div><p class="paragraph"></p><h4>使用可滚动的结果</h4><p class="paragraph">你可以通过调用scroll方法来使用Hibernate的<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/ScrollableResults.html" class="api">ScrollableResults</a> 特性。</p><p class="paragraph"></p><div class="code"><pre>def results = crit.scroll {
      maxResults(10)
}
def f = results.first()
def l = results.last()
def n = results.next()
def p = results.previous()<p class="paragraph">def <span class="java-keyword">future</span> = results.scroll(10)
def accountNumber = results.getLong('number')</p></pre></div><p class="paragraph">
下面引用的是Hibernate文档中关于ScrollableResults的描述:</p><p class="paragraph"></p><blockquote class="quote">
结果集的迭代器（iterator）可以以任意步进的方式前后移动，而Query / ScrollableResults模式跟JDBC的PreparedStatement/ ResultSet也很像，其接口方法名的语意也跟ResultSet的类似。
</blockquote><p class="paragraph">不同于JDBC，结果列的编号是从0开始.</p><p class="paragraph"></p><h4>在Criteria实例中设置属性</h4><p class="paragraph">如果在builder树内部的一个节点不匹配任何一项特定标准，它将尝试设置为Criteria对象自身的属性。因此允许完全访问这个类的所有属性。下面的例子是在<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html" class="api">Criteria</a>实例上调用<code>setMaxResults</code> 和 <code>setFirstResult</code>:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> org.hibernate.FetchMode as FM
	....
	def results = c.list {
		maxResults(10)
		firstResult(50)
		fetchMode(<span class="java-quote">"aRelationship"</span>, FM.EAGER)
	}</pre></div><p class="paragraph"></p><h4>立即抓取的方式查询</h4><p class="paragraph">在 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 立即加载和延迟加载" class="guide">立即加载和延迟加载</a> 这节，我们讨论了如果指定特定的抓取方式来避免N+1查询的问题。这个criteria查询也可以做到:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> org.hibernate.FetchMode as FM
// ......<p class="paragraph">def criteria = Task.createCriteria()
def tasks = criteria.list{
     eq(<span class="java-quote">"assignee.id"</span>, task.assignee.id)
     fetchMode('assignee', FM.EAGER)
     fetchMode('project', FM.EAGER)
     order('priority', 'asc')
}</p></pre></div><p class="paragraph">
</p><h4>方法引用</h4><p class="paragraph">如果你调用一个没有方法名的builder，比如:</p><p class="paragraph"></p><div class="code"><pre>c { … }</pre></div><p class="paragraph">默认的会列出所有结果，因此上面代码等价于:</p><p class="paragraph"></p><div class="code"><pre>c.list { … }</pre></div><p class="paragraph"><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tbody><tr><th>方法</th><th>描述</th></tr><tr class="table-odd"></tr><tr class="table-even"><td><strong class="bold">list</strong></td><td>这是默认的方法。它会返回所有匹配的行。</td></tr><tr class="table-odd"><td><strong class="bold">get</strong></td><td>返回唯一的结果集，比如，就一行。criteria已经规定好了，仅仅查询一行。这个方法更方便，免得使用一个limit来只取第一行使人迷惑。</td></tr><tr class="table-even"><td><strong class="bold">scroll</strong></td><td>返回一个可滚动的结果集</td></tr><tr class="table-odd"><td><strong class="bold">listDistinct</strong></td><td>如果子查询或者关联被使用，有一个可能就是在结果集中多次出现同一行，这个方法允许只列出不同的条目，它等价于<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/criterion/CriteriaSpecification.html" class="api">CriteriaSpecification</a> 类的<code>DISTINCT_ROOT_ENTITY</code>。</td></tr></tbody></table></p><p class="paragraph"></p><h2><a name="5.4.3 Hibernate查询语言">5.4.3 Hibernate查询语言</a></h2>GORM也支持Hibernate的查询语言HQL,在Hibernate文档中的 <a href="http://www.hibernate.org/hib_docs/reference/en/html/queryhql.html" target="blank">Chapter 14. HQL: The Hibernate Query Language</a> ,可以找到它非常完整的参考手册。<p class="paragraph">GORM提供了一些使用HQL的方法，包括<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/find.html" class="domainClasses">find</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/findAll.html" class="domainClasses">findAll</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/executeQuery.html" class="domainClasses">executeQuery</a>。下面是一个查询的例子:</p><p class="paragraph"></p><div class="code"><pre>def results =
      Book.findAll(<span class="java-quote">"from Book as b where b.title like 'Lord of the%'"</span>)</pre></div><p class="paragraph"></p><h4>位置和命名参数</h4><p class="paragraph">上面的例子中传递给查询的值是硬编码的，但是，你可以同样地使用位置参数:</p><p class="paragraph"></p><div class="code"><pre>def results =
      Book.findAll(<span class="java-quote">"from Book as b where b.title like ?"</span>, [<span class="java-quote">"The Shi%"</span>])</pre></div><p class="paragraph">或者甚至使用命名参数:</p><p class="paragraph"></p><div class="code"><pre>def results =
      Book.findAll(<span class="java-quote">"from Book as b where b.title like :search or b.author like :search"</span>, [search:<span class="java-quote">"The Shi%"</span>])</pre></div><p class="paragraph"></p><h4>多行查询</h4><p class="paragraph">如果你需要将查询分割到多行你可以使用一个行连接符:</p><p class="paragraph"></p><div class="code"><pre>def results = Book.findAll(<span class="java-quote">""</span>"\\
from Book as b, \\
     Author as a \\
where b.author = a and a.surname = ?<span class="java-quote">""</span>", ['Smith'])</pre></div><p class="paragraph"></p><blockquote class="note">
Groovy 的多行字符串对HQL查询无效
</blockquote><p class="paragraph"></p><h4>分页和排序</h4><p class="paragraph">使用HQL查询的时候你也可以进行分页和排序。要做的只是简单指定分页和排序参数作为一个散列在方法的末尾调用:</p><p class="paragraph"></p><div class="code"><pre>def results =
      Book.findAll(<span class="java-quote">"from Book as b where b.title like 'Lord of the%'"</span>, 
                   [max:10, offset:20, sort:<span class="java-quote">"asc"</span>, order:<span class="java-quote">"title"</span>])</pre></div>
<h2><a name="5.5 高级GORM特性">5.5 高级GORM特性</a></h2>接下来的章节覆盖更多高级的GORM使用 包括 缓存、定制映射和事件
<h2><a name="5.5.1 事件和自动实现时间戳">5.5.1 事件和自动实现时间戳</a></h2>GORM supports the registration of events as closures that get fired when certain events occurs such as deletes, inserts and updates. To add an event simply register the relevant closure with your domain class.
GORM支持事件注册，只需要将事件作为一个闭包即可，当某个事件触发，比如删除，插入，更新。为了添加一个事件需要在你的领域类中添加相关的闭包。<p class="paragraph">事件类型</p><p class="paragraph"></p><h4>beforeInsert事件</h4><p class="paragraph">触发当一个对象保存到数据库之前</p><p class="paragraph"></p><div class="code"><pre>class Person {
   Date dateCreated<p class="paragraph">   def beforeInsert = {
       dateCreated = <span class="java-keyword">new</span> Date()
   }
}</p></pre></div><p class="paragraph"></p><h4>beforeUpdate事件</h4><p class="paragraph">更新前事件
</p><div class="code"><pre>class Person {
   Date dateCreated
   Date lastUpdated<p class="paragraph">   def beforeInsert = {
       dateCreated = <span class="java-keyword">new</span> Date()
   }
   def beforeUpdate = {
       lastUpdated = <span class="java-keyword">new</span> Date()
   }
}</p></pre></div><p class="paragraph"></p><h4>beforeDelete事件</h4><p class="paragraph">触发但一个对象被删除
</p><div class="code"><pre>class Person {
   <span class="java-object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph">   def beforeDelete = {
      <span class="java-keyword">new</span> ActivityTrace(eventName:<span class="java-quote">"Person Deleted"</span>,data:name).save()
   }
}</p></pre></div><p class="paragraph"></p><h4>onLoad事件</h4><p class="paragraph">触发当一个对象从数据库取出
</p><div class="code"><pre>class Person {
   <span class="java-object">String</span> name
   Date dateCreated
   Date lastUpdated<p class="paragraph">   def onLoad = {
      name = <span class="java-quote">"I'm loaded"</span>
   }
}</p></pre></div><p class="paragraph"></p><h4>自动时间戳</h4>
上面的例子演示了使用事件来更新一个<code>lastUpdated</code>和<code>dateCreated</code>属性来跟踪对象的更新。事实上，这些设置不是必须的。通过简单的定义一个<code>lastUpdated</code>和<code>dateCreated</code>属性 ，GORM会自动的为你更新。<p class="paragraph">如果，这些行为不是你需要的，可以屏蔽这些功能。如下设置
</p><div class="code"><pre>class Person {
   Date dateCreated
   Date lastUpdated
   <span class="java-keyword">static</span> mapping = {
      autoTimestamp <span class="java-keyword">false</span>
   }
}</pre></div><p class="paragraph"></p><h2><a name="5.5.2 自定义ORM映射">5.5.2 自定义ORM映射</a></h2>Grails 的域对象可以映射到许多遗留的模型通过 关系对象映射域语言。接下来的部分将带你领略它是可能的通过ORM DSL<p class="paragraph"></p><blockquote class="note">
这是必要的，如果你高兴地坚持以约定来定义GORM对应的表，列名等。你只需要这个功能，如果你需要定制GORM 映射到遗留模型或进行缓存
</blockquote><p class="paragraph">自定义映射是使用静态的<code>mapping</code>块定义在你的域类中的：
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {<p class="paragraph">  }
}</p></pre></div>
<h2><a name="5.5.2.1 表名和列名">5.5.2.1 表名和列名</a></h2><h4>表名</h4><p class="paragraph">类映射到数据库的表名可以通过使用<code>table</code>关键字来定制
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
  }
}</pre></div><p class="paragraph">在上面的例子中，类会映射到<code>people</code>表来代替默认的<code>person</code>表</p><p class="paragraph"></p><h4>列名</h4><p class="paragraph">同样，也是可能的定制某个列到数据库。比如说，你想改变列名例子如下
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      firstName column:'First_Name'
  }
}</pre></div><p class="paragraph">在这个例子中，你定义了一个<code>column</code>块，此块包含的方法调用匹配每一个属性名称（本例子中是 <code>firstName</code>），接下来使用命名的<code>column</code>来指定字段名称的映射</p><p class="paragraph"></p><h4>列类型</h4><p class="paragraph">GORM supports configuration of Hibernate types via the DSL using the type attribute. This includes specifing user types that subclass the Hibernate <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/types/UserType.html" class="api">org.hibernate.types.UserType</a> class. As an example
GORM还可以通过DSL的type属性来支持Hibernate类型，包括特定Hibernate的<a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/types/UserType.html" class="api">org.hibernate.types.UserType</a>的子类。比如，有一个PostCodeType,你可以象下面这样使用：
</p><div class="code"><pre>class Address {
   <span class="java-object">String</span> number
   <span class="java-object">String</span> postCode
   <span class="java-keyword">static</span> mapping = {
      postCode type:PostCodeType
   }
}</pre></div><p class="paragraph">另外如果你想将它映射到Hibernate的基本类型而不是Grails的默认类型，可以参考下面代码：
</p><div class="code"><pre>class Address {
   <span class="java-object">String</span> number
   <span class="java-object">String</span> postCode
   <span class="java-keyword">static</span> mapping = {
      postCode type:'text'
   }
}</pre></div><p class="paragraph">上面的例子将使postCode列映射到数据库的SQL TEXT或者CLOB类型</p><p class="paragraph"></p><h4>一对一映射</h4><p class="paragraph">在关联中，你也有机会改变外键映射联系，在一对一的关系中，对列的操作跟其他常规的列操作并无二异，例子如下
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  Address address
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      firstName column:'First_Name'
      address column:'Person_Adress_Id'
  }
}</pre></div><p class="paragraph">默认情况下，<code>address</code>将映射到一个名称为address_id 的外键。但是使用上面的映射，我们改变外键列为<code>Person_Adress_Id</code></p><p class="paragraph"></p><h4>一对多映射</h4><p class="paragraph">在一个双向的一对多关系中，你可以象前节中的一对一关系中那样改变外键列，只需要在多的一端中改变列名即可。然而，在单向关联中，外键需要在关联自身中（即一的一端-译者注）指定。比如，给定一个单向一对多联系<code>Person</code>和<code>Address</code>，下面的代码会改变<code>address</code>表中外键。
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-keyword">static</span> hasMany = [addresses:Address]
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      firstName column:'First_Name'
	  addresses column:'Person_Address_Id'
  }
}</pre></div><p class="paragraph">如果你不想在<code>address</code>表中有这个列，可以通过中间关联表来完成，只需要使用joinTable参数即可：
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-keyword">static</span> hasMany = [addresses:Address]
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      firstName column:'First_Name'
      addresses joinTable:[name:'Person_Addresses', key:'Person_Id', column:'Address_Id']
  }
}</pre></div><p class="paragraph"></p><h4>多对多映射</h4><p class="paragraph">默认情况下，Grails中多对多的映射是通过中间表来完成的，以下面的多对多关联为例：
</p><div class="code"><pre>class Group {
	…
	<span class="java-keyword">static</span> hasMany = [people:Person]
}
class Person {
	…
	<span class="java-keyword">static</span> belongsTo = Group
	<span class="java-keyword">static</span> hasMany = [groups:Group]
}</pre></div><p class="paragraph">在上面的例子中，Grails将会创建一个<code>group_person</code>表包含外键<code>person_id</code>和<code>group_id</code>对应<code>person</code>和<code>group</code>表。假如你需要改变列名，你可以为每个类指定一个列映射</p><p class="paragraph"></p><div class="code"><pre>class Group {
   …
   <span class="java-keyword">static</span> mapping = {
       people column:'Group_Person_Id'
   }	
}
class Person {
   …
   <span class="java-keyword">static</span> mapping = {
       groups column:'Group_Group_Id'
   }	
}</pre></div><p class="paragraph">你也可以指定中间表的名称
</p><div class="code"><pre>class Group {
   …
   <span class="java-keyword">static</span> mapping = {
       people column:'Group_Person_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   }	
}
class Person {
   …
   <span class="java-keyword">static</span> mapping = {
       groups column:'Group_Group_Id',joinTable:'PERSON_GROUP_ASSOCIATIONS'
   }	
}</pre></div>
<h2><a name="5.5.2.2 缓存策略">5.5.2.2 缓存策略</a></h2><h4>设置缓存</h4><p class="paragraph"><a href="http://www.hibernate.org/" target="blank">Hibernate</a> 本身提供了自定义二级缓存的特性，这就需要在<code>grails-app/conf/DataSource.groovy</code>文件中配置：</p><p class="paragraph"></p><div class="code"><pre>hibernate {
    cache.use_second_level_cache=<span class="java-keyword">true</span>
    cache.use_query_cache=<span class="java-keyword">true</span>
    cache.provider_class='org.hibernate.cache.EhCacheProvider'
}</pre></div><p class="paragraph">当然，你也可以按你所需来定制设置。比如，你想使用分布式缓存机制</p><p class="paragraph"></p><blockquote class="note">
想了解更多Hibernate的二级缓存，参考<a href="http://www.hibernate.org/hib_docs/reference/en/html/performance.html#performance-cache" target="blank">Hibernate</a>相关文档
</blockquote><p class="paragraph"></p><h4>缓存实例</h4><p class="paragraph">假如要在映射代码块中启用缺省的缓存，可以通过调用<code>cache</code>方法实现：
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      cache <span class="java-keyword">true</span>
  }
}</pre></div><p class="paragraph">上面的例子中将配置一个读-写(read-write)缓存包括lazy和non-lazy属性。假如你想定制这些特性，你可以如下所示：
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      cache usage:'read-only', include:'non-lazy'
  }
}</pre></div><p class="paragraph"></p><h4>缓存关联对象</h4><p class="paragraph">就像使用Hibernate的二级缓存来缓存实例一样，你也可以来缓存集合（关联），比如：
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-keyword">static</span> hasMany = [addresses:Address]
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      version <span class="java-keyword">false</span>
      addresses column:'Address', cache:<span class="java-keyword">true</span>
  }
}
class Address {
   <span class="java-object">String</span> number
   <span class="java-object">String</span> postCode
}</pre></div><p class="paragraph">上面的例子中，我们在addresses集合启用了一个读-写缓存，你也可以使用
</p><div class="code"><pre>cache:'read-write' // or 'read-only' or 'transactional'</pre></div><p class="paragraph">更多配置请参考缓存用法</p><p class="paragraph"></p><h4>缓存用法</h4><p class="paragraph">下面是不同缓存设置和他们的使用方法
</p><ul class="star">
<li><code>read-only</code> - 假如你的应用程序需要读但是从不需要更改持久化实例，只读缓存或许适用</li>
<li><code>read-write</code> - 假如你的应用程序需要更新数据，读-写缓存或许是合适的</li>
<li><code>nonstrict-read-write</code> - 假如你的应用程序仅偶尔需要更新数据（也就是说，如果这是极不可能两笔交易，将尝试更新同一项目同时）并且时进行） ，并严格交易隔离，是不是需要一个非严格-读写缓存可能是适宜的</li>
<li><code>transactional</code> - <code>transactional</code>缓存策略提供支持对全事务缓存提供比如JBoss的TreeCache。这个缓存或许仅仅使用在一个JTA环境，同时你必须在<code>grails-app/conf/DataSource.groovy</code>文件中配置<code>hibernate.transaction.manager_lookup_class</code></li>
</ul><p class="paragraph"></p><h2><a name="5.5.2.3 继承策略">5.5.2.3 继承策略</a></h2>默认情况下GORM 类使用<code>table-per-hierarchy</code>来映射继承的。这就有一个缺点就是在数据库层面，列不能有<code>NOT-NULL</code>的约束。如果你更喜欢<code>table-per-subclass</code>，你可以使用下面方法<p class="paragraph"></p><div class="code"><pre>class Payment {
    <span class="java-object">Long</span> id
    <span class="java-object">Long</span> version
    <span class="java-object">Integer</span> amount<p class="paragraph">    <span class="java-keyword">static</span> mapping = {
        tablePerHierarchy <span class="java-keyword">false</span>
    }
}
class CreditCardPayment <span class="java-keyword">extends</span> Payment  {
    <span class="java-object">String</span> cardNumber
}</p></pre></div><p class="paragraph">在祖先Payment类的映射设置中，指定了在所有的子类中，不使用<code>table-per-hierarchy</code>映射。
</p><h2><a name="5.5.2.4 自定义数据库标识符">5.5.2.4 自定义数据库标识符</a></h2>你可以通过DSL来定制GORM生成数据库标识，缺省情况下GORM将根据原生数据库机制来生成ids，这是迄今为止最好的方法，但是仍存在许多模式，不同的方法来生成标识。<p class="paragraph">为此，Hibernate特地定义了id生成器的概念，你可以自定义它要映射的id生成器和列，如下：
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      version <span class="java-keyword">false</span>
      id generator:'hilo', params:[table:'hi_value',column:'next_value',max_lo:100]
  }
}</pre></div><p class="paragraph">在上面的例子中，我们使用了Hibernate内置的'hilo'生成器，此生成器通过一个独立的表来生成ids。此外还有许多不同的生成器可以配置，具体参考Hibernate在这个主题上的相关文档。</p><p class="paragraph"></p><blockquote class="note">
想了解更多不同的Hibernate生成器请参考<a href="http://www.hibernate.org/hib_docs/reference/en/html/mapping.html#mapping-declaration-id-generator" target="blank">Hibernate</a>文档
</blockquote><p class="paragraph">注意，如果你仅仅想定制列id，你可以这样
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      version <span class="java-keyword">false</span>
      id column:'person_id'
  }
}</pre></div>
<h2><a name="5.5.2.5 复合主键">5.5.2.5 复合主键</a></h2>GORM支持复合标识（复合主键--译者注）概念（标识由两个或者更多属性组成）。这不是我们建议的方法，但是如果你想这么做，这也是可能的：<p class="paragraph"></p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-object">String</span> lastName<p class="paragraph">  <span class="java-keyword">static</span> mapping = {
      id composite:['firstName', 'lastName']
  }
}</p></pre></div><p class="paragraph">上面的代码将通过<code>Person</code>类的<code>firstName</code>和<code>lastName</code>属性来创建一个复合id。当你后面需要通过id取一个实例时，你必须用这个对象的原型</p><p class="paragraph"></p><div class="code"><pre>def p = Person.get(<span class="java-keyword">new</span> Person(firstName:<span class="java-quote">"Fred"</span>, lastName:<span class="java-quote">"Flintstone"</span>))
println p.firstName</pre></div>
<h2><a name="5.5.2.6 数据库索引">5.5.2.6 数据库索引</a></h2>为得到最好的查询性能，通常你需要调整表的索引定义。如何调整它们是跟特定领域和要查询的用法模式相关的。使用GORM的DSL你可以指定那个列需要索引<p class="paragraph"></p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-object">String</span> address
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      version <span class="java-keyword">false</span>
      id column:'person_id'
      firstName column:'First_Name', index:'Name_Idx'
      address column:'Address', index:'Name_Idx, Address_Index'
  }
}</pre></div><p class="paragraph"></p><p class="paragraph"></p><h2><a name="5.5.2.7 乐观锁和版本定义">5.5.2.7 乐观锁和版本定义</a></h2>就像在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 悲观锁和乐观锁" class="guide">乐观锁和悲观锁</a>部分讨论的，默认情况下，GORM使用乐观锁和在每一个类中自动注入一个<code>version</code>属性，此属性将映射数据库中的一个<code>version</code>列<p class="paragraph">如果你映射的是一个遗留数据库（已经存在的数据库--译者注），这将是一个问题，因此可以通过如下方法来关闭这个功能：
</p><div class="code"><pre>class Person {
  ..
  <span class="java-keyword">static</span> mapping = {
      table 'people'
      version <span class="java-keyword">false</span>
  }
}</pre></div><p class="paragraph"></p><blockquote class="note">
如果你关闭了乐观锁，你将自己负责并发更新并且存在用户丢失数据的风险（除非你使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 悲观锁和乐观锁" class="guide">悲观锁</a>）。
</blockquote>
<h2><a name="5.5.2.8 立即加载和延迟加载">5.5.2.8 立即加载和延迟加载</a></h2><h5>延迟加载集合</h5><p class="paragraph">就像在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.3.4 立即加载和延迟加载" class="guide">立即加载和延迟加载</a>部分讨论的，默认情况下，GORM 集合使用延迟加载的并且可以通过<code>fetchMode</code>来配置 。但如果你更喜欢把你所有的映射都集中在<code>mappings</code>代码块中，你也可以使用ORM的DSL来配置获取模式：
</p><div class="code"><pre>class Person {
  <span class="java-object">String</span> firstName
  <span class="java-keyword">static</span> hasMany = [addresses:Address]
  <span class="java-keyword">static</span> mapping = {
      addresses lazy:<span class="java-keyword">false</span>
  }
}
class Address {
  <span class="java-object">String</span> street
  <span class="java-object">String</span> postCode
}</pre></div><p class="paragraph"></p><h4>延迟加载单向关联</h4><p class="paragraph">在GORM中，one-to-one和many-to-one关联缺省是非延迟加载的。这在有很多实体（数据库记录-译者注）的时候，会产生性能问题，尤其是关联查询是以新的SELECT语句执行的时候，此时你应该将one-to-one和many-to-one关联的延迟加载象集合那样进行设置:
</p><div class="code"><pre>class Person {
	<span class="java-object">String</span> firstName
	<span class="java-keyword">static</span> belongsTo = [address:Address]
	<span class="java-keyword">static</span> mapping = {
		address lazy:<span class="java-keyword">true</span> // lazily fetch the address
	}
}
class Address {
	<span class="java-object">String</span> street
	<span class="java-object">String</span> postCode
}</pre></div><p class="paragraph">这里我们设置 <code>Person</code>的<code>address</code>属性为延迟加载</p><p class="paragraph"></p><h2><a name="5.6 事务编程">5.6 事务编程</a></h2>Grails是构建在Spring的基础上的，所以使用Spring的事务来抽象处理事务编程，但GORM类通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/withTransaction.html" class="domainClasses">withTransaction</a>方法使得处理更简单，方法的第一个参数是Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/TransactionStatus.html" class="api">TransactionStatus</a>对象<p class="paragraph">典型的使用场景如下：
</p><div class="code"><pre>def transferFunds = {
	Account.withTransaction { status -&gt;
		def source = Account.get(params.from)
		def dest = Account.get(params.to)<p class="paragraph">		def amount = params.amount.toInteger()
		<span class="java-keyword">if</span>(source.active) {
			source.balance -= amount
			<span class="java-keyword">if</span>(dest.active) {
				dest.amount += amount
			}
			<span class="java-keyword">else</span> {
				status.setRollbackOnly()
			}
		}</p><p class="paragraph">		
	}</p><p class="paragraph">}</p></pre></div><p class="paragraph">在上面的例子中，如果目的账户没有处于活动状态，系统将回滚事务，同时如果有任何异常抛出在事务的处理过程中也将会自动回滚。</p><p class="paragraph">假如你不想回滚整个事务，你也可以使用"save points"来回滚一个事务到一个特定的点。你可以通过使用Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/transaction/SavepointManager.html" class="api">SavePointManager</a>接口来达到这个目的。</p><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/withTransaction.html" class="domainClasses">withTransaction</a>方法为你处理begin/commit/rollback代码块作用域内的逻辑。
</p><h2><a name="5.7 GORM和约束">5.7 GORM和约束</a></h2>尽管约束是<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">验证</a>章节的内容，但是在此涉及到约束也是很重要的，因为一些约束会影响到数据库的生成。<p class="paragraph">Grails通过使用领域类的约束来影响数据库表字段（领域类所对于的属性）的生成，还是可行的。</p><p class="paragraph">考虑下面的例子，假如我们有一个域模型如下的属性：
</p><div class="code"><pre><span class="java-object">String</span> description</pre></div><p class="paragraph">默认情况下，在MySql数据库中，Grails将会定义这个列为
</p><div class="code"><pre>column name | data type 
 description | varchar(255)</pre></div><p class="paragraph">但是，在业务规则中，要求这个领域类的<code>description</code>属性能够容纳1000个字符，在这种情况下，如果我们是使用SQL脚本，那么我们定义的这个列可能是：
</p><div class="code"><pre>column name | data type 
 description | TEXT</pre></div><p class="paragraph">现在我们又想要在基于应用程序的进行验证，_要求在持久化任何记录之前_，确保不能超过1000个字符。在Grails中，我们可以通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">约束</a>来完成，我们将在领域类中新增如下的约束声明：</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">static</span> constraints = {
        description(maxSize:1000)
}</pre></div><p class="paragraph">这个约束条件将会提供我们所需的基于应用程序的验证并且也将生成上述示例所示的数据库信息。下面是影响数据库生成的其他约束的描述。</p><p class="paragraph"></p><h4>影响字符串类型属性的约束</h4>
<ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/inList.html" class="constraints">inList</a></li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/maxSize.html" class="constraints">maxSize</a></li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/size.html" class="constraints">size</a></li>
</ul><p class="paragraph">如果<code>maxSize</code>或者<code>size</code>约束被定义，Grails将根据约束的值设置列的最大长度。</p><p class="paragraph">通常，不建议在同一个的领域类中组合使用这些约束。但是，如果你非要同时定义<code>maxSize</code>和<code>size</code>约束的话，Grails将设置列的长度为<code>maxSize</code>约束和<code>size</code>上限约束的最少值（Grails使用两者的最少值，因此任何超过最少值的长度将导致验证错误）</p><p class="paragraph">如果定义了inList约束（<code>maxSize</code>和<code>size</code>未定义）的话，字段最大长度将取决于列表（list）中最长字符串的的长度。以"Java"、"Groovy"和"C++"为例，Grails将设置字段的长度为6（"Groovy"的最长含有6个字符）。</p><p class="paragraph"></p><h4>影响数值类型属性的约束</h4>
<ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/min.html" class="constraints">min</a></li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/max.html" class="constraints">max</a></li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/range.html" class="constraints">range</a></li>
</ul><p class="paragraph">如果定义了约束<code>max</code>、<code>min</code>或者<code>range</code>，Grails将基于约束的值尝试着设置列的<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">精度</a>（设置的结果很大程度上依赖于Hibernate跟底层数据库系统的交互程度）。</p><p class="paragraph">通常来说，不建议在同一领域类的属性上组合成双的min/max和range约束，但是如果这些约束同时被定义了，那么Grails将使用约束值中的最少精度值（Grails取两者的最少值，是因为任意超过最少精度的长度将会导致一个验证错误）。
</p><ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Constraints/scale.html" class="constraints">scale</a></li>
</ul><p class="paragraph">如果定义了scale约束，那么Grails会试图使用基于约束的值来设置列的<a href="http://uk.builder.com/architecture/db/0,39026552,20268520,00.htm" target="blank">标度（scale）</a>。此规则仅仅应用于浮点数值（比如，java.lang.Float,java.Lang.Double, java.lang.BigDecimal及其相关的子类），设置的结果同样也是很大程度上依赖于Hibernate跟底层数据库系统的交互程度。</p><p class="paragraph">约束定义着数值的最小/最大值，Grails使用数字的最大值来设置其精度。切记仅仅指定min/max约束中的一个，是不会影响到数据库的生成的（因为可能会是很大的负值，比如当max是100），除非指定的约束值要比Hibernate默认的精度（当前是19）更高，比如：</p><p class="paragraph"></p><div class="code"><pre>someFloatValue(max:1000000, scale:3)</pre></div><p class="paragraph">将产生：</p><p class="paragraph"></p><div class="code"><pre>someFloatValue DECIMAL(19, 3) // precision is <span class="java-keyword">default</span></pre></div><p class="paragraph">但是</p><p class="paragraph"></p><div class="code"><pre>someFloatValue(max:12345678901234567890, scale:5)</pre></div><p class="paragraph">将产生：
</p><div class="code"><pre>someFloatValue DECIMAL(25, 5) // precision = digits in max + scale</pre></div><p class="paragraph">和</p><p class="paragraph"></p><div class="code"><pre>someFloatValue(max:100, min:-100000)</pre></div><p class="paragraph">将产生：</p><p class="paragraph"></p><div class="code"><pre>someFloatValue DECIMAL(8, 2) // precision = digits in min + <span class="java-keyword">default</span> scale</pre></div>
<h1><a name="6. Web层">6. Web层</a></h1><h2><a name="6.1 控制器">6.1 控制器</a></h2>控制器是属于请求范围的,用于处理请求，创建或者准备响应。换句话说，每次<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/request.html" class="controllers">request</a>会创建一个新的控制器实体。控制器能产生响应或者委托给一个视图。创建一个控制器，简单创建一个类名以 <code>Controller</code> 结尾的类，并放于<code>grails-app/controllers</code>目录中。<p class="paragraph">默认的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL映射</a>设置能确保你的控制器名字的第一部分被映射到一个URI上，并且控制器中的每个操作定义被映射到控制器命名URI中的URI。</p><p class="paragraph"></p><h2><a name="6.1.1 理解控制器和操作">6.1.1 理解控制器和操作</a></h2><h4>创建一个控制器</h4><p class="paragraph">控制器可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-controller.html" class="commandLine">create-controller</a>目标创建.作为示例，可以在Grails根目录下尝试运行下列命令。
</p><div class="code"><pre>grails create-controller book</pre></div><p class="paragraph">这条命令将导致在<code>grails-app/controllers/BookController.groovy</code>位置上创建一个控制器。</p><p class="paragraph"></p><div class="code"><pre>class BookController { … }</pre></div><p class="paragraph"><code>BookController</code>默认映射到/book URI上（相对于您的应用程序根目录）</p><p class="paragraph"></p><blockquote class="note">
<code>create-controller</code>命令只不过是个方便的工具，你还可以使用你喜欢的文本编辑器或者IDE更容易的创建控制器。
</blockquote><p class="paragraph"></p><h4>创建操作（Actions）</h4><p class="paragraph">一个控制器可以拥有多个属性，每个属性都被分配一个代码块.每个这样的属性将被映射到URI上：
</p><div class="code"><pre>class BookController {
    def list = {<p class="paragraph">        // <span class="java-keyword">do</span> controller logic
        // create model</p><p class="paragraph">        <span class="java-keyword">return</span> model
    }
}</p></pre></div><p class="paragraph">默认情况下这个例子映射到/book/list URI上，因为属性被命名为<code>list</code>。</p><p class="paragraph"></p><h4>默认的操作</h4><p class="paragraph">一个控制器具有默认URI的概念即映射到控制器的根URI。默认情况下缺省URI在这里的是<code>/book</code>。默认的URI通过以下规则来支配：
</p><ul class="star">
<li>如果只有一个操作存在，一个控制器的默认URI将映射到该操作。</li>
<li>假如你定义了一个<code>index</code>操作，当没有操作被指定在URI<code>/book</code>上时，这个操作将处理请求。</li>
<li>除此之外，你可以明确的设置为<code>defaultAction</code>属性：</li>
</ul><p class="paragraph"></p><div class="code"><pre>def defaultAction = <span class="java-quote">"list"</span></pre></div>
<h2><a name="6.1.2 控制器和作用域">6.1.2 控制器和作用域</a></h2>h4.有效作用域<p class="paragraph">作用域本质上就像hash对象，允许你存储变量。下列为控制器有效作用域：
</p><ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/servletContext.html" class="controllers">servletContext</a> - 也被叫做应用范围, 这个范围允许你横跨整个web应用程序共享状态. servletContext对象为一个<a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletContext.html" class="api">javax.servlet.ServletContext</a>实体。</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/session.html" class="controllers">session</a> - session允许关联某个给定用户的状态，通常使用Cookie把一个session与一位客户关联起来  ，session对象为一个<a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpSession.html" class="api">HttpSession</a>实体</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/request.html" class="controllers">request</a> - request对象只允许存储当前的请求对象，request 对象为一个<a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html" class="api">HttpServletRequest</a>实体</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a> - 可变的进入请求参数map（map为java.util.Map类型参数）(CGI)。</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/flash.html" class="controllers">flash</a> - 见下文.</li>
</ul><p class="paragraph"></p><h4>访问作用域</h4><p class="paragraph">作用域的访问可以通过使用上面变量名与Groovy 的array索引操作符的结合来访问，甚至可以使用Servlet API提供的类，例如HttpServletRequest ： <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html" class="api">HttpServletRequest</a>:</p><p class="paragraph"></p><div class="code"><pre>class BookController {
    def find = {
        def findBy = params[<span class="java-quote">"findBy"</span>]
        def appContext = request[<span class="java-quote">"foo"</span>]
        def loggedUser = session[<span class="java-quote">"logged_user"</span>]<p class="paragraph">    }
}</p></pre></div><p class="paragraph">你甚至可以使用.操作符来存取作用域内部值，这样使语法更加简洁清楚：
</p><div class="code"><pre>class BookController {
    def find = {
        def findBy = params.findBy
        def appContext = request.foo
        def loggedUser = session.logged_user<p class="paragraph">    }
}</p></pre></div><p class="paragraph">这是统一存取不同作用域的方式之一.</p><p class="paragraph"></p><h4>使用Flash作用域</h4><p class="paragraph">Grails 支持<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/flash.html" class="controllers">flash</a>作用域的概念，它临时存贮只在这次请求和下次请求中使用的属性，随后属性值将被清除。这在重定向之前直接设置消息是非常有用的。
</p><div class="code"><pre>def delete = {
    def b = Book.get( params.id )
    <span class="java-keyword">if</span>(!b) {
        flash.message = <span class="java-quote">"User not found <span class="java-keyword">for</span> id ${params.id}"</span>
        redirect(action:list)
    }
    … // remaining code
}</pre></div>
<h2><a name="6.1.3 模型和视图">6.1.3 模型和视图</a></h2><h4>返回模型</h4><p class="paragraph">模型本质上是个map类型，当视图被渲染时使用。map中的keys转变成变量名可以让视图访问。这里有一对方式来返回模型，第一种方式是明确返回map实体：
</p><div class="code"><pre>def show = {
 	[ book : Book.get( params.id ) ]
}</pre></div><p class="paragraph">假如没有明确的模型被返回，控制器的属性将被当做模型来使用，因此允许你的代码写成下面这样:
</p><div class="code"><pre>class BookController {
    List books
    List authors
    def list = {
           books = Book.list()
           authors = Author.list()
    }
}</pre></div><p class="paragraph"></p><blockquote class="note">
这可能是由于事实上控制器是原型（prototype）范围。换句话说，每次请求，一个新的控制器会被创建，否则上面的代码将不是线程安全的。
</blockquote><p class="paragraph">在上面示例中的 <code>books</code> 和 <code>authors</code>属性将在视图中被使用。</p><p class="paragraph">一个更加高级的方法是返回Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/ModelAndView.html" class="api">ModelAndView</a> 类。
</p><div class="code"><pre><span class="java-keyword">import</span> org.springframework.web.servlet.ModelAndView
...<p class="paragraph">def index = {
    def favoriteBooks = … // get some books just <span class="java-keyword">for</span> the index page, perhaps your favorites</p><p class="paragraph">    // forward to the list view to show them
    <span class="java-keyword">return</span> <span class="java-keyword">new</span> ModelAndView(<span class="java-quote">"/book/list"</span>, [ bookList : favoriteBooks ])
}</p></pre></div><p class="paragraph">
</p><h4>选择视图</h4><p class="paragraph">在先前的两个示例里没有代码指定哪个 视图:guide:GSP去渲染。那么Grails怎么知道哪个视图被选取了？答案在于规约。观察这个操作：
</p><div class="code"><pre>class BookController {
	def show = {
	 	[ book : Book.get( params.id ) ]
	}	
}</pre></div><p class="paragraph">Grails 将自动在 <code>grails-app/views/book/show.gsp</code> 位置寻找一个视图(事实上Grails将首先尝试寻找JSP页面, 因为Grails可以等同的用于JSP).</p><p class="paragraph">假如你希望渲染另一个视图，那么<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法可以帮助你：
</p><div class="code"><pre>def show = {
  	def map = [ book : Book.get( params.id ) ]
    render(view:<span class="java-quote">"display"</span>, model:map)
}</pre></div><p class="paragraph">在这种情况下Grails将尝试渲染 <code>grails-app/views/book/display.gsp</code>位置上的视图。注意，Grails自动描述位于<code>book</code>文件夹中的 <code>grails-app/views</code> 路径位置的视图。很便利，但是假如你拥有一些共享的视图用来存取，作为替代使用：
</p><div class="code"><pre>def show = {
  	def map = [ book : Book.get( params.id ) ]
    render(view:<span class="java-quote">"/shared/display"</span>, model:map)
}</pre></div><p class="paragraph">在这种情况下Grails将尝试渲染<code>grails-app/views/shared/display.gsp</code>位置上的视图。</p><p class="paragraph">
</p><h4>渲染响应</h4><p class="paragraph">有时它很容易的渲染来自创建控制器小块文本或者代码的响应(通常使用Ajax应用程序)。因为使用了高度灵活的 "render"方法。
</p><div class="code"><pre>render <span class="java-quote">"Hello World!"</span></pre></div><p class="paragraph">
上面的代码打印出"Hello World!" 响应，其他的示例包括：
</p><div class="code"><pre>// write some markup
render {
   <span class="java-keyword">for</span>(b in books) {
      div(id:b.id, b.title)
   }
}
// render a specific view
render(view:'show')
// render a template <span class="java-keyword">for</span> each item in a collection
render(template:'book_template', collection:Book.list())
// render some text with encoding and content type
render(text:<span class="java-quote">"&lt;xml&gt;some xml&lt;/xml&gt;"</span>,contentType:<span class="java-quote">"text/xml"</span>,encoding:<span class="java-quote">"UTF-8"</span>)</pre></div><p class="paragraph">
</p><h2><a name="6.1.4 重定向和链">6.1.4 重定向和链</a></h2><h4>重定向</h4><p class="paragraph">所有的控制器的操作都可以使用 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/redirect.html" class="controllers">redirect</a>方法来重定向。
</p><div class="code"><pre>class OverviewController {
    def login = {}<p class="paragraph">    def find = {
        <span class="java-keyword">if</span>(!session.user)
           redirect(action:login)
        .....
    }
}</p></pre></div><p class="paragraph">在<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/redirect.html" class="controllers">redirect</a>方法内部，使用<a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletResponse.html" class="api">HttpServletResonse</a>对象的<code>sendRedirect</code>方法。</p><p class="paragraph"><code>redirect</code> 方法可以选择如下用法之一：
</p><ul class="star">
<li>在同一控制器类中另外的的闭包（closure）：</li>
</ul><p class="paragraph"></p><div class="code"><pre>// 同一个类中调用的login操作在
redirect(action:login)</pre></div>
<ul class="star">
<li>控制器的名字和操作：</li>
</ul><p class="paragraph"></p><div class="code"><pre>// 同样重定向到home controller中的index操作
redirect(controller:'home',action:'index')</pre></div>
<ul class="star">
<li>一个应用程序上下文资源关联路径URI：</li>
</ul><p class="paragraph"></p><div class="code"><pre>// 重定向到一个明确的URI
redirect(uri:<span class="java-quote">"/login.html"</span>)</pre></div>        
<ul class="star">
<li>或者完整的URL：</li>
</ul><p class="paragraph"></p><div class="code"><pre>// 重定向到一个URL
redirect(url:<span class="java-quote">"http://grails.org"</span>)</pre></div><p class="paragraph">使用<code>params</code>作为方法的参数,参数可以被随意的从一个操作传递到下一个：      
</p><div class="code"><pre>redirect(action:myaction, params:[myparam:<span class="java-quote">"myvalue"</span>])</pre></div><p class="paragraph">
这些参数通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>动态属性变得可用，它同样存取请求参数。如果一个参数跟请求参数同名，那么请求参数将被覆盖，控制器的参数将被优先使用。</p><p class="paragraph">由于这个<code>params</code>对象同样是一个map，你可以使用它传递当前的请求参数从一个操作传递到下个操作:
</p><div class="code"><pre>redirect(action:<span class="java-quote">"next"</span>, params:params)</pre></div><p class="paragraph"></p><h4>链（Chaining）</h4>
操作同样可以作为一个链。 链（Chaining）允许模型从一个操作传递到下个操作之间被保存。在下面的操作中调用操作<code>first</code>操作，例如：
<div class="code"><pre>class ExampleChainController {
    def first = {
        chain(action:second,model:[one:1])
    }
    def second  = {
        chain(action:third,model:[two:2])
    }
    def third = {
         [three:3])
    }
}</pre></div><p class="paragraph">
返回的模型结果：
</p><div class="code"><pre>[one:1, two:2, three:3]</pre></div><p class="paragraph">通过<code>chainModel</code>map，该模型可在随后的连接中的控制器的操作中被存取。这个动态属性只存在于操作：
</p><div class="code"><pre>class ChainController {<p class="paragraph">    def nextInChain = {
        def model = chainModel.myModel
        .....
    }
}</p></pre></div><p class="paragraph">
同<code>redirect</code>方法一样，你也可以给<code>chain</code>方法传递参数：            
</p><div class="code"><pre>chain(action:<span class="java-quote">"action1"</span>, model:[one:1], params:[myparam:<span class="java-quote">"param1"</span>])</pre></div><p class="paragraph"></p><h2><a name="6.1.5 控制器拦截器">6.1.5 控制器拦截器</a></h2>通常，它有利于拦截基于每个request,session或者application状态的数据处理。 这个可以通过操作的拦截器来完成。当前有两种类型的拦截器:before和after。<p class="paragraph"></p><blockquote class="note">
如果你的拦截很可能用于一个以上的控制器，你几乎肯定会写一个更好的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6 过滤器" class="guide">Filter</a>，这样可以在一个横切（cross cutting）管理中应用于多个控制器或者URIs而不需要改变每个控制器的逻辑
</blockquote><p class="paragraph"></p><h4>Before 拦截器</h4><p class="paragraph">这个<code>beforeInterceptor</code>拦截器在操作执行之前被处理。如果它返回false 那么被拦截的操作将不会被执行。在一个控制器内，拦截器可以被定义在所有的操作内，如下：</p><p class="paragraph"></p><div class="code"><pre>def beforeInterceptor = {
       println <span class="java-quote">"Tracing action ${actionUri}"</span>
}</pre></div><p class="paragraph">
上面在控制器定义主体内被声明。它将在所有操作之前被执行。它将在所有操作之前被处理并且不干扰数据处理。一个通常使用的情形是为了验证：
</p><div class="code"><pre>def beforeInterceptor = [action:<span class="java-keyword">this</span>.&amp;auth,except:'login']
// defined as a regular method so its <span class="java-keyword">private</span>
def auth() {
     <span class="java-keyword">if</span>(!session.user) {
            redirect(action:'login')
            <span class="java-keyword">return</span> <span class="java-keyword">false</span>
     }
}
def login = {
     // display login page
}</pre></div><p class="paragraph">
上面的代码定义了一个名为 <code>auth</code>的方法。一个方法作为一个操作使用，以至于不被暴露于外界（即它是私有的）。<code>beforeInterceptor</code>被用于'除了'login'操作之外的所有操作，并被告知执行'auth'方法。'auth'使用Groovy的方法指示器语法来引用。在方法中，方法本身会检查一个用户是否存在于session中，否则，它将导航到login操作并返回false,说明被拦截的操作不会被执行。</p><p class="paragraph"></p><h4>After 拦截器</h4><p class="paragraph">使用<code>afterInterceptor</code>属性来定义一个拦截器，它会在一个操作之后被执行：
</p><div class="code"><pre>def afterInterceptor = { model -&gt;
       println <span class="java-quote">"Tracing action ${actionUri}"</span>
}</pre></div><p class="paragraph">这个after拦截器获取结果模型作为参数，因此可以执行传送模型操作或者响应。</p><p class="paragraph">一个after 拦截器也可以事先来渲染通过修改Spring MVC的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/ModelAndView.html" class="api">ModelAndView</a>对象。在这种情况下，上面的例子变成
</p><div class="code"><pre>def afterInterceptor = { model, modelAndView -&gt;
       println <span class="java-quote">"Current view is ${modelAndView.viewName}"</span>
       <span class="java-keyword">if</span>(model.someVar) modelAndView.viewName = <span class="java-quote">"/mycontroller/someotherview"</span>
       println <span class="java-quote">"View is now ${modelAndView.viewName}"</span>
}</pre></div><p class="paragraph">这里允许通过当前的操作改变基于返回模型的视图。注意，<code>modelAndView</code>可能为<code>null</code> 假如被拦截的操作调用redirect或render。</p><p class="paragraph"></p><h4>拦截条件</h4><p class="paragraph">Rails用户将会十分熟悉authentication示例和当执行拦截的时候怎样使用'except'条件（在Gails中拦截被叫做'filters'，这个术语与Java中的servlet filter存在冲突）：
</p><div class="code"><pre>def beforeInterceptor = [action:<span class="java-keyword">this</span>.&amp;auth,except:'login']</pre></div><p class="paragraph">执行除指定操作外的所有操作拦截。操作列表同样可以按下列这样被定义：
</p><div class="code"><pre>def beforeInterceptor = [action:<span class="java-keyword">this</span>.&amp;auth,except:['login','register']]</pre></div><p class="paragraph">其他支持的条件是'only'，只执行指定操作拦截：
</p><div class="code"><pre>def beforeInterceptor = [action:<span class="java-keyword">this</span>.&amp;auth,only:['secure']]</pre></div><p class="paragraph"></p><p class="paragraph">
</p><h2><a name="6.1.6 数据绑定">6.1.6 数据绑定</a></h2>数据绑定是"绑定"进入的请求参数到一个对象的属性或者一个完整对象图的行为。数据绑定将处理所有来自请求参数必要的类型装换。它们通常通过表单提交来实现，并总是String类型，可是，Groovy 或者Java对象的属性很可能不是。<p class="paragraph">Grails使用<a href="http://www.springframework.org/" target="blank">Spring</a>的基本数据绑定能力来完成数据绑定。</p><p class="paragraph"></p><h4>绑定Request数据到模型上</h4><p class="paragraph">这里有2个方法来绑定请求参数到一个领域类的属性上。第一，涉及到使用领域类的隐式构造器
</p><div class="code"><pre>def save = {
  def b = <span class="java-keyword">new</span> Book(params)
  b.save()
}</pre></div><p class="paragraph">数据绑定发生在<code>new Book(params)</code>代码内。通过传递 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象到领域类的构造器，Grails自动识别你正在试图绑定来自请求中的参数。因此，假如我们有一个像这样进入的请求：
</p><div class="code"><pre>/book/save?title=The%20Stand&amp;author=Stephen%20King</pre></div><p class="paragraph">那么，<code>title</code> 和 <code>author</code>请求参数将自动被设置到领域类上。假如，你需要执行数据绑定到一个已存在的实例上，那么，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/properties.html" class="domainClasses">properties</a>属性：
</p><div class="code"><pre>def save = {
  def b = Book.get(params.id)
  b.properties = params
  b.save()
}</pre></div><p class="paragraph">这与使用隐式构造函数是完全一样的作用</p><p class="paragraph"></p><h4>数据绑定和关联</h4><p class="paragraph">假如你有一个<code>one-to-one</code> 或 <code>many-to-one</code>关联，你同样可以使用Grails的数据绑定能力来更新这些关联，例如，假如你有这样一个进入的请求：
</p><div class="code"><pre>/book/save?author.id=20</pre></div><p class="paragraph">Grails 将自动检测请求参数上的 <code>.id</code>后缀，并在进行数据绑定的时候查找给定的id的<code>Author</code>实体，像这样：
</p><div class="code"><pre>def b = <span class="java-keyword">new</span> Book(params)</pre></div><p class="paragraph"></p><h4>数据绑定多个领域类</h4><p class="paragraph">有可能绑定数据到领域类来自<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象。</p><p class="paragraph">举例来说，你有个进入的请求：
</p><div class="code"><pre>/book/save?book.title=The%20Stand&amp;author.name=Stephen%20King</pre></div><p class="paragraph">你将注意到和上面请求不同的是每个参数带有个像<code>author.</code> 或 <code>book.</code>这样的前缀，这是用来分隔哪个参数属于哪种类型的。Grails的<code>params</code>对象就像一个多维散列表，你可以索引
</p><div class="code"><pre>def b = <span class="java-keyword">new</span> Book(params['book'])</pre></div><p class="paragraph">注意我们是怎么样使用<code>book.title</code>的第一圆点前面的前缀参数来隔离唯一的参数来绑定。我们同样可以这样来使用<code>Author</code>领域类：
</p><div class="code"><pre>def a = <span class="java-keyword">new</span> Author(params['author'])</pre></div><p class="paragraph"></p><h4>数据绑定和类型转换错误</h4><p class="paragraph">有时，当执行数据绑定时它可能不会把一个特殊的String转换到一个特殊的目标类型。你得到一个什么样的类型转换错误。Grails将保存类型转换错误到一个领域类的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/errors.html" class="domainClasses">errors</a>属性中。借这个例子：
</p><div class="code"><pre>class Book {
    …
    URL publisherURL
}</pre></div><p class="paragraph">这里，我们有个领域类<code>Book</code>，它使用Java具体类型<code>java.net.URL</code>来表示URLs。现在，假设我们有个先这样的进入参数：
</p><div class="code"><pre>/book/save?publisherURL=a-bad-url</pre></div><p class="paragraph">
在这种情况下，它不可能绑定这个string类型<code>a-bad-url</code>到<code>publisherURL</code>属性上，你可以像这样检查：</p><p class="paragraph"></p><div class="code"><pre>def b = <span class="java-keyword">new</span> Book(params)<p class="paragraph"><span class="java-keyword">if</span>(b.hasErrors()) {
   println <span class="java-quote">"The value ${b.errors.getFieldError('publisherURL').rejectedValue} is not a valid URL!"</span>
}</p></pre></div><p class="paragraph">机关我们尚未隐藏错误代码(更多参考见 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7. 验证" class="guide">验证</a>部分)，对于类型转换错误，你将可以使用grails-app/i18n/messages.properties file来定义错误信息。你可以像这样来使用普通的消息处理：
</p><div class="code"><pre>typeMismatch.java.net.URL=The field {0} is not a valid URL</pre></div><p class="paragraph">或者更具体的：
</p><div class="code"><pre>typeMismatch.Book.publisherURL=The publisher URL you specified is not a valid URL</pre></div><p class="paragraph"></p><h4>数据绑定和安全关系</h4><p class="paragraph">当批量更新来自请求参数的属性时，你必须小心，不能允许客户端绑定恶意的数据到领域类，最后持久到数据库中。</p><p class="paragraph">这个问题可以通过两种方式来避免，一种是使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.9 命令对象" class="guide">命令对象</a>。另一种方式是本文所述的，使用灵活的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/bindData.html" class="controllers">bindData</a>方法。</p><p class="paragraph">这个<code>bindData</code>方法有着同样的数据绑定能力，但是是对任何对象：
</p><div class="code"><pre>def sc = <span class="java-keyword">new</span> SaveCommand()
bindData(sc, params)</pre></div><p class="paragraph">然而，这个<code>bindData</code>方法允许排除某些不想更新的的参数：
</p><div class="code"><pre>def sc = <span class="java-keyword">new</span> SaveCommand()
bindData(sc, params, ['myReadOnlyProp'])</pre></div><p class="paragraph"></p><p class="paragraph"></p><h2><a name="6.1.7 XML和JSON响应">6.1.7 XML和JSON响应</a></h2><h4>使用render方法输出XML</h4><p class="paragraph">Grails支持一些不同的方法来产生XML和JSON响应。第一个是隐式的通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法。</p><p class="paragraph"><code>render</code>方法可以传递一个代码块来执行标记生成器产生XML
</p><div class="code"><pre>def list = {
	def results = Book.list()
	render(contentType:<span class="java-quote">"text/xml"</span>) {
		books {
			<span class="java-keyword">for</span>(b in results) {
				book(title:b.title)
			}
		}	
	}
}</pre></div><p class="paragraph">这段代码的结果将会像这样：
</p><div class="code"><pre><span class="xml-tag">&lt;books&gt;</span>
	  <span class="xml-tag">&lt;book title=<span class="xml-quote">"The Stand"</span> /&gt;</span>
	  <span class="xml-tag">&lt;book title=<span class="xml-quote">"The Shining"</span> /&gt;</span>	
<span class="xml-tag">&lt;/books&gt;</span></pre></div><p class="paragraph">注意，当你使用标记生成器时，必须小心避免命名冲突。例如，这段代码将产生一个错误：
</p><div class="code"><pre>def list = {
	def books = Book.list()  // naming conflict here
	render(contentType:<span class="java-quote">"text/xml"</span>) {
		books {
			<span class="java-keyword">for</span>(b in results) {
				book(title:b.title)
			}
		}	
	}
}</pre></div><p class="paragraph">原因是，这里的一个本地变量<code>books</code>企图作为方法被调用。</p><p class="paragraph"></p><h4>使用render方法输出JSON</h4><p class="paragraph"><code>render</code> 方法可以同样被用于输出JSON:
</p><div class="code"><pre>def list = {
	def results = Book.list()
	render(contentType:<span class="java-quote">"text/json"</span>) {
		books {
			<span class="java-keyword">for</span>(b in results) {
				book(title:b.title)
			}
		}	
	}
}</pre></div><p class="paragraph">在这种情况下，结果就会是大致相同的：
</p><div class="code"><pre>[
	{title:<span class="java-quote">"The Stand"</span>}, 
	{title:<span class="java-quote">"The Shining"</span>}
]</pre></div><p class="paragraph">同样的命名冲突危险适用于JSON生成器。</p><p class="paragraph"></p><h4>自动XML列集(Marshalling)</h4><p class="paragraph">
（译者注：在此附上对于列集(Marshalling)解释：对函数参数进行打包处理得过程，因为指针等数据，必须通过一定得转换，才能被另一组件所理解。可以说列集(Marshalling)是一种数据格式的转换方法。）</p><p class="paragraph">Grails同样支持自动列集(Marshalling)<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">领域类</a>为XML通过特定的转换器。</p><p class="paragraph">首先，导入<code>grails.converters</code> 类包到你的控制器（Controllers）中：            
</p><div class="code"><pre><span class="java-keyword">import</span> grails.converters.*</pre></div><p class="paragraph">现在，你可以使用下列高度易读的语法来自动转换领域类成XML：
</p><div class="code"><pre>render Book.list() as XML</pre></div><p class="paragraph">输出结果看上去会像下列这样：
</p><div class="code"><pre>&lt;?xml version=<span class="java-quote">"1.0"</span> encoding=<span class="java-quote">"ISO-8859-1"</span>?&gt;
&lt;list&gt;
  &lt;book id=<span class="java-quote">"1"</span>&gt;
    &lt;author&gt;Stephen King&lt;/author&gt;
    &lt;title&gt;The Stand&lt;/title&gt;
  &lt;/book&gt;
  &lt;book id=<span class="java-quote">"2"</span>&gt;
    &lt;author&gt;Stephen King&lt;/author&gt;
    &lt;title&gt;The Shining&lt;/title&gt;
  &lt;/book&gt;
&lt;/list&gt;</pre></div><p class="paragraph">一个使用转换器的替代方法是使用Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">codecs</a>特性。codecs特性提供了<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">encodeAsXML</a>和<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">encodeAsJSON</a>方法:
</p><div class="code"><pre>def xml = Book.list().encodeAsXML()
render xml</pre></div><p class="paragraph">更多的XML 列集(Marshalling)信息见<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13.1 REST" class="guide">REST</a>部分</p><p class="paragraph"></p><h4>自动JSON列集(Marshalling)</h4><p class="paragraph">Grails同样支持自动列集(Marshalling)为JSON通过同样的机制。简单替代<code>XML</code> 为<code>JSON</code>
</p><div class="code"><pre>render Book.list() as JSON</pre></div><p class="paragraph">输出结果看上去会像下列这样：
</p><div class="code"><pre>[
	{<span class="java-quote">"id"</span>:1,
	 <span class="java-quote">"class"</span>:<span class="java-quote">"Book"</span>,
	 <span class="java-quote">"author"</span>:<span class="java-quote">"Stephen King"</span>,
	 <span class="java-quote">"title"</span>:<span class="java-quote">"The Stand"</span>},
	{<span class="java-quote">"id"</span>:2,
	 <span class="java-quote">"class"</span>:<span class="java-quote">"Book"</span>,
	 <span class="java-quote">"author"</span>:<span class="java-quote">"Stephen King"</span>,
	 <span class="java-quote">"releaseDate"</span>:<span class="java-keyword">new</span> Date(1194127343161),
	 <span class="java-quote">"title"</span>:<span class="java-quote">"The Shining"</span>}
 ]</pre></div><p class="paragraph">再次作为一种替代，你可以使用<code>encodeAsJSON</code>达到相同的效果
</p><h2><a name="6.1.8 上传文件">6.1.8 上传文件</a></h2><h4>文件上传程序</h4><p class="paragraph">Grails通过Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartHttpServletRequest.html" class="api">MultipartHttpServletRequest</a>接口来支持文件上传。上传文件的第一步就是像下面这样创建一个multipart form：
</p><div class="code"><pre>Upload Form: <span class="xml-tag">&lt;br /&gt;</span>
	<span class="xml-tag">&lt;g:form action=<span class="xml-quote">"upload"</span> method=<span class="xml-quote">"post"</span> enctype=<span class="xml-quote">"multipart/form-data"</span>&gt;</span>
		<span class="xml-tag">&lt;input type=<span class="xml-quote">"file"</span> name=<span class="xml-quote">"myFile"</span> /&gt;</span>
		<span class="xml-tag">&lt;input type=<span class="xml-quote">"submit"</span> /&gt;</span>
	<span class="xml-tag">&lt;/g:form&gt;</span></pre></div><p class="paragraph">有那么一些的方式来处理文件上传。第一种方法是直接与Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartFile.html" class="api">MultipartFile</a>实例合作：
</p><div class="code"><pre>def upload = {
    def f = request.getFile('myFile')
    <span class="java-keyword">if</span>(!f.empty) {
      f.transferTo( <span class="java-keyword">new</span> File('/some/local/dir/myfile.txt') )
      response.sendError(200,'Done');
    }    
    <span class="java-keyword">else</span> {
       flash.message = 'file cannot be empty'
       render(view:'uploadForm')
    }
}</pre></div><p class="paragraph">这显然是得心应手，通过<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/multipart/MultipartFile.html" class="api">MultipartFile</a>接口可以直接获得一个InputStream，用来转移到其他目的地和操纵文件等等.</p><p class="paragraph"></p><h4>文件上传通过数据绑定</h4><p class="paragraph">文件上传同样可以通过数据绑定来完成。例如，假定你有个<code>Image</code>领域类按照下面的示例：
</p><div class="code"><pre>class Image {
   <span class="java-object">byte</span>[] myFile
}</pre></div><p class="paragraph">现在，假如你创建一个image并像下面这个示例一样传入<code>params</code> 对象，Grails将自动把文件的内容当作一个byte绑定到<code>myFile</code>属性:
</p><div class="code"><pre>def img = <span class="java-keyword">new</span> Image(params)</pre></div><p class="paragraph">它同样可以设置文件的内容为一个string，通过改变image的<code>myFile</code>属性类型为一个String类型：
</p><div class="code"><pre>class Image {
   <span class="java-object">String</span> myFile
}</pre></div><p class="paragraph"></p><h2><a name="6.1.9 命令对象">6.1.9 命令对象</a></h2>Grails控制器支持命令对象概念。一个命令对象类似于Struts中的一个formbean,它们在当你想要写入属性子集来更新一个领域类情形时是非常有用的。<p class="paragraph"></p><h4>声明命令对象</h4><p class="paragraph">命令对象通常作为一个控制器直接声明在控制器类定义下的同一个源文件中。例如：
</p><div class="code"><pre>class UserController {
	…
}
class LoginCommand {
   <span class="java-object">String</span> username
   <span class="java-object">String</span> password
   <span class="java-keyword">static</span> constraints = {
           username(blank:<span class="java-keyword">false</span>, minSize:6)
           password(blank:<span class="java-keyword">false</span>, minSize:6)
   }
}</pre></div><p class="paragraph">上面的示例证明，你可以提供<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">约束</a>给命令，就象你在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">领域类</a>用法一样。</p><p class="paragraph"></p><h4>使用命令对象</h4><p class="paragraph">为了使用命令对象，控制器可以随意指定任何数目的命令对象参数。必须提供参数的类型以至于Grails能知道什么样的对象被创建，写入和验证。</p><p class="paragraph">在控制器的操作被执行之前，Grails将自动创建一个命令对象类的实体，用相应名字的请求参数写入到命令对象属性，并且命令对象将被验证，例如：
</p><div class="code"><pre>class LoginController {
  def login = { LoginCommand cmd -&gt;
         <span class="java-keyword">if</span>(cmd.hasErrors()) {
                redirect(action:'loginForm')
         }
         <span class="java-keyword">else</span> {
            // <span class="java-keyword">do</span> something <span class="java-keyword">else</span>
        }
  }
}</pre></div><p class="paragraph"></p><h4>命令对象与依赖注入</h4><p class="paragraph">命令对象可以参与依赖注入。这有利于一些定制的验证逻辑与Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8. 服务层" class="guide">services</a>的结合。
</p><div class="code"><pre>class LoginCommand {
    def loginService<p class="paragraph">	<span class="java-object">String</span> username
	<span class="java-object">String</span> password
	<span class="java-keyword">static</span> constraints = {
		username(validator: {
			loginService.canLogin(username, password)
		})
	}
}</p></pre></div><p class="paragraph">上面示例，命令对象与一个来自Spring的<code>ApplicationContext</code>注入名字bean结合。</p><p class="paragraph"></p><h2><a name="6.2 Groovy Server Pages">6.2 Groovy Server Pages</a></h2>Groovy Servers Pages (或者简写为 GSP)Grails的视图技术。它被设计成像ASP和JSP这样被使用者熟悉的技术，但更加灵活和直观。<p class="paragraph">GSP存在于Grails的<code>grails-app/views</code>目录中，他们通常会自动渲染（通过规约），或者像这样通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法：
</p><div class="code"><pre>render(view:<span class="java-quote">"index"</span>)</pre></div><p class="paragraph">一个GSP是典型的混合标签和GSP指令来帮助视图渲染。
</p><blockquote class="note">
虽然，它可能在把Grrails逻辑嵌入到你的GSP中，这样做将会覆盖这个文档，这个做法是强烈反对的。混合标签和代码是个<strong class="bold">bad</strong>事情，很多GSP没有包括代码也没有必要这样做。
</blockquote><p class="paragraph">一个GPS通常拥有一个"model"，它是变量集被用于视图渲染。通过一个控制器model被传递到GSP视图。例如，考虑下列控制器的操作：
</p><div class="code"><pre>def show = {
	[book: Book.get(params.id)]
}</pre></div><p class="paragraph">这个操作将查找一个<code>Book</code> 实体，并创建一个包含关键字为<code>book</code>的model,这个关键字可在随后的GSP视图中应用：
</p><div class="code"><pre>&lt;%=book.title%&gt;</pre></div>
<h2><a name="6.2.1 GSP基础">6.2.1 GSP基础</a></h2>在下一节，我们将通过GSP基础知识让你知道它能做什么。首先，我们将涵盖基础语法，对于JSP和ASP用户是非常熟悉的。<p class="paragraph">GSP支持使用 <code>&lt;% %&gt;</code>来嵌入Groovy代码(这是不推荐的):
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
   <span class="xml-tag">&lt;body&gt;</span>
     <span class="xml-tag">&lt;% out &lt;&lt; <span class="xml-quote">"Hello GSP!"</span> %&gt;</span>
   <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">同样，你可以使用<code>&lt;%= %&gt;</code>语法来输出值：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
   <span class="xml-tag">&lt;body&gt;</span>
     <span class="xml-tag">&lt;%=<span class="xml-quote">"Hello GSP!"</span> %&gt;</span>
   <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">
GSP同样支持服务器端JSP样式注释，像下列示例显示的这样：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
   <span class="xml-tag">&lt;body&gt;</span>
	 <span class="xml-tag">&lt;%-- This is my comment --%&gt;</span>
     <span class="xml-tag">&lt;%=<span class="xml-quote">"Hello GSP!"</span> %&gt;</span>
   <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div>
<h2><a name="6.2.1.1 变量和作用域">6.2.1.1 变量和作用域</a></h2>在<code>&lt;% %&gt;</code>中你当然可以声明变量：
<div class="code"><pre><span class="xml-tag">&lt;% now = new Date() %&gt;</span></pre></div><p class="paragraph">然后，在页面中的之后部分可以重复使用
</p><div class="code"><pre><span class="xml-tag">&lt;%=now%&gt;</span></pre></div><p class="paragraph">然而, 在GSP中存在着一些预先定义的变量，包括:
</p><ul class="star">
<li><code>application</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletContext.html" class="api">javax.servlet.ServletContext</a>实例</li>
<li><code>applicationContext</code> Spring <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>实例</li>
<li><code>flash</code> - <a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/flash.html" class="controllers">flash</a> 对象</li>
<li><code>grailsApplication</code> -  <a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> 实例</li>
<li><code>out</code> - 响应输出流</li>
<li><code>params</code> -<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象用于检索请求参数</li>
<li><code>request</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html" class="api">HttpServletRequest</a>实例</li>
<li><code>response</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletResponse.html" class="api">HttpServletResponse</a>实例</li>
<li><code>session</code> - <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpSession.html" class="api">HttpSession</a>实例</li>
<li><code>webRequest</code> - <a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/web/servlet/mvc/GrailsWebRequest.html" class="api">GrailsWebRequest</a>实例</li>
</ul><p class="paragraph"></p><h2><a name="6.2.1.2 逻辑和迭代">6.2.1.2 逻辑和迭代</a></h2>使用<code>&lt;% %&gt;</code> 语法，你当然可以使用这样的语法进行嵌套循环等等操作：
<div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
   <span class="xml-tag">&lt;body&gt;</span>
      <span class="xml-tag">&lt;% [1,2,3,4].each { num -&gt;</span> %&gt;
         <span class="xml-tag">&lt;p&gt;</span><span class="xml-tag">&lt;%=<span class="xml-quote">"Hello ${num}!"</span> %&gt;</span><span class="xml-tag">&lt;/p&gt;</span>
      <span class="xml-tag">&lt;%}%&gt;</span>
   <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">同样可以分支逻辑：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
   <span class="xml-tag">&lt;body&gt;</span>
      <span class="xml-tag">&lt;% if(params.hello == 'true' )%&gt;</span>	
      <span class="xml-tag">&lt;%=<span class="xml-quote">"Hello!"</span>%&gt;</span>
      <span class="xml-tag">&lt;% else %&gt;</span>
      <span class="xml-tag">&lt;%=<span class="xml-quote">"Goodbye!"</span>%&gt;</span>
   <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div>
<h2><a name="6.2.1.3 页面指令">6.2.1.3 页面指令</a></h2>GSP同样支持少许的JSP样式页面指令<p class="paragraph"><code>import</code>指令允许在页面中导入类。然而，它却很少被使用，因为Groovy缺省导入和<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2 GSP标签" class="guide">GSP标签</a>已经足够：
</p><div class="code"><pre><span class="xml-tag">&lt;%<code> page import=<span class="xml-quote">"java.awt.*"</span> %&gt;</code></span></pre></div><p class="paragraph"><code>GSP同样支持</code>contentType@ 指令
</p><div class="code"><pre><span class="xml-tag">&lt;%<code> page contentType=<span class="xml-quote">"text/json"</span> %&gt;</code></span></pre></div><p class="paragraph">contentType@指令允许GSP使用其他的格式来渲染。
</p><h2><a name="6.2.1.4 表达式">6.2.1.4 表达式</a></h2>尽管GSP也支持<code>&lt;%= %&gt;</code> 语法，而且很早就介绍过，但在实际当中却很少应用，因为此用法主要是为ASP和 、JSP开发者所保留的。而GSP的表达式跟JSP EL表达式很相似的，跟Groovy GString的<code>${expr}</code>用法也很像
<div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
  <span class="xml-tag">&lt;body&gt;</span>
    Hello ${params.name}
  <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">尽管如此，跟JSP EL不同的是，你可以在<code>${..}</code>括号中使用Groovy表达式。<code>${..}</code>中的变量缺省情况下是<strong class="bold">不</strong>被转义的，因此变量的任何HTML字符串内容被直接输出到页面，要减少这种Cross-site-scripting (XSS)攻击的风险，你可以设置<code>grails-app/conf/Config.groovy</code>中的 <code>grails.views.default.codec</code>为HTML转化方式。
</p><div class="code"><pre>grails.views.<span class="java-keyword">default</span>.codec='html'</pre></div><p class="paragraph">其他可选的值是'none' (缺省值)和'base64'。
</p><h2><a name="6.2.2 GSP标签">6.2.2 GSP标签</a></h2>现在，JSP遗传下来的缺点已经被取消，下面的章节将涵盖GSP的内置标签，它是定义GSP页面最有利的方法。
<blockquote class="note">
<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库" class="guide">标签库</a>部分涵盖怎么添加你自己的定制标签库。
</blockquote><p class="paragraph">所有GSP内置标签以前缀<code>g:</code>开始。不像JSP，你不需要指定任何标签库的导入。假如，一个标签以<code>g:</code>开始，它被自动认为是一个GSP标签。一个GPS标签的示例看起来像这样：
</p><div class="code"><pre><span class="xml-tag">&lt;g:example /&gt;</span></pre></div><p class="paragraph">GSP标签同样可以拥有主体，像这样：
</p><div class="code"><pre><span class="xml-tag">&lt;g:example&gt;</span>
   Hello world
<span class="xml-tag">&lt;/g:example&gt;</span></pre></div><p class="paragraph">表达式被传递给GSP标签属性，假如没有使用表达式，将被认为是一个String值：
</p><div class="code"><pre><span class="xml-tag">&lt;g:example attr=<span class="xml-quote">"${new Date()}"</span>&gt;</span>
   Hello world
<span class="xml-tag">&lt;/g:example&gt;</span></pre></div><p class="paragraph">Maps同样能被传递给GSP标签属性，通常使用一个命名参数样式语法：
</p><div class="code"><pre><span class="xml-tag">&lt;g:example attr=<span class="xml-quote">"${new Date()}"</span> attr2=<span class="xml-quote">"[one:1, two:2, three:3]"</span>&gt;</span>
   Hello world
<span class="xml-tag">&lt;/g:example&gt;</span></pre></div><p class="paragraph">注意，对于String类型属性值，你必须使用单引号：
</p><div class="code"><pre><span class="xml-tag">&lt;g:example attr=<span class="xml-quote">"${new Date()}"</span> attr2=<span class="xml-quote">"[one:'one', two:'two']"</span>&gt;</span>
   Hello world
<span class="xml-tag">&lt;/g:example&gt;</span></pre></div><p class="paragraph">在介绍完基本的语法之后，下面我们来讲解Grails中默认提供的标签</p><p class="paragraph"></p><h2><a name="6.2.2.1 变量和作用域">6.2.2.1 变量和作用域</a></h2>变量可以在GSP中使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/set.html" class="tags">set</a>标签来定义：
<div class="code"><pre><span class="xml-tag">&lt;g:set var=<span class="xml-quote">"now"</span> value=<span class="xml-quote">"${new Date()}"</span> /&gt;</span></pre></div><p class="paragraph">这里，我们给GSP表达式结果赋予了一个名为<code>now</code>的变量 (简单的构建一个新的 <code>java.util.Date</code> 实体)。你也可以在<code>&lt;g:set&gt;</code>主体中定义一个变量：
</p><div class="code"><pre><span class="xml-tag">&lt;g:set var=<span class="xml-quote">"myHTML"</span>&gt;</span>
   Some re-usable code on: ${new Date()}
<span class="xml-tag">&lt;/g:set&gt;</span></pre></div><p class="paragraph">变量同样可以被放置于下列的范围内：
</p><ul class="star">
<li><code>page</code> - 当前页面范围 (默认)</li>
<li><code>request</code> - 当前请求范围</li>
<li><code>flash</code> - <a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/flash.html" class="controllers">flash</a>作用域，因此它可以在下一次请求中有效</li>
<li><code>session</code> - 用户session范围</li>
<li><code>application</code> - 全局范围.</li>
</ul><p class="paragraph">选择变量被放入的范围可以使用<code>scope</code>属性
</p><div class="code"><pre><span class="xml-tag">&lt;g:set var=<span class="xml-quote">"now"</span> value=<span class="xml-quote">"${new Date()}"</span> scope=<span class="xml-quote">"request"</span> /&gt;</span></pre></div>
<h2><a name="6.2.2.2 逻辑和迭代">6.2.2.2 逻辑和迭代</a></h2>GSP同样支持迭代逻辑标签，逻辑上通过使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/if.html" class="tags">if</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/else.html" class="tags">else</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/elseif.html" class="tags">elseif</a>来支持典型的分支情形。
<div class="code"><pre><span class="xml-tag">&lt;g:if test=<span class="xml-quote">"${session.role == 'admin'}"</span>&gt;</span>
   <span class="xml-tag">&lt;%-- show administrative functions --%&gt;</span>
<span class="xml-tag">&lt;/g:if&gt;</span>
<span class="xml-tag">&lt;g:else&gt;</span>
   <span class="xml-tag">&lt;%-- show basic functions --%&gt;</span>
<span class="xml-tag">&lt;/g:else&gt;</span></pre></div><p class="paragraph">GSP用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/each.html" class="tags">each</a>和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/while.html" class="tags">while</a> 标签来处理迭代：
</p><div class="code"><pre><span class="xml-tag">&lt;g:each in=<span class="xml-quote">"${[1,2,3]}"</span> var=<span class="xml-quote">"num"</span>&gt;</span>
   <span class="xml-tag">&lt;p&gt;</span>Number ${num}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:each&gt;</span><p class="paragraph"><span class="xml-tag">&lt;g:set var=<span class="xml-quote">"num"</span> value=<span class="xml-quote">"${1}"</span> /&gt;</span>
<span class="xml-tag">&lt;g:while test=<span class="xml-quote">"${num &lt; 5 }"</span>&gt;</span>
    <span class="xml-tag">&lt;p&gt;</span>Number ${num++}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:while&gt;</span></p></pre></div>
<h2><a name="6.2.2.3 搜索和过滤">6.2.2.3 搜索和过滤</a></h2>假如你拥有对象集合，你经常需要使用一些方法来排序和过滤他们。GSP支持<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/findAll.html" class="tags">findAll</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/grep.html" class="tags">grep</a>来做这些工作。
<div class="code"><pre>Stephen King's Books:
<span class="xml-tag">&lt;g:findAll in=<span class="xml-quote">"${books}"</span> expr=<span class="xml-quote">"it.author == 'Stephen King'"</span>&gt;</span>
     <span class="xml-tag">&lt;p&gt;</span>Title: ${it.title}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:findAll&gt;</span></pre></div><p class="paragraph"><code>expr</code>属性包含了一个Groovy表达式，它可以被当作一个过滤器来使用。谈到过滤器，<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/grep.html" class="tags">grep</a>标签通过类来完成与过滤器类似的工作：
</p><div class="code"><pre><span class="xml-tag">&lt;g:grep in=<span class="xml-quote">"${books}"</span> filter=<span class="xml-quote">"NonFictionBooks.class"</span>&gt;</span>
     <span class="xml-tag">&lt;p&gt;</span>Title: ${it.title}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:grep&gt;</span></pre></div><p class="paragraph">或者使用一个正则表达式：
</p><div class="code"><pre><span class="xml-tag">&lt;g:grep in=<span class="xml-quote">"${books.title}"</span> filter=<span class="xml-quote">"~/.*?Groovy.*?/"</span>&gt;</span>
     <span class="xml-tag">&lt;p&gt;</span>Title: ${it}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:grep&gt;</span></pre></div><p class="paragraph">上面的示例同样有趣，因为它使用了GPath.Groovy的GPath等同与XPath语言。实际上<code>books</code>集合是 <code>Book</code>集合的实体。不过，假设每个<code>Book</code>拥有一个<code>title</code>,你可以使用表达式<code>books.title</code>来获取Book titles的list.
</p><h2><a name="6.2.2.4 链接和资源">6.2.2.4 链接和资源</a></h2>GSP还拥有特有的标签来帮助你管理连接到控制器和操作.<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/link.html" class="tags">link</a>标签允许你指定控制器和操作配对的名字，并基于<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL映射</a>来自动完成连接。即使你去改变！一些 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/link.html" class="tags">link</a>的示例如下:
<div class="code"><pre><span class="xml-tag">&lt;g:link action=<span class="xml-quote">"show"</span> id=<span class="xml-quote">"1"</span>&gt;</span>Book 1<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link action=<span class="xml-quote">"show"</span> id=<span class="xml-quote">"${currentBook.id}"</span>&gt;</span>${currentBook.name}<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link controller=<span class="xml-quote">"book"</span>&gt;</span>Book Home<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link controller=<span class="xml-quote">"book"</span> action=<span class="xml-quote">"list"</span>&gt;</span>Book List<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link url=<span class="xml-quote">"[action:'list',controller:'book']"</span>&gt;</span>Book List<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link action=<span class="xml-quote">"list"</span> params=<span class="xml-quote">"[sort:'title',order:'asc',author:currentBook.author]"</span>&gt;</span>
     Book List
<span class="xml-tag">&lt;/g:link&gt;</span></pre></div>
<h2><a name="6.2.2.5 表单和字段">6.2.2.5 表单和字段</a></h2><h4>表单基础</h4>
GSP支持许多不同标签来帮助处理HTML表单和字段，最基础的是<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/form.html" class="tags">form</a>标签，<code>form</code>标签是一个控制器/操作所理解的正规的HTML表单标签版本。 <code>url</code>属性允许你指定映射到哪个控制器和操作：
<div class="code"><pre><span class="xml-tag">&lt;g:form name=<span class="xml-quote">"myForm"</span> url=<span class="xml-quote">"[controller:'book',action:'list']"</span>&gt;</span>...<span class="xml-tag">&lt;/g:form&gt;</span></pre></div><p class="paragraph">我们创建个名为<code>myForm</code>的表单，它被提交到<code>BookController</code>的<code>list</code>操作。除此之外，适用于所有不同的HTML属性。</p><p class="paragraph"></p><h4>表单字段</h4><p class="paragraph">同构造简单的表单一样，GSP支持如下不同字段类型的定制：
</p><ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/textField.html" class="tags">textField</a> - 'text'类型输入字段</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/checkBox.html" class="tags">checkBox</a> - 'checkbox'类型输入字段</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/radio.html" class="tags">radio</a> - 'radio'类型输入字段</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/hiddenField.html" class="tags">hiddenField</a> - 'hidden'类型输入字段</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/select.html" class="tags">select</a> - 处理 HTML 选择框</li>
</ul><p class="paragraph">上面的每一个都允许GSP表达式作为值：
</p><div class="code"><pre><span class="xml-tag">&lt;g:textField name=<span class="xml-quote">"myField"</span> value=<span class="xml-quote">"${myValue}"</span> /&gt;</span></pre></div><p class="paragraph">GSP同样包含上面标签的扩张助手版本，比如<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/radioGroup.html" class="tags">radioGroup</a> (创建一组<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/radio.html" class="tags">radio</a> 标签), <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/localeSelect.html" class="tags">localeSelect</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/currencySelect.html" class="tags">currencySelect</a> 和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/timeZoneSelect.html" class="tags">timeZoneSelect</a> (选择各自的地区区域, 货币 和时间区域).</p><p class="paragraph"></p><h4>多样的提交按钮</h4><p class="paragraph">处理多样的提交按钮这样由来已久的问题，同样可以通过Grails的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/actionSubmit.html" class="tags">actionSubmit</a>标签优雅的处理。它就像一个正规提交，但是，允许你指定一个可选的操作来提交。
</p><div class="code"><pre><span class="xml-tag">&lt;g:actionSubmit value=<span class="xml-quote">"Some update label"</span> action=<span class="xml-quote">"update"</span> /&gt;</span></pre></div>
<h2><a name="6.2.2.6 标签作为方法调用">6.2.2.6 标签作为方法调用</a></h2>GSP标签和其他标签技术一个主要不同在于，来自<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>, <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库" class="guide">标签库</a>或者GSP 视图中的GPS标签可以被当作任意的正规标签或者当作方法被调用.<p class="paragraph"></p><h4>来自GSPs中的标签当作方法调用</h4><p class="paragraph">当作为方法被调用时，标签的返回值被当作String实体直接被写入响应中。因此，示例中的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/createLinkTo.html" class="tags">createLinkTo</a>能等同的看做方法调用：
</p><div class="code"><pre>Static Resource: ${createLinkTo(dir:<span class="xml-quote">"images"</span>, file:<span class="xml-quote">"logo.jpg"</span>)}</pre></div><p class="paragraph">当你必须在一个属性内使用一个标签时是特别有用的。
</p><div class="code"><pre><span class="xml-tag">&lt;img src=<span class="xml-quote">"${createLinkTo(dir:'images', file:'logo.jpg')}"</span> /&gt;</span></pre></div><p class="paragraph">在视图技术中，标签内嵌套标签的特性是不被支持的，这样变得十分混乱，往往使得像Dreamweaver这样WYSWIG的工具产生不利的效果以至于在渲染标签时。
</p><div class="code"><pre><span class="xml-tag">&lt;img src=<span class="xml-quote">"&lt;g:createLinkTo dir="</span>images<span class="xml-quote">" file="</span>logo.jpg<span class="xml-quote">" /&gt;</span>"</span> /&gt;</pre></div><p class="paragraph"></p><h4>来自控制器（Controllers）和标签库的标签作为方法调用</h4><p class="paragraph">你同样可以调用来自控制器和标签库的标签。标签可以不需要内部默认的 <code>g:</code> <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.4 标签命名空间" class="guide">namespace</a>前缀来调用，并返回String结果：
</p><div class="code"><pre>def imageLocation = createLinkTo(dir:<span class="java-quote">"images"</span>, file:<span class="java-quote">"logo.jpg"</span>)</pre></div><p class="paragraph">然而，你同样可以用命名空间前缀来避免命名冲突：
</p><div class="code"><pre>def imageLocation = g.createLinkTo(dir:<span class="java-quote">"images"</span>, file:<span class="java-quote">"logo.jpg"</span>)</pre></div><p class="paragraph">假如你有一个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.4 标签命名空间" class="guide">custom namespace</a>，你可以使用它的前缀来替换（例如，使用<a href="http://grails.org/FCK+editor+plugin" target="blank">FCK Editor plugin</a>）：
</p><div class="code"><pre>def editor = fck.editor()</pre></div><p class="paragraph"></p><p class="paragraph"></p><h2><a name="6.2.3 视图和模板">6.2.3 视图和模板</a></h2>和视图一样，Grails有模板的概念。模板有利于分隔出你的视图在可维护的块中，并与<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.4 使用Sitemesh布局" class="guide">Layouts</a>结合提供一个高度可重用机制来构建视图。<p class="paragraph"></p><h4>模板基础</h4><p class="paragraph">Grails使用在一个视图名字前放置一个下划线来标识为一个模板的规约。例如，你可能有个位于<code>grails-app/views/book/_bookTemplate.gsp</code>的模板处理渲染Books ：
</p><div class="code"><pre><span class="xml-tag">&lt;div class=<span class="xml-quote">"book"</span> id=<span class="xml-quote">"${book?.id}"</span>&gt;</span>
   <span class="xml-tag">&lt;div&gt;</span>Title: ${book?.title}<span class="xml-tag">&lt;/div&gt;</span>
   <span class="xml-tag">&lt;div&gt;</span>Author: ${book?.author?.name}<span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;/div&gt;</span></pre></div><p class="paragraph">为了渲染来自<code>grails-app/views/book</code> 视图中的一个模板，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/render.html" class="tags">render</a>标签：
</p><div class="code"><pre><span class="xml-tag">&lt;g:render template=<span class="xml-quote">"bookTemplate"</span> model=<span class="xml-quote">"[book:myBook]"</span> /&gt;</span></pre></div><p class="paragraph">注意，我们是怎么样使用render标签的<code>model</code>属性来使用传入的一个model。假如，你有多个<code>Book</code>实体，你同样可以使用render标签为每个<code>Book</code>渲染模板
</p><div class="code"><pre><span class="xml-tag">&lt;g:render template=<span class="xml-quote">"bookTemplate"</span> var=<span class="xml-quote">"book"</span> collection=<span class="xml-quote">"${bookList}"</span> /&gt;</span></pre></div><p class="paragraph"></p><h4>共享模板</h4><p class="paragraph">在早先的示例中，我们有一个特定于<code>BookController</code>模板，它的视图位于 <code>grails-app/views/book</code>。然而，你可能想横跨你的应用来共享模板。</p><p class="paragraph">既然这样，你可以把他们放置于grails-app/views视图根目录或者位于这个位置的任何子目录，然后在模板属性在模板名字之前使用一个 <code>/</code>来指明相对模板路径
</p><div class="code"><pre><span class="xml-tag">&lt;g:render template=<span class="xml-quote">"/shared/mySharedTemplate"</span> /&gt;</span></pre></div><p class="paragraph">你也可以使用这个技术从任何视图或控制器（Controllers）来引用任何目录下的模板：
</p><div class="code"><pre><span class="xml-tag">&lt;g:render template=<span class="xml-quote">"/book/bookTemplate"</span> model=<span class="xml-quote">"[book:myBook]"</span> /&gt;</span></pre></div><p class="paragraph"></p><h4>在控制器和标签库中的模板</h4><p class="paragraph">你同样可以使用控制器<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法渲染模板控制器中，它对<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7 Ajax" class="guide">Ajax</a>引用很有用。
</p><div class="code"><pre>def show = {
	de b = Book.get(params.id)
	render(template:<span class="java-quote">"bookTemplate"</span>, model:[book:b])
}</pre></div><p class="paragraph">在控制器中的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法最普通的行为是直接写入响应。假如，你需要获得模板作为一个String的结果作为替代，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/render.html" class="tags">render</a>标签：</p><p class="paragraph"></p><div class="code"><pre>def show = {
	de b = Book.get(params.id)
	<span class="java-object">String</span> content = g.render(template:<span class="java-quote">"bookTemplate"</span>, model:[book:b])
	render content
}</pre></div><p class="paragraph">注意， <code>g.</code> namespace的用法，它告诉Grails我们想使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2.2.6 标签作为方法调用" class="guide">标签作为方法调用</a>来代替<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法。</p><p class="paragraph"></p><h2><a name="6.2.4 使用Sitemesh布局">6.2.4 使用Sitemesh布局</a></h2><h4>创建布局</h4><p class="paragraph">Grails利用了<a href="http://www.opensymphony.com/sitemesh/" target="blank">Sitemesh</a>，一个装饰引擎，来支持视图布局。布局位于<code>grails-app/views/layouts</code>目录中。一个典型的布局如下：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
      <span class="xml-tag">&lt;head&gt;</span>
          <span class="xml-tag">&lt;title&gt;</span><span class="xml-tag">&lt;g:layoutTitle default=<span class="xml-quote">"An example decorator"</span> /&gt;</span><span class="xml-tag">&lt;/title&gt;</span>
          <span class="xml-tag">&lt;g:layoutHead /&gt;</span>
      <span class="xml-tag">&lt;/head&gt;</span>
      <span class="xml-tag">&lt;body onload=<span class="xml-quote">"${pageProperty(name:'body.onload')}"</span>&gt;</span>
            <span class="xml-tag">&lt;div class=<span class="xml-quote">"menu"</span>&gt;</span><span class="xml-comment">&lt;!--my common menu goes here--&gt;</span><span class="xml-tag">&lt;/menu&gt;</span>
                 <span class="xml-tag">&lt;div class=<span class="xml-quote">"body"</span>&gt;</span>
                      <span class="xml-tag">&lt;g:layoutBody /&gt;</span>
                 <span class="xml-tag">&lt;/div&gt;</span>
            <span class="xml-tag">&lt;/div&gt;</span>
      <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">关键的元素是<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/layoutHead.html" class="tags">layoutHead</a>，<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/layoutTitle.html" class="tags">layoutTitle</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/layoutBody.html" class="tags">layoutBody</a>标签的用法，这里是他们所做的：
</p><ul class="star">
<li><code>layoutTitle</code> - 输出目标页面的title</li>
<li><code>layoutHead</code> - 输出目标页面head标签内容</li>
<li><code>layoutBody</code> - 输出目标页面body标签内容</li>
</ul><p class="paragraph">早前的示例也证明了<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/pageProperty.html" class="tags">pageProperty</a>标签能被用去检查和返回目标页面的方向。</p><p class="paragraph"></p><h4>启动布局</h4><p class="paragraph">这里有少许方法来启动启动一个布局。简单的在视图中添加meta标签：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
    <span class="xml-tag">&lt;head&gt;</span>
	    <span class="xml-tag">&lt;title&gt;</span>An Example Page<span class="xml-tag">&lt;/title&gt;</span>
        <span class="xml-tag">&lt;meta name=<span class="xml-quote">"layout"</span> content=<span class="xml-quote">"main"</span>&gt;</span><span class="xml-tag">&lt;/meta&gt;</span>
    <span class="xml-tag">&lt;/head&gt;</span>
    <span class="xml-tag">&lt;body&gt;</span>This is my content!<span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph">在这种情况下，一个名为<code>grails-app/views/layouts/main.gsp</code> 将被用于布局这个页面。假如，我们使用来自早前部分的布局，输出看上去像下列这样：
</p><div class="code"><pre><span class="xml-tag">&lt;html&gt;</span>
      <span class="xml-tag">&lt;head&gt;</span>
          <span class="xml-tag">&lt;title&gt;</span>An Example Page<span class="xml-tag">&lt;/title&gt;</span>
      <span class="xml-tag">&lt;/head&gt;</span>
      <span class="xml-tag">&lt;body onload=<span class="xml-quote">""</span>&gt;</span>
            <span class="xml-tag">&lt;div class=<span class="xml-quote">"menu"</span>&gt;</span><span class="xml-comment">&lt;!--my common menu goes here--&gt;</span><span class="xml-tag">&lt;/menu&gt;</span>
                 <span class="xml-tag">&lt;div class=<span class="xml-quote">"body"</span>&gt;</span>
					This is my content!
                 <span class="xml-tag">&lt;/div&gt;</span>
            <span class="xml-tag">&lt;/div&gt;</span>
      <span class="xml-tag">&lt;/body&gt;</span>
<span class="xml-tag">&lt;/html&gt;</span></pre></div><p class="paragraph"></p><h4>布局规约</h4><p class="paragraph">第二种关联布局的方法是使用"布局规约"，假如你有个这样的控制器:
</p><div class="code"><pre>class BookController {
    def list = {  … }
}</pre></div><p class="paragraph">你可以创建一个名为<code>grails-app/views/layouts/book.gsp</code>的布局，根据规约，它将被应用于<code>BookController</code>的所有视图中。</p><p class="paragraph">换句话说，你可以创建一个名为<code>grails-app/views/layouts/book/list.gsp</code>的布局，它将只被应用于<code>BookController</code>中的<code>list</code>操作，</p><p class="paragraph">如果你同时使用了以上提到的两种布局的话，那当list操作被执行的时候，那么操作将根据优先级的顺序来使用布局。</p><p class="paragraph"></p><h4>内联布局</h4><p class="paragraph">通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/applyLayout.html" class="tags">applyLayout</a>标签Grails同样支持Sitemesh的内联布局概念。<code>applyLayout</code>标签可以被用于应用一个布局到一个模板，URL或者内容的任意部分。事实上，通过"decorating"你的模板允许你更进一步的积木化你的视图结构</p><p class="paragraph">一些使用示例如下：
</p><div class="code"><pre><span class="xml-tag">&lt;g:applyLayout name=<span class="xml-quote">"myLayout"</span> template=<span class="xml-quote">"bookTemplate"</span> collection=<span class="xml-quote">"${books}"</span> /&gt;</span><p class="paragraph"><span class="xml-tag">&lt;g:applyLayout name=<span class="xml-quote">"myLayout"</span> url=<span class="xml-quote">"http://www.google.com"</span> /&gt;</span></p><p class="paragraph"><span class="xml-tag">&lt;g:applyLayout name=<span class="xml-quote">"myLayout"</span>&gt;</span>
The content to apply a layout to
<span class="xml-tag">&lt;/g:applyLayout&gt;</span></p></pre></div><p class="paragraph"></p><h2><a name="6.3 标签库">6.3 标签库</a></h2>像<a href="http://java.sun.com/products/jsp/" target="blank">Java Server Pages(JSP)</a> 一样，GSP支持定制tag库的概念。不同于JSP，Grails标签库机制是简单的，优雅的，在运行时完全可重载的。<p class="paragraph">创建一个标签库是相当简单的，创建一个以规约<code>TagLib</code>结尾的一个Groovy类，并把它放置于<code>grails-app/taglib</code>目录里。
</p><div class="code"><pre>class SimpleTagLib {<p class="paragraph">}</p></pre></div><p class="paragraph">现在，为了创建一个标签，简单的创建属性并赋值一个带有两个参数的代码块：标签属性和主体内容：
</p><div class="code"><pre>class SimpleTagLib {
	def simple = { attrs, body -&gt;<p class="paragraph">    }
}</p></pre></div><p class="paragraph"><code>attrs</code>属性是一个简单的标签属性map，同时<code>body</code>是另一可调用的代码块，它返回主体内容：
</p><div class="code"><pre>class SimpleTagLib {
	def emoticon = { attrs, body -&gt;
	   out &lt;&lt; body() &lt;&lt; attrs.happy == '<span class="java-keyword">true</span>' ? <span class="java-quote">" :-)"</span> : <span class="java-quote">" :-("</span>	
    }
}</pre></div><p class="paragraph">正如以上所显示的，这里有个隐式的<code>out</code>变量，它引用了输出<code>Writer</code>，可以用来附加内容到响应中。然后，你可以在你的GSP内简单的引用这个标签而不需要任何导入。
</p><div class="code"><pre><span class="xml-tag">&lt;g:emoticon happy=<span class="xml-quote">"true"</span>&gt;</span>Hi John<span class="xml-tag">&lt;/g:emoticon&gt;</span></pre></div>
<h2><a name="6.3.1 简单标签">6.3.1 简单标签</a></h2>作为演示，早先的示例只不过是写了个没有主体只有输出内容的简单标签。另一个示例是一个<code>dateFormat</code>样式标签：
<div class="code"><pre>def dateFormat = { attrs, body -&gt;
	out &lt;&lt; <span class="java-keyword">new</span> java.text.SimpleDateFormat(attrs.format).format(attrs.date)
}</pre></div><p class="paragraph">上面使用了Java的 <code>SimpleDateFormat</code>类来格式化一个date，然后把它写入响应。随后，这个标签能像下列这样在GSP中使用：
</p><div class="code"><pre><span class="xml-tag">&lt;g:dateFormat format=<span class="xml-quote">"dd-MM-yyyy"</span> date=<span class="xml-quote">"${new Date()}"</span> /&gt;</span></pre></div><p class="paragraph">有时。你需要用简单的标签把HTML标签（mark-up）写入到响应中。一个方法是直接嵌套内容：
</p><div class="code"><pre>def formatBook = { attrs, body -&gt;
    out &lt;&lt; <span class="java-quote">"&lt;div id="${attrs.book.id}"&gt;"</span>	
    out &lt;&lt; <span class="java-quote">"Title : ${attrs.book.title}"</span>	
	out &lt;&lt; <span class="java-quote">"&lt;/div&gt;"</span>
}</pre></div><p class="paragraph">虽然，这个方法可能很诱人，但不是非常的简洁。一个更好的方法将是复用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/render.html" class="tags">render</a>标签：
</p><div class="code"><pre>def formatBook = { attrs, body -&gt;
    out &lt;&lt; render(template:<span class="java-quote">"bookTemplate"</span>, model:[book:attrs.book])	
}</pre></div><p class="paragraph">然后，这个单独的GSP模板做了实际的渲染工作。
</p><h2><a name="6.3.2 逻辑标签">6.3.2 逻辑标签</a></h2>一旦一组条件满足，你同样可以在标签的主体中创建仅仅用来输出的逻辑标签。一个这样的例子可能是一组安全标签：
<div class="code"><pre>def isAdmin = { attrs, body -&gt;
     def user = attrs['user']
     <span class="java-keyword">if</span>(user != <span class="java-keyword">null</span> &amp;&amp; checkUserPrivs(user)) {
           out &lt;&lt; body()
     }
}</pre></div><p class="paragraph">上面的标签检查用户是否为管理人员，如果他/她有正确设置的访问权限只输出主体内容： 
</p><div class="code"><pre><span class="xml-tag">&lt;g:isAdmin user=<span class="xml-quote">"${myUser}"</span>&gt;</span>
    // some restricted content
<span class="xml-tag">&lt;/g:isAdmin&gt;</span></pre></div><p class="paragraph">
</p><h2><a name="6.3.3 迭代标签">6.3.3 迭代标签</a></h2>迭代标签同样普通，因为你可以多次调用主体
<div class="code"><pre>def repeat = { attrs, body -&gt;
    attrs.times?.toInteger().times { num -&gt;
        out &lt;&lt; body(num)
    }
}</pre></div><p class="paragraph">在这个示例中，我们检查一个<code>times</code>属性，假如存在，把它转换为一个数字，然后使用Groovy的<code>times</code>方法。
</p><div class="code"><pre><span class="xml-tag">&lt;g:repeat times=<span class="xml-quote">"3"</span>&gt;</span>
<span class="xml-tag">&lt;p&gt;</span>Repeat this 3 times! Current repeat = ${it}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:repeat&gt;</span></pre></div><p class="paragraph">注意，我们是怎么样在这个示例中使用隐式的 <code>it</code>变量来引用当前的数字。这个过程是因为在迭代内部我们调用了传递进入当前值的主体：
</p><div class="code"><pre>out &lt;&lt; body(num)</pre></div><p class="paragraph">那个值然后被作为默认的 <code>it</code>变量传递给标签，然而，假如你有嵌套标签便会导致冲突，因此，你将可能替换主体使用的变量名：</p><p class="paragraph"></p><div class="code"><pre>def repeat = { attrs, body -&gt;
	def <span class="java-keyword">var</span> = attrs.<span class="java-keyword">var</span> ? attrs.<span class="java-keyword">var</span> : <span class="java-quote">"num"</span>
    attrs.times?.toInteger().times { num -&gt;
        out &lt;&lt; body((<span class="java-keyword">var</span>):num)
    }
}</pre></div><p class="paragraph">这里，我们检查是否存在一个<code>var</code>属性，如果存在的话，将其作为body调用的参数：
</p><div class="code"><pre>out &lt;&lt; body((<span class="java-keyword">var</span>):num)</pre></div><p class="paragraph"></p><blockquote class="note">
注意，变量名围绕的圆括号的使用。假如你省略，Groovy会认为你使用了一个String关键字，而不是引用这个变量它自己。
</blockquote><p class="paragraph">现在，我们可以改变这个标签的使用方法，如下：
</p><div class="code"><pre><span class="xml-tag">&lt;g:repeat times=<span class="xml-quote">"3"</span> var=<span class="xml-quote">"j"</span>&gt;</span>
<span class="xml-tag">&lt;p&gt;</span>Repeat this 3 times! Current repeat = ${j}<span class="xml-tag">&lt;/p&gt;</span>
<span class="xml-tag">&lt;/g:repeat&gt;</span></pre></div><p class="paragraph">注意，我们是怎么样使用 <code>var</code>属性来定义<code>j</code>德尔变量名，随后，我们可能在标签主体类引用这个变量。
</p><h2><a name="6.3.4 标签命名空间">6.3.4 标签命名空间</a></h2>默认情况下，标签被添加到默认的Grails命名空间，并在GSP页面中和 <code>g:</code>前缀一起使用。然而，你可以指定一个不同的命名空间，通过在你的<code>TagLib</code>类中添加一个静态属性：
<div class="code"><pre>class SimpleTagLib {
    <span class="java-keyword">static</span> namespace = <span class="java-quote">"my"</span><p class="paragraph">    def example = { attrs -&gt;
        …
    }
}</p></pre></div><p class="paragraph">这里，我们指定了一个命名空间<code>my</code>，因此，稍后在GPS页面中标签库中的标签引用会像这样：
</p><div class="code"><pre><span class="xml-tag">&lt;my:example name=<span class="xml-quote">"..."</span> /&gt;</span></pre></div><p class="paragraph">前缀和静态的命名空间属性值一样。命名空间对于插件特别有用。</p><p class="paragraph">命名空间内的标签可以作为方法调用，使用命名空间作为前缀来执行方法调用：
</p><div class="code"><pre>out &lt;&lt; my.example(name:<span class="java-quote">"foo"</span>)</pre></div><p class="paragraph">可用于GSP，控制器或者标签库。
</p><h2><a name="6.4 URL映射">6.4 URL映射</a></h2>到目前为止，贯穿整个文档用于URLs的规约默认为<code>/controller/action/id</code>。然而，这个规约不是硬性的写入Grails中，实际上，它是通过一个位于<code>grails-app/conf/UrlMappings.groovy</code>的URL映射类所控制。<p class="paragraph"><code>UrlMappings</code>类包含一个名为<code>mappings</code>单一属性，并被赋予一个代码块：
</p><div class="code"><pre>class UrlMappings {
    <span class="java-keyword">static</span> mappings = {
    }	
}</pre></div><p class="paragraph"></p><h2><a name="6.4.1 映射到控制器和操作">6.4.1 映射到控制器和操作</a></h2>为了创建简单的映射，只需简单的使用相对URL作为方法名，并指定控制器和操作的命名参数来映射：
<div class="code"><pre><span class="java-quote">"/product"</span>(controller:<span class="java-quote">"product"</span>, action:<span class="java-quote">"list"</span>)</pre></div><p class="paragraph">在这种情况下，我们建立URL <code>/product</code>到<code>ProductController</code>的<code>list</code>操作的映射。你当然可以省略操作定义，来映射控制器默认的操作：
</p><div class="code"><pre><span class="java-quote">"/product"</span>(controller:<span class="java-quote">"product"</span>)</pre></div><p class="paragraph">一个可选的语法是把在块中被赋值的控制器和操作传递给方法：
</p><div class="code"><pre><span class="java-quote">"/product"</span> {
	controller = <span class="java-quote">"product"</span>
	action = <span class="java-quote">"list"</span>
}</pre></div><p class="paragraph">你使用哪一个句法很大程度上依赖于个人偏好。</p><p class="paragraph">
</p><h2><a name="6.4.2 嵌入式变量">6.4.2 嵌入式变量</a></h2><h4>简单变量</h4><p class="paragraph">早前的部分说明，怎样使用具体的"标记"来映射普通的URLs。在URL映射里讲过，标记是在每个斜线字符之间的顺序字符。一个具体的标记就像<code>/product</code>这样被良好定义。然而，很多情况下，标记的值直到运行时才知道是什么。在这种情况下，你可以在URL中使用变量占位符，例如：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
  <span class="java-quote">"/product/$id"</span>(controller:<span class="java-quote">"product"</span>)
}</pre></div><p class="paragraph">在这种情况下，通过嵌入一个$id变量作为第2个标记，Grails将自动映射第2个标记到一个名为<code>id</code>的参数(通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象得到).例如给定的URL<code>/product/MacBook</code>，下面的代码将渲染"MacBook"到响应中：
</p><div class="code"><pre>class ProductController {
     def index = { render params.id }
}</pre></div><p class="paragraph">
当然你可以构建更多复杂的映射示例。例如传统的blog URL格式将被映射成下面这样：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/$blog/$year/$month/$day/$id"</span>(controller:<span class="java-quote">"blog"</span>, action:<span class="java-quote">"show"</span>)
}</pre></div><p class="paragraph">上面的映射允许你这样做：
</p><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry</pre></div><p class="paragraph">在URL里单独的标记将再次被映射到带有<code>year</code>, <code>month</code>, <code>day</code>, <code>id</code>等等可用值的params对象中。</p><p class="paragraph"></p><h4>动态控制器和操作名</h4><p class="paragraph">变量同样可以被用于动态构造控制器和操作名。实际上，默认的Grails URL映射使用这样的技术：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
    <span class="java-quote">"/$controller/$action?/$id?"</span>()
}</pre></div><p class="paragraph">这里，控制器名，操作名和id名，隐式的从嵌入在URL中的<code>controller</code>, <code>action</code> 和 <code>id</code>中获得。</p><p class="paragraph"></p><h4>可选的变量</h4><p class="paragraph">默认映射另一个特性就是能够在一个变量的末尾附加一个<code>?</code>，使它成为一个可选的标记。这个技术更进一步的示例能够运用于blog URL映射，使它具有更灵活性的连接。
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java-quote">"blog"</span>, action:<span class="java-quote">"show"</span>)
}</pre></div><p class="paragraph">下列URLs的所有映射将与放置于<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象中的唯一关联的参数匹配：
</p><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry
/graemerocher/2007/01/10
/graemerocher/2007/01
/graemerocher/2007
/graemerocher</pre></div><p class="paragraph"></p><h4>任意变量</h4><p class="paragraph">你同样可以传递来自于URL映射的任意参数给控制器，把他们设置在块内传递给这个映射：
</p><div class="code"><pre><span class="java-quote">"/holiday/win"</span> {
     id = <span class="java-quote">"Marrakech"</span>
     year = 2007
}</pre></div><p class="paragraph">在这个<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象得到的这个变量将被传递给这个控制器。</p><p class="paragraph"></p><h4>动态解析变量</h4><p class="paragraph">硬编码任意变量是有用的，但是，有时你需要基于运行时因素来计算变量名。这个同样可能通过给变量名分配一个块。
</p><div class="code"><pre><span class="java-quote">"/holiday/win"</span> {
     id = { params.id } 
     isEligible = { session.user != <span class="java-keyword">null</span> } // must be logged in
}</pre></div><p class="paragraph">上述情况，当URL实际被匹配，块中的代码将被解析，因此可以被用于结合所有种类的逻辑处理。
</p><h2><a name="6.4.3 映射到视图">6.4.3 映射到视图</a></h2>如果你想决定一个URL一个view,而无需涉及一个控制器或者操作，你也可以这样做。例如，如果你想映射根URL <code>/</code>到一个位于<code>grails-app/views/index.gsp</code>的GSP，你可以这样使用：
<div class="code"><pre><span class="java-keyword">static</span> mappings = {
      <span class="java-quote">"/"</span>(view:<span class="java-quote">"/index"</span>)  // map the root URL
}</pre></div><p class="paragraph">换句话说，假如你需要一个具体给定的控制器（Controller）中的一个视图，你可以这样使用：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/help"</span>(controller:<span class="java-quote">"site"</span>,view:<span class="java-quote">"help"</span>) // to a view <span class="java-keyword">for</span> a controller
}</pre></div>dao
<h2><a name="6.4.4 映射到响应代码">6.4.4 映射到响应代码</a></h2>Grails同样允许你映射一个HTTP响应代码到控制器，操作或视图。所有你需要做的是使用一个方法名来匹配你所感兴趣的响应代码：
<div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"500"</span>(controller:<span class="java-quote">"errors"</span>, action:<span class="java-quote">"serverError"</span>)
   <span class="java-quote">"404"</span>(controller:<span class="java-quote">"errors"</span>, action:<span class="java-quote">"notFound"</span>)
   <span class="java-quote">"403"</span>(controller:<span class="java-quote">"errors"</span>, action:<span class="java-quote">"forbidden"</span>)
}</pre></div><p class="paragraph">或者换句话说，假如你只不过想提供定制的错误页面：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"500"</span>(view:<span class="java-quote">"/errors/serverError"</span>)
   <span class="java-quote">"404"</span>(view:<span class="java-quote">"/errors/notFound"</span>)
   <span class="java-quote">"403"</span>(view:<span class="java-quote">"/errors/forbidden"</span>)
}</pre></div>
<h2><a name="6.4.5 映射到HTTP方法">6.4.5 映射到HTTP方法</a></h2>URL映射同样可以配置成基于HTTP 方法 (GET, POST, PUT or DELETE)的map。这个对于RESTful APIs和基于HTTP方法的约束映射是非常有用的。<p class="paragraph">作为一个示例，下面的映射为<code>BookController</code>URL提供一个RESTful API URL映射：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/product/$id"</span>(controller:<span class="java-quote">"product"</span>){
       action = [GET:<span class="java-quote">"show"</span>, PUT:<span class="java-quote">"update"</span>, DELETE:<span class="java-quote">"delete"</span>, POST:<span class="java-quote">"save"</span>]
   }	
}</pre></div>
<h2><a name="6.4.6 映射通配符">6.4.6 映射通配符</a></h2>Grails的URL映射机制同样支持通配符映射。例如，考虑下面的映射：
<div class="code"><pre><span class="java-keyword">static</span> mappings = {
	<span class="java-quote">"/images/*.jpg"</span>(controllers:<span class="java-quote">"image"</span>)
}</pre></div><p class="paragraph">这个映射将匹配所有images路径下像<code>/image/logo.jpg</code>这样的jpg。当然你可以通过一个变量来达到同样的效果：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
	<span class="java-quote">"/images/$name.jpg"</span>(controllers:<span class="java-quote">"image"</span>)
}</pre></div><p class="paragraph">然而，你可以使用双通配符来匹配多于一个层次之外的：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
	<span class="java-quote">"/images/**.jpg"</span>(controllers:<span class="java-quote">"image"</span>)
}</pre></div><p class="paragraph">这样的话，这个映射将不但匹配<code>/image/logo.jpg</code>而且匹配 <code>/image/other/logo.jpg</code>。更好的是你可以使用一个双通配符变量：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
	// will match /image/logo.jpg and /image/other/logo.jpg 
	<span class="java-quote">"/images/$name**.jpg"</span>(controllers:<span class="java-quote">"image"</span>)
}</pre></div><p class="paragraph">这样的话，它将储存路径，从params对象获得命名参数里的通配符：
</p><div class="code"><pre>def name = params.name
println name // prints <span class="java-quote">"logo.jpg"</span> or <span class="java-quote">"other/logo.jpg"</span></pre></div><p class="paragraph"></p><p class="paragraph">
</p><h2><a name="6.4.7 自动重写链接">6.4.7 自动重写链接</a></h2>URL映射另一个重要的特性是自动定制<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/link.html" class="tags">link</a>标签的行为。以便改变这个映射而不需要改变所有的连接.<p class="paragraph">通过一个URL重写技术做到这点，从URL映射反转连接设计。
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java-quote">"blog"</span>, action:<span class="java-quote">"show"</span>)
}</pre></div><p class="paragraph">如果，你像下列一样使用连接标签：
</p><div class="code"><pre><span class="xml-tag">&lt;g:link controller=<span class="xml-quote">"blog"</span> action=<span class="xml-quote">"show"</span> params=<span class="xml-quote">"[blog:'fred', year:2007]"</span>&gt;</span>My Blog<span class="xml-tag">&lt;/g:link&gt;</span>
<span class="xml-tag">&lt;g:link controller=<span class="xml-quote">"blog"</span> action=<span class="xml-quote">"show"</span> params=<span class="xml-quote">"[blog:'fred', year:2007, month:10]"</span>&gt;</span>My Blog - October 2007 Posts<span class="xml-tag">&lt;/g:link&gt;</span></pre></div><p class="paragraph">Grails将自动重写URL通过适当的格式：
</p><div class="code"><pre><span class="xml-tag">&lt;a href=<span class="xml-quote">"/fred/2007"</span>&gt;</span>My Blog<span class="xml-tag">&lt;/a&gt;</span>
<span class="xml-tag">&lt;a href=<span class="xml-quote">"/fred/2007/10"</span>&gt;</span>My Blog - October 2007 Posts<span class="xml-tag">&lt;/a&gt;</span></pre></div>
<h2><a name="6.4.8 应用约束">6.4.8 应用约束</a></h2>URL映射同样支持Grails统一<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">验证约束</a>机制，它允许你更进一步"约束"一个URL是怎么被匹配的。例如，如果我们回到早前的blog示例代码，这个映射当前看上去会像这样：
<div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/$blog/$year?/$month?/$day?/$id?"</span>(controller:<span class="java-quote">"blog"</span>, action:<span class="java-quote">"show"</span>)
}</pre></div><p class="paragraph">这寻去URLs像这样：
</p><div class="code"><pre>/graemerocher/2007/01/10/my_funky_blog_entry</pre></div><p class="paragraph">不过，它也允许这样：
</p><div class="code"><pre>/graemerocher/not_a_year/not_a_month/not_a_day/my_funky_blog_entry</pre></div><p class="paragraph">当它强迫你在控制器代码中做一些聪明的语法分析时会有问题。幸运的是，URL映射能进一步的约束验证URL标记：
</p><div class="code"><pre><span class="java-quote">"/$blog/$year?/$month?/$day?/$id?"</span> {
     controller = <span class="java-quote">"blog"</span>
     action = <span class="java-quote">"show"</span>
     constraints {
          year(matches:/d{4}/)
          month(matches:/d{2}/)
          day(matches:/d{2}/)
     }
}</pre></div><p class="paragraph">在这种情况下，约束能确保 <code>year</code>, <code>month</code> 和 <code>day</code>参数匹配一个具体有效的模式，从而在稍后来减轻你的负担。
</p><h2><a name="6.5 Web Flow">6.5 Web Flow</a></h2><h4>概述</h4><p class="paragraph">Grails构建在<a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring Web Flow</a> 项目之上来支持创建web flow。一个web flow是一个会话，它横跨多个请求，并把状态保留在flow范围内。一个web flow同样定义了开始和结束状态。</p><p class="paragraph">Web Flow不需要一个HTTP session,作为另外一种选择，他们将状态存储在一种连续的形态中，然后通过Grails来回传递的request参数中的执行流中的key进行还原。这相比其他使用HttpSession来保存状态的应用来说更具有可扩展性，尤其是在内存和集群方面。</p><p class="paragraph">Web flow就是一个基础而高级的状态机，它管理这从一个状态到下一状态的“流”。既然是状态管理，你就勿需再关心用户在一个多步骤的流程中已经进入那个操作了，因为Web Flow已经帮你管理了，因此Web Flow在处理象网上购物、宾馆预定及任何多页面的工作流的应用具有出乎意料的简单。</p><p class="paragraph"></p><h4>创建流</h4><p class="paragraph">创建一个流只需简单的创建一个常规的Grails控制器，然后添加一个以规约<code>Flow</code>结尾的操作。例如：
</p><div class="code"><pre>class BookController {
   def index = {
      redirect(action:<span class="java-quote">"shoppingCart"</span>)
   }
   def shoppingCartFlow = {
             ..
   }
}</pre></div><p class="paragraph">注意，当重定向或引用流时，可以把它看做一个操作而省略掉<code>Flow</code>前缀。换句话说，上面流的操作名为<code>shoppingCart</code>.
</p><h2><a name="6.5.1 开始和结束状态">6.5.1 开始和结束状态</a></h2>如前所述，一个流定义了开始和结束状态。一个开始状态是当一个用户第一次启动一个会话（或流）时开始。Grails的开始流是第一个需要一个块的方法调用。例如：<p class="paragraph"></p><div class="code"><pre>class BookController {
   …
   def shoppingCartFlow = {
       showCart {
           on(<span class="java-quote">"checkout"</span>).to <span class="java-quote">"enterPersonalDetails"</span>           
           on(<span class="java-quote">"continueShopping"</span>).to <span class="java-quote">"displayCatalogue"</span>
       }
       …
       displayCatalogue {
            redirect(controller:<span class="java-quote">"catalogue"</span>, action:<span class="java-quote">"show"</span>)
       }
       displayInvoice()
   }
}</pre></div><p class="paragraph">这里，<code>showCart</code>节点是这个流的开始状态。因为这个showCart状态没有定义一个操作或重定向，它被认为是一个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.2 操作状态和视图状态" class="guide">视图状态</a>。通过规约，引用<code>grails-app/views/book/shoppingCart/showCart.gsp</code>视图。</p><p class="paragraph">注意，这不像正规的控制器的操作，这个视图被存储在和它流的名字匹配的目录<code>grails-app/views/book/shoppingCart</code>中。</p><p class="paragraph"><code>shoppingCart</code>流同样可能拥有两个结束状态。第一个是<code>displayCatalogue</code>，执行一种外部重定向到另一个控制器和行动，从而结束流。第二个是<code>displayInvoice</code>是一个最终状态，因为它已经没有根本没有任何事件了，简单的渲染一个名为<code>grails-app/views/book/shoppingCart/displayInvoice.gsp</code>的视图，并在同一时间终止流。</p><p class="paragraph">一旦一个流结束，它可能只是从开始状态重新开始，在这种情况下的<code>showCart</code>不会来自任何其他状态。
</p><h2><a name="6.5.2 操作状态和视图状态">6.5.2 操作状态和视图状态</a></h2><h4>视图状态</h4><p class="paragraph">一种视图状态没有定义 <code>action</code> 或 <code>redirect</code>。因此，下面是一个视图状态的示例：
</p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>).to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">它将默认查找一个名为<code>grails-app/views/book/shoppingCart/enterPersonalDetails.gsp</code>的视图。注意，<code>enterPersonalDetails</code>定义了两个事件：<code>submit</code> 和 <code>return</code>.视图负责触发<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.3 流执行事件" class="guide">triggering</a>这些事件。假如你想改变视图的渲染，你可以使用render方法来完成：
</p><div class="code"><pre>enterPersonalDetails {
   render(view:<span class="java-quote">"enterDetailsView"</span>)
   on(<span class="java-quote">"submit"</span>).to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">现在，它将查找<code>grails-app/views/book/shoppingCart/enterDetailsView.gsp</code>。假如你想使用共享的视图，视图参数以/ 开头：
</p><div class="code"><pre>enterPersonalDetails {
   render(view:<span class="java-quote">"/shared/enterDetailsView"</span>)
   on(<span class="java-quote">"submit"</span>).to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">现在它将查找 <code>grails-app/views/shared/enterDetailsView.gsp</code></p><p class="paragraph"></p><h4>操作状态</h4><p class="paragraph">一个操作状态是执行代码却不渲染任何视图的这样一个状态：。操作结果被用于支配流的切换。创建一个操作状态，你需要定义一个被执行的操作：
</p><div class="code"><pre>listBooks {
   action { 
	  [ bookList:Book.list() ]
   }
   on(<span class="java-quote">"success"</span>).to <span class="java-quote">"showCatalogue"</span>
   on(Exception).to <span class="java-quote">"handleError"</span>
}</pre></div><p class="paragraph">正如你所看到的，一个操作看上去非常类似于一个控制器的操作，实际上，假如你需要你可以重用控制器操作的。假如这个操作没有错误成功返回，<code>success</code>事件将被触发。这样的话，我们返回一个map,它被到做"model"看待，并自动放置于<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.4 流的作用域" class="guide">flow 范围</a>.</p><p class="paragraph">另外，在上面的示例中同样使用了一个异常处理在这行上处理错误：
</p><div class="code"><pre>on(Exception).to <span class="java-quote">"handleError"</span></pre></div><p class="paragraph">当错误发生的情况下，它将使流切换到一个静态调用<code>handleError</code>.</p><p class="paragraph">你可以写更复杂的操作与流请求上下文相互作用：
</p><div class="code"><pre>processPurchaseOrder  {
     action {
         def a =  flow.address
         def p = flow.person
         def pd = flow.paymentDetails
         def cartItems = flow.cartItems
         flow.clear()<p class="paragraph">         def o = <span class="java-keyword">new</span> Order(person:p, shippingAddress:a, paymentDetails:pd)
         o.invoiceNumber = <span class="java-keyword">new</span> Random().nextInt(9999999)
         cartItems.each { o.addToItems(it) }
         o.save()
         [order:o]
     }
     on(<span class="java-quote">"error"</span>).to <span class="java-quote">"confirmPurchase"</span>
     on(Exception).to <span class="java-quote">"confirmPurchase"</span>
     on(<span class="java-quote">"success"</span>).to <span class="java-quote">"displayInvoice"</span>
}</p></pre></div><p class="paragraph">这里，一个更复杂的操作收集所有的来自流范围积累的数据，并创建一个<code>Order</code>对象。然后，把Order作为模型返回。在这里值得注意的重要事情是与请求上下文和 "flow scope"的相互作用。</p><p class="paragraph"></p><h4>切换操作</h4><p class="paragraph">其他格式的操作被称之为切换操作。切换操作,一旦一个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.3 流执行事件" class="guide">事件</a>被触发，切换操作优先于状态切换被直接执行。普通的切换操作如下：
</p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>) {
       log.trace <span class="java-quote">"Going to enter shipping"</span>	
   }.to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">注意，我们是怎样传递一个代码块给<code>submit</code>事件，只是简单的记录这个切换。切换状态对于<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.5 数据绑定和验证" class="guide">数据绑定和验证</a>是非常有用的，将在后面部分涵盖。</p><p class="paragraph"></p><h2><a name="6.5.3 流执行事件">6.5.3 流执行事件</a></h2>为了执行流从一个状态到下一个状态的切换，你需要一些方法来触发一个事件，指出流下一步该做什么。事件的触发可以来自于任何视图状态和操作状态。<p class="paragraph"></p><h4>来自于一个视图状态的触发事件</h4><p class="paragraph">正如之前所讨论的，在早前代码列表内流的开始状态可能处理两个事件。一个<code>checkout</code> 和一个 <code>continueShopping</code> 事件:
</p><div class="code"><pre>def shoppingCartFlow = {
    showCart {
        on(<span class="java-quote">"checkout"</span>).to <span class="java-quote">"enterPersonalDetails"</span>           
        on(<span class="java-quote">"continueShopping"</span>).to <span class="java-quote">"displayCatalogue"</span>
    }
    …
}</pre></div><p class="paragraph">一旦这个<code>showCart</code>事件是一个视图状态，它将渲染<code>grails-app/book/shoppingCart/showCart.gsp</code>视图.在这个视图内你需要有触发流执行的组件。
</p><div class="code"><pre><span class="xml-tag">&lt;g:form action=<span class="xml-quote">"shoppingCart"</span>&gt;</span>
    <span class="xml-tag">&lt;g:submitButton name=<span class="xml-quote">"continueShopping"</span> value=<span class="xml-quote">"Continue Shopping"</span>&gt;</span><span class="xml-tag">&lt;/g:submitButton&gt;</span>
    <span class="xml-tag">&lt;g:submitButton name=<span class="xml-quote">"checkout"</span> value=<span class="xml-quote">"Checkout"</span>&gt;</span><span class="xml-tag">&lt;/g:submitButton&gt;</span>
<span class="xml-tag">&lt;/g:form&gt;</span></pre></div><p class="paragraph">这个表格必须提交返回<code>shoppingCart</code>流。每个<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/submitButton.html" class="tags">submitButton</a>标签的name属性标示哪个事件将被触发。假如，你没有表格，你同样可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/link.html" class="tags">link</a> 标签来触发一个事件，如下：
</p><div class="code"><pre><span class="xml-tag">&lt;g:link action=<span class="xml-quote">"shoppingCart"</span> event=<span class="xml-quote">"checkout"</span> /&gt;</span></pre></div><p class="paragraph"></p><h4>来自于一个操作的触发事件</h4><p class="paragraph">为了触发来自于一个操作的一个事件，你需要调用一个方法。例如，这里内置的<code>error()</code> 和 <code>success()</code> 方法。下面的示例在切换操作中验证失败后触发<code>error()</code>事件。
</p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>) {
         def p = <span class="java-keyword">new</span> Person(params)
         flow.person = p
         <span class="java-keyword">if</span>(!p.validate())<span class="java-keyword">return</span> error()
   }.to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">在这种情况下，因为错误，切换操作将使流回到 <code>enterPersonalDetails</code>状态。</p><p class="paragraph">有了一种操作状态，你也能触发事件来重定向流:
</p><div class="code"><pre>shippingNeeded {
   action {
       <span class="java-keyword">if</span>(params.shippingRequired) yes()
       <span class="java-keyword">else</span> no()
   }
   on(<span class="java-quote">"yes"</span>).to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"no"</span>).to <span class="java-quote">"enterPayment"</span>
}</pre></div><p class="paragraph"></p><h2><a name="6.5.4 流的作用域">6.5.4 流的作用域</a></h2><h4>作用域基础</h4><p class="paragraph">在以前的示例中，你可能会注意到我们在“流作用域（flow scope）”中已经使用了一个特殊的 <code>flow</code>来存储对象，在Grails中共有5种不同的作用域可供你使用：
</p><ul class="star">
<li><code>request</code> - 仅在当前的请求中存储对象</li>
<li><code>flash</code> - 仅在当前和下一请求中存储对象</li>
<li><code>flow</code> - 在工作流中存储对象，当流到达结束状态，移出这些对象</li>
<li><code>conversation</code> - 在会谈（conversation）中存储对象，包括根工作流和其下的子工作流</li>
<li><code>session</code> - 在用户会话（session）中存储对象</li>
</ul><p class="paragraph"></p><blockquote class="note">
Grails的service类可以自动的定位web flow的作用域，详细请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8. 服务层" class="guide">Services</a>
</blockquote><p class="paragraph">此外从一个action中返回的模型映射（model map）将会自动设置成flow范围，比如在一个转换（transition）的操作中，你可以象下面这样使用<code>flow</code>作用域</p><p class="paragraph"></p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>) {
         [person:<span class="java-keyword">new</span> Person(params)]
   }.to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">要知道每一个状态总是创建一个新的请求，因此保存在request作用域中的对象在其随后的视图状态中不再有效，要想在状态之间传递对象，需要使用除了request之外的其他作用域。此外还有注意，Web Flow将：
</p><ol>
<li>在状态转换的时候，会将对象从flash作用域移动到request作用域</li>
<li>在渲染以前，将会合并flow和conversation作用域的对象到视图模型中（因此你不需要在视图中引用这些对象的时候，再包含一个作用域前缀了）</li>
</ol><p class="paragraph"></p><h4>流的作用域和序列化</h4><p class="paragraph">当你将对象放到 <code>flash</code>, <code>flow</code> 或者 <code>conversation</code>作用域中的时候，要确保对象已经实现了 <code>java.io.Serializable</code>接口，否则将会报错。这在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">domain classes</a>尤为显著，因为领域类通常在视图中渲染的时候被放到相应的作用域中，比如下面的领域类示例：</p><p class="paragraph"></p><div class="code"><pre>class Book {
	<span class="java-object">String</span> title
}</pre></div><p class="paragraph">为了能够让<code>Book</code>类的实例可以放到flow作用域中，你需要修改如下：</p><p class="paragraph"></p><div class="code"><pre>class Book <span class="java-keyword">implements</span> Serializable {
	<span class="java-object">String</span> title
}</pre></div><p class="paragraph">这也会影响到领域类中的关联和闭包，看下面示例：</p><p class="paragraph"></p><div class="code"><pre>class Book <span class="java-keyword">implements</span> Serializable {
	<span class="java-object">String</span> title
	Author author
}</pre></div><p class="paragraph">此处如果<code>Author</code>关联没有实现<code>Serializable</code>，你同样也会得到一个错误。此外在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5.5.1 事件和自动实现时间戳" class="guide">GORM事件</a>中使用的闭包比如 <code>onLoad</code>, <code>onSave</code>等也会受到影响，下例的领域类如果放到flow作用域中，将会产生一个错误。</p><p class="paragraph"></p><div class="code"><pre>class Book <span class="java-keyword">implements</span> Serializable {
	<span class="java-object">String</span> title
	def onLoad = {
		println <span class="java-quote">"I'm loading"</span>
	}
}</pre></div><p class="paragraph">这是因为<code>onLoad</code>事件中的代码块必能被序列化，要想避免这种错误，需要将所有的事件声明为<code>transient</code>:</p><p class="paragraph"></p><div class="code"><pre>class Book <span class="java-keyword">implements</span> Serializable {
	<span class="java-object">String</span> title
	<span class="java-keyword">transient</span> onLoad = {
		println <span class="java-quote">"I'm loading"</span>
	}
}</pre></div>
<h2><a name="6.5.5 数据绑定和验证">6.5.5 数据绑定和验证</a></h2>在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5.1 开始和结束状态" class="guide">开始和结束状态</a>部分，开始状态的第一个示例触发一个切换到<code>enterPersonalDetails</code>状态。这个状态渲染一个视图，并等待用户键入请求信息：<p class="paragraph"></p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>).to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">一个视图包含一个带有两个提交按钮的表格，每个都触发提交事件或返回事件：
</p><div class="code"><pre><span class="xml-tag">&lt;g:form action=<span class="xml-quote">"shoppingCart"</span>&gt;</span>
    <span class="xml-comment">&lt;!-- Other fields --&gt;</span>
    <span class="xml-tag">&lt;g:submitButton name=<span class="xml-quote">"submit"</span> value=<span class="xml-quote">"Continue"</span>&gt;</span><span class="xml-tag">&lt;/g:submitButton&gt;</span>
    <span class="xml-tag">&lt;g:submitButton name=<span class="xml-quote">"return"</span> value=<span class="xml-quote">"Back"</span>&gt;</span><span class="xml-tag">&lt;/g:submitButton&gt;</span>
<span class="xml-tag">&lt;/g:form&gt;</span></pre></div><p class="paragraph">然而，怎么样捕捉被表格提交的信息？为了捕捉表格信息我们可以使用流切换操作：</p><p class="paragraph"></p><div class="code"><pre>enterPersonalDetails {
   on(<span class="java-quote">"submit"</span>) {
         flow.person = <span class="java-keyword">new</span> Person(params)
         !flow.person.validate() ? error() : success()
   }.to <span class="java-quote">"enterShipping"</span>
   on(<span class="java-quote">"<span class="java-keyword">return</span>"</span>).to <span class="java-quote">"showCart"</span>
}</pre></div><p class="paragraph">注意，我们是怎样执行来自请求参数的绑定，把<code>Person</code>实体放置于<code>flow</code>范围中。同样有趣的是，我们执行 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7. 验证" class="guide">验证</a>，并在验证失败是调用<code>error()</code>方法。
</p><h2><a name="6.5.6 子流程和会话">6.5.6 子流程和会话</a></h2>Grails的Web Flow集成同样支持子流（subflows）。一个子流在一个流中就像一个流。拿下面search流作为示例：<p class="paragraph"></p><div class="code"><pre>def searchFlow = {
            displaySearchForm {
                on(<span class="java-quote">"submit"</span>).to <span class="java-quote">"executeSearch"</span>
            }
            executeSearch {
                action {
                    [results:searchService.executeSearch(params.q)]
                }
                on(<span class="java-quote">"success"</span>).to <span class="java-quote">"displayResults"</span>
                on(<span class="java-quote">"error"</span>).to <span class="java-quote">"displaySearchForm"</span>
            }
            displayResults {
                on(<span class="java-quote">"searchDeeper"</span>).to <span class="java-quote">"extendedSearch"</span>
                on(<span class="java-quote">"searchAgain"</span>).to <span class="java-quote">"displaySearchForm"</span>
            }
            extendedSearch {
                subflow(extendedSearchFlow)   // &lt;--- extended search subflow
                on(<span class="java-quote">"moreResults"</span>).to <span class="java-quote">"displayMoreResults"</span>
                on(<span class="java-quote">"noResults"</span>).to <span class="java-quote">"displayNoMoreResults"</span>
            }
            displayMoreResults()
            displayNoMoreResults()
}</pre></div><p class="paragraph">它在<code>extendedSearch</code>状态中引用了一个子流。子流完全是另一个流：</p><p class="paragraph"></p><div class="code"><pre>def extendedSearchFlow = {
       startExtendedSearch {
           on(<span class="java-quote">"findMore"</span>).to <span class="java-quote">"searchMore"</span>
           on(<span class="java-quote">"searchAgain"</span>).to <span class="java-quote">"noResults"</span>
       }
       searchMore {
           action {
              def results = searchService.deepSearch(ctx.conversation.query)
              <span class="java-keyword">if</span>(!results)<span class="java-keyword">return</span> error()
              conversation.extendedResults = results
           }
           on(<span class="java-quote">"success"</span>).to <span class="java-quote">"moreResults"</span>
           on(<span class="java-quote">"error"</span>).to <span class="java-quote">"noResults"</span>
       }
       moreResults()
       noResults()
}</pre></div><p class="paragraph">注意，它是怎样把<code>extendedResults</code>放置于会话范围的。这个范围不同于流范围，因为它允许你横跨整个会话而不只是这个流。同样注意结束状态（每个子流的<code>moreResults</code> 或 <code>noResults</code>在主流中触发事件：
</p><div class="code"><pre>extendedSearch {
         subflow(extendedSearchFlow)   // &lt;--- extended search subflow
         on(<span class="java-quote">"moreResults"</span>).to <span class="java-quote">"displayMoreResults"</span>
         on(<span class="java-quote">"noResults"</span>).to <span class="java-quote">"displayNoMoreResults"</span>
}</pre></div><p class="paragraph"></p><h2><a name="6.6 过滤器">6.6 过滤器</a></h2>虽然，Grails支持良好的细粒度拦截器，它们只是对少数控制器有用，当管理大型应用时就会变得很困难。另一方面，过滤器能横跨整组控制器,一个URI空间或者一种具体的操作。过滤器对插件更容易，维护彻底的分离你主要的控制器逻辑，有利于所有像安全，日志等等这样的横切关注点。<p class="paragraph"></p><h2><a name="6.6.1 应用过滤器">6.6.1 应用过滤器</a></h2>为了创建一个过滤器在<code>grails-app/conf</code>下创建一个以规约<code>Filters</code>结尾的类。在这个类中，定义一个名为<code>filters</code>的代码块，它包含了过滤器的定义：<p class="paragraph"></p><div class="code"><pre>class ExampleFilters {
   def filters = {
        // your filters here
   }
}</pre></div><p class="paragraph">每个在 <code>filters</code>块中定义的过滤器拥有一个name 和一个 scope。name是方法的名字，scope使用的命名参数被定义。例如，假如你需要定义一个引用于所有控制器和操作的过滤器：
</p><div class="code"><pre>sampleFilter(controller:'*', action:'*') {
  // interceptor definitions
}</pre></div><p class="paragraph">过滤器的scope可能是下列事件之一：
</p><ul class="star">
<li>可选择的通配符配对一个控制器和/或操作名字</li>
<li>一个URI, 使用Ant路径匹配语法</li>
</ul><p class="paragraph">过滤器的一些示例包括：
</p><ul class="star">
<li>所有的控制器和操作</li>
</ul><p class="paragraph"></p><div class="code"><pre>all(controller:'*', action:'*') {<p class="paragraph">}</p></pre></div>
<ul class="star">
<li>只对<code>BookController</code></li>
</ul><p class="paragraph"></p><div class="code"><pre>justBook(controller:'book', action:'*') {<p class="paragraph">}</p></pre></div>
<ul class="star">
<li>适用于URI空间</li>
</ul><p class="paragraph"></p><div class="code"><pre>someURIs(uri:'/book/**') {<p class="paragraph">}</p></pre></div>
<ul class="star">
<li>适用于所有的URIs</li>
</ul><p class="paragraph"></p><div class="code"><pre>allURIs(uri:'/**') {<p class="paragraph">}</p></pre></div><p class="paragraph">另外，这个次序决定了你所定义的过滤器的执行次序。
</p><h2><a name="6.6.2 过滤器的类型">6.6.2 过滤器的类型</a></h2>在过滤器的主体内，你可以定义下列过滤器的拦截器类型之一：
<ul class="star">
<li><code>before</code> - 操作（Action）之前执行. 返回false指出将要的过滤器，并且操作（Action）将不被执行</li>
<li><code>after</code> - 操作（Action）之后执行. 获取第一参数作为视图模型</li>
<li><code>afterView</code> -视图显然之后执行</li>
</ul><p class="paragraph">例如，完成普通的身份验证使用情形，你可以定义一个过滤器，如下：
</p><div class="code"><pre>class SecurityFilters {
   def filters = {
       loginCheck(controller:'*', action:'*') {
           before = {
              <span class="java-keyword">if</span>(!session.user &amp;&amp; !actionName.equals('login')) {
                  redirect(action:'login')
                  <span class="java-keyword">return</span> <span class="java-keyword">false</span>
               }
           }<p class="paragraph">       }
   }
}</p></pre></div><p class="paragraph">
这里的<code>loginCheck</code>过滤器使用一个<code>before</code>拦截器来执行一个代码块，检查是否一个用户在session内，假如不是，重定向到login操作。注意，怎么样返回false确保操作本身不被执行.
</p><h2><a name="6.6.3 过滤器的功能">6.6.3 过滤器的功能</a></h2>过滤器支持所有在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a> 和 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库" class="guide">标签库</a>中可用的属性，附加application context：
<ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/request.html" class="controllers">request</a> -  HttpServletRequest 对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/response.html" class="controllers">response</a> -HttpServletResponse对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/session.html" class="controllers">session</a> - HttpSession 对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/servletContext.html" class="controllers">servletContext</a> - ServletContext对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/flash.html" class="controllers">flash</a> - flash 对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a> - request parameters 对象</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/actionName.html" class="controllers">actionName</a> - 正被发送的操作名</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/controllerName.html" class="controllers">controllerName</a> - 正被发送的控制器名</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/grailsApplication.html" class="controllers">grailsApplication</a> - 当前运行的Grails应用</li>
<li><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">applicationContext</a> - ApplicationContext 对象</li>
</ul><p class="paragraph">然而，过滤器只支持一个到控制器和标签库可用的方法的子集 。包括：
</p><ul class="star">
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/redirect.html" class="controllers">redirect</a> - 重定向到其他的控制器和操作</li>
<li><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a> - 渲染定制响应</li>
</ul><p class="paragraph"></p><h2><a name="6.7 Ajax">6.7 Ajax</a></h2>Grails所写的动态框架，通过它的标签库提供对构建Ajax应用的支持。完整的标签列表，查看标签库参考资料。
<h2><a name="6.7.1 用Prototype实现Ajax">6.7.1 用Prototype实现Ajax</a></h2>Grails默认装载<a href="http://www.prototypejs.org/" target="blank">Prototype</a> 库，但是通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12 插件" class="guide">Plug-in 系统</a>提供像<a href="http://dojotoolkit.org/" target="blank">Dojo</a> , <a href="http://developer.yahoo.com/yui/" target="blank">Yahoo UI</a> 和 <a href="http://code.google.com/webtoolkit/" target="blank">Google Web Toolkit</a> 等其他框架的支持.<p class="paragraph">这部分涵盖Grails对Prototype的支持。在开始之间，你必须在你页面的<code>&lt;head&gt;</code> 标签内添加这样一行：</p><p class="paragraph"></p><div class="code"><pre><span class="xml-tag">&lt;g:javascript library=<span class="xml-quote">"prototype"</span> /&gt;</span></pre></div><p class="paragraph">这里使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/javascript.html" class="tags">javascript</a> 标签自动插入Prototype正确位置的引用。假如你同样需要<a href="http://script.aculo.us/" target="blank">Scriptaculous</a> ，你可以如下这样做为替换：
</p><div class="code"><pre><span class="xml-tag">&lt;g:javascript library=<span class="xml-quote">"scriptaculous"</span> /&gt;</span></pre></div><p class="paragraph">
</p><h2><a name="6.7.1.1 异步链接">6.7.1.1 异步链接</a></h2>远程内容可以使用多种方法载入，最常使用的方法是通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/remoteLink.html" class="tags">remoteLink</a>标签。这个标签允许创建的HTML锚标记执行一个异步请求，并随意的在一个元素中设置响应。如下简单方法创建一个远程连接：
<div class="code"><pre><span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"delete"</span> id=<span class="xml-quote">"1"</span>&gt;</span>Delete Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span></pre></div><p class="paragraph">上面的连接发送一个异步请求给当前id为<code>1</code>的控制器的<code>delete</code>操作
</p><h2><a name="6.7.1.2 更新内容">6.7.1.2 更新内容</a></h2>这很重要，但是通常你可能想提供一些事情发生的反馈信息给用户：
<div class="code"><pre>def delete = {
      def b = Book.get( params.id )
      b.delete()
      render <span class="java-quote">"Book ${b.id} was deleted"</span>
}</pre></div><p class="paragraph">GSP代码：</p><p class="paragraph"></p><div class="code"><pre><span class="xml-tag">&lt;div id=<span class="xml-quote">"message"</span>&gt;</span><span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"delete"</span> id=<span class="xml-quote">"1"</span> update=<span class="xml-quote">"message"</span>&gt;</span>Delete Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span></pre></div><p class="paragraph">上面的示例将调用这个操作并设置<code>message</code> <code>div</code>的响应内容为<code>"Book 1 was deleted"</code>。这通过标签上的<code>update</code>属性来完成，它同样可以获取一个map来指出在失败时什么被更新。
</p><div class="code"><pre><span class="xml-tag">&lt;div id=<span class="xml-quote">"message"</span>&gt;</span><span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;div id=<span class="xml-quote">"error"</span>&gt;</span><span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"delete"</span> id=<span class="xml-quote">"1"</span>
              update=<span class="xml-quote">"[success:'message',failure:'error']"</span>&gt;</span>Delete Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span></pre></div><p class="paragraph">这里，<code>error</code> div在请求失败时被更新。
</p><h2><a name="6.7.1.3 异步表单提交">6.7.1.3 异步表单提交</a></h2>一个HTML form同样可以以两种方式之一被异步提交。第一个，使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/formRemote.html" class="tags">formRemote</a>标签，它和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/remoteLink.html" class="tags">remoteLink</a> 标签有类似的属性:
<div class="code"><pre><span class="xml-tag">&lt;g:formRemote url=<span class="xml-quote">"[controller:'book',action:'delete']"</span> update=<span class="xml-quote">"[success:'message',failure:'error']"</span>&gt;</span>
       <span class="xml-tag">&lt;input type=<span class="xml-quote">"hidden"</span> name=<span class="xml-quote">"id"</span> value=<span class="xml-quote">"1"</span> /&gt;</span>
       <span class="xml-tag">&lt;input type=<span class="xml-quote">"submit"</span> value=<span class="xml-quote">"Delete Book!"</span> /&gt;</span>
<span class="xml-tag">&lt;/g:formRemote &gt;</span></pre></div><p class="paragraph">或者，你也可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/submitToRemote.html" class="tags">submitToRemote</a>来创建一个提交按钮。它允许一些按钮远程提交，同时，一些不依赖操作:
</p><div class="code"><pre><span class="xml-tag">&lt;form action=<span class="xml-quote">"delete"</span>&gt;</span>
       <span class="xml-tag">&lt;input type=<span class="xml-quote">"hidden"</span> name=<span class="xml-quote">"id"</span> value=<span class="xml-quote">"1"</span> /&gt;</span>
       <span class="xml-tag">&lt;g:submitToRemote action=<span class="xml-quote">"delete"</span> update=<span class="xml-quote">"[success:'message',failure:'error']"</span> /&gt;</span>
<span class="xml-tag">&lt;/form&gt;</span></pre></div><p class="paragraph"></p><h2><a name="6.7.1.4 Ajax事件">6.7.1.4 Ajax事件</a></h2>假如，确定事件发生，特定的javascript可能被调用。所有的事件以"on"开头，在适当的地方反馈给用户，或者采用其他的操作：<p class="paragraph"></p><div class="code"><pre><span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"show"</span> 
              id=<span class="xml-quote">"1"</span> 
              update=<span class="xml-quote">"success"</span> 
              onLoading=<span class="xml-quote">"showProgress()"</span> 
              onComplete=<span class="xml-quote">"hideProgress()"</span>&gt;</span>Show Book 1<span class="xml-tag">&lt;/g:remoteLink&gt;</span></pre></div><p class="paragraph">上述代码将执行"showProgress()"函数来显示一个进度条或者其他适当的展现，其他的事件还包括：
</p><ul class="star">
<li><code>onSuccess</code>  - 成功时被调用javascript函数</li>
<li><code>onFailure</code>  - 失败时被调用javascript函数</li>
<li><code>on_ERROR_CODE</code>  - 处理指定的错误代码时调用javascript函数 (例如 on404="alert('not found!')")</li>
<li><code>onUninitialized</code>  - 一个ajax引擎初始化失败时调用javascript函数</li>
<li><code>onLoading</code>  - 当远程函数加载响应时调用javascript函数</li>
<li><code>onLoaded</code>  - 当远程函数加载完响应时调用javascript函数</li>
<li><code>onComplete</code>  - 当远程函数完成（包括任何更新）时调用javascript函数</li>
</ul><p class="paragraph">假如你需要引用<code>XmlHttpRequest</code>对象，你可以使用隐式的event参数<code>e</code> 获取它：
</p><div class="code"><pre><span class="xml-tag">&lt;g:javascript&gt;</span>
   function fireMe(e) {
	   alert(<span class="xml-quote">"XmlHttpRequest = "</span> + e)
   }
}
<span class="xml-tag">&lt;/g:javascript&gt;</span>
<span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"example"</span> 
              update=<span class="xml-quote">"success"</span> 
              onSuccess=<span class="xml-quote">"fireMe(e)"</span>&gt;</span>Ajax Link<span class="xml-tag">&lt;/g:remoteLink&gt;</span></pre></div><p class="paragraph"></p><h2><a name="6.7.2 用Dojo实现Ajax">6.7.2 用Dojo实现Ajax</a></h2>Grails把<a href="http://dojotoolkit.org/" target="blank">Dojo</a> 作为一种外部插件来支持Grails的特性。在终端窗口，从你项目的根目录键入下列命令来安装插件。
<div class="code"><pre>grails install-plugin dojo</pre></div><p class="paragraph">将下载Dojo最新的支持版本，并安装到你的Grails项目中。完成上面的步骤后，你可以在你页面的顶部添加下列引用：
</p><div class="code"><pre><span class="xml-tag">&lt;g:javascript library=<span class="xml-quote">"dojo"</span> /&gt;</span></pre></div><p class="paragraph">现在，所有像<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/remoteLink.html" class="tags">remoteLink</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/formRemote.html" class="tags">formRemote</a>和 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/submitToRemote.html" class="tags">submitToRemote</a>标签都可以和Dojo进行远程处理工作。
</p><h2><a name="6.7.3 用GWT实现Ajax">6.7.3 用GWT实现Ajax</a></h2>Grails同样支持<a href="http://code.google.com/webtoolkit/" target="blank">Google Web Toolkit</a> 特性，插件的全面<a href="http://grails.org/GWT+Plugin" target="blank">文档</a>可以Grails wiki中找到.
<h2><a name="6.7.4 服务端的Ajax">6.7.4 服务端的Ajax</a></h2>虽然Ajax特性X为XML，但通常可以分解成许多不同方式执行Ajax:
<ul class="star">
<li>内容为中心的 Ajax - 只不过是使用远程调用的HTML结果来更新页面</li>
<li>数据为中心的Ajax - 实际上是发送一个来自于服务器端的XML或JSON，通过编程更新页面</li>
<li>脚本为中心的 Ajax - 服务器端发送的Javascript流在传送过程中被赋值</li>
</ul><p class="paragraph">在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.7 Ajax" class="guide">Ajax</a>部分中的更多的示例涵盖了内容为中心的 Ajax在什么地方更新页面，但同样你可能使用数据为中心的Ajax或脚本为中心的 Ajax。这份指南涵盖了不同风格的Ajax.</p><p class="paragraph"></p><h4>内容为中心的Ajax</h4><p class="paragraph">作为概括，内容为中心的 Ajax涉及从服务器端发送一些HTML返回和通过使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法来渲染模板：</p><p class="paragraph"></p><div class="code"><pre>def showBook = {
	def b = Book.get(params.id)<p class="paragraph">	render(template:<span class="java-quote">"bookTemplate"</span>, model:[book:b])
}</p></pre></div><p class="paragraph">在客户端调用这个涉及使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/remoteLink.html" class="tags">remoteLink</a> 标签:
</p><div class="code"><pre><span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"showBook"</span> id=<span class="xml-quote">"${book.id}"</span> update=<span class="xml-quote">"book${book.id}"</span>&gt;</span>Update Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span>
<span class="xml-tag">&lt;div id=<span class="xml-quote">"book${book.id}"</span>&gt;</span>
   <span class="xml-comment">&lt;!--existing book mark-up --&gt;</span>
<span class="xml-tag">&lt;/div&gt;</span></pre></div><p class="paragraph"></p><h4>数据为中心的Ajax与JSON</h4><p class="paragraph">数据为中心的Ajax通常涉及在客户端上的响应赋值和通过编程更新。Grails中的JSON响应，你将使用Grails典型的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.7 XML和JSON响应" class="guide">JSON marshaling</a>能力：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.converters.*<p class="paragraph">def showBook = {
	def b = Book.get(params.id)</p><p class="paragraph">    render b as JSON	
}</p></pre></div><p class="paragraph">随后，在客户端使用一个Ajax事件处理解析这个进入的JSON请求：
</p><div class="code"><pre><span class="xml-tag">&lt;g:javascript&gt;</span>
function updateBook(e) {
	var book = eval(<span class="xml-quote">"("</span>+e.responseText+<span class="xml-quote">")"</span>) // evaluate the JSON
	$(<span class="xml-quote">"book"</span>+book.id+<span class="xml-quote">"_title"</span>).innerHTML = book.title
}
<span class="xml-tag">&lt;g:javascript&gt;</span>
<span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"test"</span> update=<span class="xml-quote">"foo"</span> onSuccess=<span class="xml-quote">"updateBook(e)"</span>&gt;</span>Update Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span>
<span class="xml-tag">&lt;g:set var=<span class="xml-quote">"bookId"</span>&gt;</span>book${book.id}<span class="xml-tag">&lt;/g:set&gt;</span>
<span class="xml-tag">&lt;div id=<span class="xml-quote">"${bookId}"</span>&gt;</span>
	<span class="xml-tag">&lt;div id=<span class="xml-quote">"${bookId}_title"</span>&gt;</span>The Stand<span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;/div&gt;</span></pre></div><p class="paragraph"></p><h4>数据为中心的Ajax与XML</h4><p class="paragraph">在服务器端使用XML同样简单：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.converters.*<p class="paragraph">def showBook = {
	def b = Book.get(params.id)</p><p class="paragraph">    render b as XML	
}</p></pre></div><p class="paragraph">然而，因为涉及到DOM，客户变得更加复杂：
</p><div class="code"><pre><span class="xml-tag">&lt;g:javascript&gt;</span>
function updateBook(e) {
	var xml = e.responseXML
	var id = xml.getElementsByTagName(<span class="xml-quote">"book"</span>).getAttribute(<span class="xml-quote">"id"</span>)
	$(<span class="xml-quote">"book"</span>+id+<span class="xml-quote">"_title"</span>)=xml.getElementsByTagName(<span class="xml-quote">"title"</span>)[0].textContent
}
<span class="xml-tag">&lt;g:javascript&gt;</span>
<span class="xml-tag">&lt;g:remoteLink action=<span class="xml-quote">"test"</span> update=<span class="xml-quote">"foo"</span> onSuccess=<span class="xml-quote">"updateBook(e)"</span>&gt;</span>Update Book<span class="xml-tag">&lt;/g:remoteLink&gt;</span>
<span class="xml-tag">&lt;g:set var=<span class="xml-quote">"bookId"</span>&gt;</span>book${book.id}<span class="xml-tag">&lt;/g:set&gt;</span>
<span class="xml-tag">&lt;div id=<span class="xml-quote">"${bookId}"</span>&gt;</span>
	<span class="xml-tag">&lt;div id=<span class="xml-quote">"${bookId}_title"</span>&gt;</span>The Stand<span class="xml-tag">&lt;/div&gt;</span>
<span class="xml-tag">&lt;/div&gt;</span></pre></div><p class="paragraph"></p><h4>脚本为中心的Ajax与JavaScript</h4><p class="paragraph">脚本为中心的 Ajax涉及实际返回的Javascript,在客户端得到赋值。这样的示例见下表：
</p><div class="code"><pre>def showBook = {
	def b = Book.get(params.id)<p class="paragraph">    response.contentType = <span class="java-quote">"text/javascript"</span>
    <span class="java-object">String</span> title = b.title.encodeAsJavascript()
    render <span class="java-quote">"$('book${b.id}_title')='${title}'"</span>
}</p></pre></div><p class="paragraph">要记住的重要事情是，设置<code>contentType</code>为<code>text/javascript</code>。假如你在客户端使用Prototype，由于这个<code>contentType</code>设置，返回的Javascript将自动被赋值。
很明显，在这种情况下，它是关键性的，你有一个一致的client-sideAPI，因为，你不想客户端的改变破坏服务器端。这就是Rails有些像RJS的理由之一。虽然，Grails当前没有像RJS的一个特性，但<a href="http://grails.org/Dynamic+Javascript+Plugin" target="blank">动态JavaScript 插件</a>提供了类似的功能。
</p><h2><a name="6.8 内容协商">6.8 内容协商</a></h2>Grails使用任何一个HTTP <code>Accept</code> 报头来内置支持<a href="http://en.wikipedia.org/wiki/Content_negotiation" target="blank">内容协商</a>，一种明确格式化请求参数或扩展的一种URI映射 。<p class="paragraph"></p><h4>配置Mime类型</h4><p class="paragraph">在你开始处理内容协商之前，你必须告诉Grails你希望支持什么样的内容类型。默认情况下，Grails在<code>grails-app/conf/Config.groovy</code>内使用 <code>grails.mime.types</code>设置来配置若干不同的内容类型。
</p><div class="code"><pre>grails.mime.types = [ xml: ['text/xml', 'application/xml'],
                      text: 'text-plain',
                      js: 'text/javascript',
                      rss: 'application/rss+xml',
                      atom: 'application/atom+xml',
                      css: 'text/css',
                      cvs: 'text/csv',
                      all: '*/*',
                      json: 'text/json',
                      html: ['text/html','application/xhtml+xml']
                    ]</pre></div><p class="paragraph">上面的小块配置，允许Grails检查把包含 'text/xml' 或 'application/xml' 媒体类型的一个请求的格式只当做 'xml'看待，你可以添加你自己的类型通过简单的添加条目到 map中.</p><p class="paragraph"></p><h4>内容协商-使用Accept报头</h4><p class="paragraph">每个进入的HTTP请求都有个特别的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="blank">Accept</a>报头，它定义了客户端能“接受”什么样的媒体类型(或 mime 类型)。这个在老式的浏览器中是比较典型的：
</p><div class="code"><pre>*/*</pre></div><p class="paragraph">简单的表示任何事物。然而，在较新的浏览器中，更多有用的东西像这样被全部一起发送(一个Firefox <code>Accept</code> 报头示例):
</p><div class="code"><pre>text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5</pre></div><p class="paragraph">Grails解析这个进入的格式，并添加一个 <code>property</code>给<a href="http://www.kuqin.com/grails-doc-1.0/ref/Servlet%20API/request.html" class="servletAPI">request</a>对象，来描叙更为理想的请求格式。对于上述的例子下列的断言将通过</p><p class="paragraph"></p><div class="code"><pre>assert 'html' == request.format</pre></div><p class="paragraph">为什么？这个<code>text/html</code>媒体类型拥有最高"质量"等级0.9，因此，具有最高优先权。如果如前所述，你有一老式浏览器结果会稍微不同:
</p><div class="code"><pre>assert 'all' == request.format</pre></div><p class="paragraph">在这种情况下，'all'可能的格式将被客户端接受。为了处理来自<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>不同类型的请求，你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/withFormat.html" class="controllers">withFormat</a>方法，它的行为被当作switch语句类型：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.converters.*<p class="paragraph">class BookController {
	def books
	def list = {
		<span class="java-keyword">this</span>.books = Book.list()
		withFormat {
			html bookList:books
			js { render <span class="java-quote">"alert('hello')"</span> } 
			xml { render books as XML }
		}
	}
}</p></pre></div><p class="paragraph">这里发生了什么，假如优先格式是<code>html</code>，随后Grails将只执行<code>html()</code>调用。这个做了什么，它使Grails寻找一个视图调用每个<code>grails-app/views/books/list.html.gsp</code> 或 <code>grails-app/views/books/list.gsp</code>。假如这个格式是<code>xml</code>，随后，闭包将会被调用，一个XML响应被渲染。</p><p class="paragraph">假如这个accept报头是'all'，就像在老式浏览器里，随后，格式的选择将基于withFormat方法之内的调用秩序。在这种情况下，早前示例的<code>html</code>方法将首先被调用。</p><p class="paragraph"></p><blockquote class="note">
当使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/withFormat.html" class="controllers">withFormat</a>时确保它是控制器操作的最后一个被调用，当<code>withFormat</code>方法的返回值被操作使用支配下一步做什么。
</blockquote><p class="paragraph"></p><h4>内容协商与格式化请求参数</h4><p class="paragraph">如果请求头的内容跟你的不一直，那么你可以覆盖在request参数中的特定<code>format</code>来解决：</p><p class="paragraph"></p><div class="code"><pre>/book/list?format=xml</pre></div><p class="paragraph">你同样可以在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL Mappings</a>定义中定义这个参数：
</p><div class="code"><pre><span class="java-quote">"/book/list"</span>(controller:<span class="java-quote">"book"</span>, action:<span class="java-quote">"list"</span>) {
	format = <span class="java-quote">"xml"</span>
}</pre></div><p class="paragraph"></p><h4>内容协商与URI扩展</h4><p class="paragraph">Grails同样可以通过URI扩展来支持内容协商。例如，给出下列URI：
</p><div class="code"><pre>/book/list.xml</pre></div><p class="paragraph">Grails将刮去扩展，并映射到<code>/book/list</code>作为替代，同时，基于这个扩展把内容格式化为<code>xml</code>。这个行为是默认允许的，那么，假如你希望关闭它，你必须把<code>grails-app/conf/Config.groovy</code>下的<code>grails.mime.file.extensions</code>属性设置为<code>false</code>：
</p><div class="code"><pre>grails.mime.file.extensions = <span class="java-keyword">false</span></pre></div><p class="paragraph"></p><h4>测试内容协商</h4><p class="paragraph">为了在一个集成测试中测试内容协商(参见 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9. 测试" class="guide">测试</a>部分)你能任一个操纵引入的请求报头:
</p><div class="code"><pre>void testJavascriptOutput() {
	def controller = <span class="java-keyword">new</span> TestController()
	controller.request.addHeader <span class="java-quote">"Accept"</span>, <span class="java-quote">"text/javascript, text/html, application/xml, text/xml, */*"</span><p class="paragraph">	controller.testAction()
	assertEquals <span class="java-quote">"alert('hello')"</span>, controller.response.contentAsString
}</p></pre></div><p class="paragraph">或者你可以设置这个格式化参数来完成一个简单效果：</p><p class="paragraph"></p><div class="code"><pre>void testJavascriptOutput() {
	def controller = <span class="java-keyword">new</span> TestController()
	controller.params.format = 'js'<p class="paragraph">	controller.testAction()
	assertEquals <span class="java-quote">"alert('hello')"</span>, controller.response.contentAsString
}</p></pre></div>
<h1><a name="7. 验证">7. 验证</a></h1>Grails的验证功能是建立在<a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/validation/package-summary.html" target="blank">Spring's Validator API</a>和数据绑定之上的，但Grails在此特性和约束机制的基础上又提供了统一的定义验证约束的方法。<p class="paragraph">Grails中的约束是采用声明性验证规则的方式进行的，大多情况下这些规则都是应用在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">领域类</a>上，不过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL映射</a> and <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.9 命令对象" class="guide">命令对象</a>同样也支持约束。
</p><h2><a name="7.1 声明约束">7.1 声明约束</a></h2>在一个领域类中，约束<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/constraints.html" class="domainClasses">constraints</a>被定义在constraints属性的代码块中：
<div class="code"><pre>class User {
    <span class="java-object">String</span> login
    <span class="java-object">String</span> password
    <span class="java-object">String</span> email
    <span class="java-object">Integer</span> age<p class="paragraph">    <span class="java-keyword">static</span> constraints = {
	  …
    }
}</p></pre></div><p class="paragraph">然后可以通过方法来调用相匹配的属性名，而属性的约束是通过命名参数的组合来满足特定的限制的：</p><p class="paragraph"></p><div class="code"><pre>class User {
    ...<p class="paragraph">    <span class="java-keyword">static</span> constraints = {
        login(size:5..15, blank:<span class="java-keyword">false</span>, unique:<span class="java-keyword">true</span>)
        password(size:5..15, blank:<span class="java-keyword">false</span>)
        email(email:<span class="java-keyword">true</span>, blank:<span class="java-keyword">false</span>)
        age(min:18, nullable:<span class="java-keyword">false</span>)
    }
}</p></pre></div><p class="paragraph">在上述示例中，我们声明的<code>login</code>属性其长度是5-10个字符，而且不能为空，且必须唯一，我们同样也在<code>password</code>, <code>email</code> 和 <code>age</code> 属性上应用了约束。
</p><blockquote class="note">
  完整有效的约束参考请浏览参考指南
</blockquote>
<h2><a name="7.2 验证约束">7.2 验证约束</a></h2><h4>验证基础</h4><p class="paragraph">要验证一个领域类，你可以在任何实例上调用其<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/validate.html" class="domainClasses">validate</a>方法：
</p><div class="code"><pre>def user =  <span class="java-keyword">new</span> User(params)<p class="paragraph"><span class="java-keyword">if</span>(user.validate()) {
    // <span class="java-keyword">do</span> something with user
}
<span class="java-keyword">else</span> {
    user.errors.allErrors.each {
        println it
    }
}</p></pre></div><p class="paragraph">领域类的 <code>errors</code>属性是Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/Errors.html" class="api">Errors</a>接口实例，<code>Errors</code>接口提供了访问这些验证错误的方法，并且还可以取得原始的值。
</p><h4>验证阶段</h4>
在Grails中，有两个基本的验证阶段，第一个是<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.6 数据绑定" class="guide">数据绑定</a>，发生在将你的请求参数绑定到一个类实例的时候：
<div class="code"><pre>def user = <span class="java-keyword">new</span> User(params)</pre></div><p class="paragraph">在这个时候如果你通过<code>errors</code>捕获到错误，可能是因为类型转换（比如将字符串转化为日期类型），你还可以通过 <code>Errors</code>来检测和获取到输入的原始值，比如：
</p><div class="code"><pre><span class="java-keyword">if</span>(user.hasErrors()) {
	<span class="java-keyword">if</span>(user.hasFieldError(<span class="java-quote">"login"</span>)) {
		println user.getFieldError(<span class="java-quote">"login"</span>).rejectedValue
	}
}</pre></div><p class="paragraph">验证的第二阶段发生在你调用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/validate.html" class="domainClasses">validate</a>或者<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a>的时候，Grails将通过你定义的<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/constraints.html" class="domainClasses">constraints</a>来验证这些值的边界。比如，缺省情况下，在执行<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a>操作以前，将会先调用 <code>validate</code>方法，因此你可以写如下类似代码：
</p><div class="code"><pre><span class="java-keyword">if</span>(user.save()) {
    <span class="java-keyword">return</span> user
}
<span class="java-keyword">else</span> {
    user.errors.allErrors.each {
        println it
    }
}</pre></div><p class="paragraph"></p><h2><a name="7.3 客户端验证">7.3 客户端验证</a></h2><h4>显示错误</h4><p class="paragraph">通常情况下，如果你得到一个验证错误，你希望重定向到要渲染的视图，在那里，你需要一些方法来呈现这些错误。Grails通过很多丰富的标签来处理这些错误，比如你只想简单的将这些错误显示为列表（list），你可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/renderErrors.html" class="tags">renderErrors</a>
</p><div class="code"><pre><span class="xml-tag">&lt;g:renderErrors bean=<span class="xml-quote">"${user}"</span> /&gt;</span></pre></div><p class="paragraph">如果你想更详细地显示，你可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/hasErrors.html" class="tags">hasErrors</a>和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/eachError.html" class="tags">eachError</a>
</p><div class="code"><pre><span class="xml-tag">&lt;g:hasErrors bean=<span class="xml-quote">"${user}"</span>&gt;</span>
  <span class="xml-tag">&lt;ul&gt;</span>
   <span class="xml-tag">&lt;g:eachError var=<span class="xml-quote">"err"</span> bean=<span class="xml-quote">"${user}"</span>&gt;</span>
       <span class="xml-tag">&lt;li&gt;</span>${err}<span class="xml-tag">&lt;/li&gt;</span> 
   <span class="xml-tag">&lt;/g:eachError&gt;</span>
  <span class="xml-tag">&lt;/ul&gt;</span>
<span class="xml-tag">&lt;/g:hasErrors&gt;</span></pre></div><p class="paragraph"></p><h4>高亮显示错误</h4><p class="paragraph">当一个字段输入不正确的时候，经常是用红色方框或者类似的东东来高亮显示,这也可以通过调用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/hasErrors.html" class="tags">hasErrors</a>来完成，比如：
</p><div class="code"><pre><span class="xml-tag">&lt;div class='value ${hasErrors(bean:user,field:'login','errors')}'&gt;</span>
   <span class="xml-tag">&lt;input type=<span class="xml-quote">"text"</span> name=<span class="xml-quote">"login"</span> value=<span class="xml-quote">"${fieldValue(bean:user,field:'login')}"</span>/&gt;</span>
<span class="xml-tag">&lt;/div&gt;</span></pre></div><p class="paragraph">这段代码所做的是检查<code>user</code> bean的<code>login</code>字段是否存在错误，如果发现错误，就在<code>div</code>上的增加一个<code>errors</code>的CSS类，这样你就可以使用CSS的规则来高亮显示<code>div</code>了。</p><p class="paragraph"></p><h4>获取输入值</h4><p class="paragraph">每一个error实际上是Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/FieldError.html" class="api">FieldError</a>类的一个实例，它包含着输入的原始值，当你希望使用出错的对象来恢复原来值的时候，这是很有用的，你可以通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/fieldValue.html" class="tags">fieldValue</a>标签来实现：
</p><div class="code"><pre><span class="xml-tag">&lt;input type=<span class="xml-quote">"text"</span> name=<span class="xml-quote">"login"</span> value=<span class="xml-quote">"${fieldValue(bean:user,field:'login')}"</span>/&gt;</span></pre></div><p class="paragraph">此代码将先检查 <code>User</code> bean上是否存在一个<code>FieldError</code>，如果存在它将为<code>login</code>字段获取到原始输入值。
</p><h2><a name="7.4 验证和国际化">7.4 验证和国际化</a></h2>Grails中关于错误的另一重要的事情是不要在代码中到处硬编码，在Grails <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10. 国际化" class="guide">i18n</a>所支持的消息绑定（message bundles）的协助下，Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/FieldError.html" class="api">FieldError</a>类基本可以解决硬编码信息的问题。<p class="paragraph"></p><h4>约束和信息代码</h4><p class="paragraph">约束代码本身就是规约（convention）支配的，让我们看看早些时候的约束的示例：
</p><div class="code"><pre>class User {
    ...<p class="paragraph">    <span class="java-keyword">static</span> constraints = {
        login(size:5..15, blank:<span class="java-keyword">false</span>, unique:<span class="java-keyword">true</span>)
        password(size:5..15, blank:<span class="java-keyword">false</span>)
        email(email:<span class="java-keyword">true</span>, blank:<span class="java-keyword">false</span>)
        age(min:18, nullable:<span class="java-keyword">false</span>)
    }
}</p></pre></div><p class="paragraph">通常如果违反了<code>blank</code>约束，Grails将以如下形式寻找信息编码：
</p><div class="code"><pre>[<span class="java-object">Class</span> Name].[Property Name].[Constraint Code]</pre></div><p class="paragraph">在<code>blank</code>约束中，以上代码应该是<code>user.login.blank</code>，因此在你的<code>grails-app/i18n/messages.properties</code>文件中需要如下信息：
</p><div class="code"><pre>user.login.blank=Your login name must be specified!</pre></div><p class="paragraph">关于什么编码匹配什么约束的参考请参照每个约束的参考指南（本指南的constraint部分--译者注）。</p><p class="paragraph"></p><h4>显示信息</h4><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/renderErrors.html" class="tags">renderErrors</a>标签将使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/message.html" class="tags">message</a>标签来为你寻找信息，但是如果你希望自己更多控制显示，那你需要自己做如下的事情：
</p><div class="code"><pre><span class="xml-tag">&lt;g:hasErrors bean=<span class="xml-quote">"${user}"</span>&gt;</span>
  <span class="xml-tag">&lt;ul&gt;</span>
   <span class="xml-tag">&lt;g:eachError var=<span class="xml-quote">"err"</span> bean=<span class="xml-quote">"${user}"</span>&gt;</span>
       <span class="xml-tag">&lt;li&gt;</span><span class="xml-tag">&lt;g:message error=<span class="xml-quote">"${err}"</span> /&gt;</span><span class="xml-tag">&lt;/li&gt;</span> 
   <span class="xml-tag">&lt;/g:eachError&gt;</span>
  <span class="xml-tag">&lt;/ul&gt;</span>
<span class="xml-tag">&lt;/g:hasErrors&gt;</span></pre></div><p class="paragraph">在此示例中，我们在<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/eachError.html" class="tags">eachError</a>标签内又使用了<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/message.html" class="tags">message</a>标签，通过<code>error</code>参数我们可以读取错误的信息。
</p><h1><a name="8. 服务层">8. 服务层</a></h1>和<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6. Web层" class="guide">web层</a>一样，Grails中也有service层的概念。Grails团队不鼓励在controller中嵌入核心应用逻辑，因为这样不利于代码的重用，也影响清晰的分层。<p class="paragraph">Grials中,应用的主要逻辑都放在的service层，controller负责处理请求流程。</p><p class="paragraph"></p><h4>创建一个Service</h4><p class="paragraph">要创建一个Grails service,你只要进入命令行模式，在项目的根目录下，执行<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-service.html" class="commandLine">create-service</a>命令:</p><p class="paragraph"></p><div class="code"><pre>grails create-service simple</pre></div><p class="paragraph">这样就会创建一个service，这个service位于 <code>grails-app/services/SimpleService.groovy</code> .除了名字按照Grails的约定以 <code>Service</code>结尾以外,这个文件就是一个普通的Groovy类:</p><p class="paragraph"></p><div class="code"><pre>class SimpleService {	
}</pre></div>
<h2><a name="8.1 声明式事务">8.1 声明式事务</a></h2>Services 通常会包含这样的逻辑--需要多个 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">domain 类</a>之间相互配合。因此它常常会出现这样的情况:涉及到的持久化包括大量的数据库操作。这些问题使得service中经常都需要对方法进行事务管理。当然你可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/withTransaction.html" class="domainClasses">withTransaction</a> 方法来管理事务，但是这样很繁琐，也不能充分利用Spring的强大的事务抽象能力。<p class="paragraph">Grails中可以对service进行事务划分，它声明service中所有方法都是事务型的。缺省所有的service都进行了事务划分。要禁用这个配置，只需要设置 <code>transactional</code> 属性为 <code>false</code>：</p><p class="paragraph"></p><div class="code"><pre>class CountryService {
    <span class="java-keyword">static</span> transactional = <span class="java-keyword">false</span>
}</pre></div><p class="paragraph">你也可以设置这个属性为<code>true</code>，以防止将来这个默认值改变后对你的应用造成影响，或者是明确声明service是事务型的。</p><p class="paragraph"></p><blockquote class="warning">
警告: <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8.3 依赖注入和服务" class="guide">依赖注入</a> 是使声明式事务工作的<strong class="bold">唯一</strong> 途径。如果你自己用<code>new</code>操作符，比如<code>new BookService()</code>，将不能得到一个事务型的service.
</blockquote><p class="paragraph">
这样的结果是所有的方法被包装在一个事务中，在方法中有异常抛出时，将会自动回滚。事务传播级别默认是<a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/TransactionDefinition.html#PROPAGATION_REQUIRED" target="blank">PROPAGATION_REQUIRED</a>.
</p><h2><a name="8.2 服务的作用域">8.2 服务的作用域</a></h2>缺省情况下，service中的方法不是同步的,没有什么能阻止并发执行service中的方法。实际上，因为service是单例并且可能会并发执行，你要在service中保存状态时需要慎重考虑一下，最好是不要在service中存储任何状态.<p class="paragraph">你可以通过将service放入一个特定的范围来改变这个行为.目前支持的范围有:
</p><ul class="star">
<li><code>prototype</code> - 当它每次被注入另外一个类时，创建一个新的service</li>
<li><code>request</code> - 每个请求创建一个新的service</li>
<li><code>flash</code> - 为当前和下一个请求创建一个service</li>
<li><code>flow</code> - 为一个web flow创建一个service</li>
<li><code>conversation</code> -在web flow中，为一个会话创建一个service. 比如一个根流程和它的子流程.</li>
<li><code>session</code> - 为一个用户会话创建一个service</li>
<li><code>singleton</code> (默认) - 始终只有一个service实例存在</li>
</ul><p class="paragraph"></p><blockquote class="note">
如果你的service是<code>flash</code>, <code>flow</code> 或者 <code>conversation</code> 范围的，它需要实现<code>java.io.Serializable</code>接口，并且只能用于<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5 Web Flow" class="guide">Web Flow</a>上下文.
</blockquote><p class="paragraph">      
要使用上面的某个范围，只要在你的类中增加一个static scope属性:
</p><div class="code"><pre><span class="java-keyword">static</span> scope = <span class="java-quote">"flow"</span></pre></div><p class="paragraph"></p><h2><a name="8.3 依赖注入和服务">8.3 依赖注入和服务</a></h2><h4>基本的依赖注入</h4><p class="paragraph">Grails service的一个重要方面是它从<a href="http://www.springframework.org/" target="blank">Spring Framework</a> 获得的依赖注入能力。Grails提供了"基于约定的依赖注入".也就是说，你可以使用service的类名作为属性名，自动将它们注入到controller,tag库等地方。</p><p class="paragraph">例如，有一个叫做<code>BookService</code>的service,如果你在一个controller里定义了一个<code>bookService</code> 属性:
</p><div class="code"><pre>class BookController {
   def bookService
   …
}</pre></div><p class="paragraph">这时Spring容器将会根据这个service的scope配置，自动注入一个service的实例。所有的依赖注入都根据名字完成;Grails不支持根据类型注入.你也可以指定类型，如下:</p><p class="paragraph"></p><div class="code"><pre>class AuthorService {
	BookService bookService
}</pre></div><p class="paragraph">但是这样做会产生一个副作用，如果你在开发模式下改变了 <code>BookService</code> ，重新加载时会抛出一个错误.</p><p class="paragraph"></p><h4>依赖注入和service</h4><p class="paragraph">你可以用同样的方法在一个service中注入另一个service.比如你有一个<code>AuthorService</code>，它需要使用 <code>BookService</code>,那么只要这样:</p><p class="paragraph"></p><div class="code"><pre>class AuthorService {
	def bookService
}</pre></div><p class="paragraph"></p><h4>依赖注入和Domain类</h4><p class="paragraph">你甚至可以将service注入到domain类中，这在开发富domain模型时可能会有用:</p><p class="paragraph"></p><div class="code"><pre>class Book {	
	…
	def bookService
	def buyBook() {
		bookService.buyBook(<span class="java-keyword">this</span>)
	}
}</pre></div>
<h2><a name="8.4 使用Java的服务">8.4 使用Java的服务</a></h2>Grails service封装了可重用的逻辑,你可以在包括Java类的其他类中使用他们，这是它另外一个强大地方。有多种方法重用用Java编写的service,最简单是把你的service移进<code>grails-app/services</code> 目录下的一个包里,因为Java中不能从缺省包(如果没有声明包,就使用缺省包)中导入一个类。所以像下面用Java编写的<code>BookService</code>就不能被导入从而无法重用:<p class="paragraph"></p><div class="code"><pre>class BookService {
	void buyBook(Book book) {
		// logic
	}
}</pre></div><p class="paragraph">但是，这个问题是很容易解决的。你只要将这个类放进一个包里就可以了，也就是将这个类移进一个子目录，比如<code>grails-app/services/bookstore</code> ，然后修改包声明:
</p><div class="code"><pre><span class="java-keyword">package</span> bookstore
class BookService {
	void buyBook(Book book) {
		// logic
	}
}</pre></div><p class="paragraph">另外一个替代方案是，在包里面建立一个service要实现的接口:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">package</span> bookstore;
<span class="java-keyword">interface</span> BookStore {
	void buyBook(Book book);
}</pre></div><p class="paragraph">然后service实现这个接口:</p><p class="paragraph"></p><div class="code"><pre>class BookService <span class="java-keyword">implements</span> bookstore.BookStore {
	void buyBook(Book b) {
		// logic
	}
}</pre></div><p class="paragraph">后面这种方法更清楚，因为在Java里只引用了接口，与实现类无关。无论哪种方法，这个任务的目标是要使得Java在编译时能够静态地找到它要用的类(或接口)。现在这个任务完成了,你可以在 <code>src/java</code> 包里面创建一个Java类，然后增加一个setter方法，以便在Spring中能够装配这个bean:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">package</span> bookstore;
// note: <span class="java-keyword">this</span> is Java class
<span class="java-keyword">public</span> class BookConsumer {
	<span class="java-keyword">private</span> BookStore store;<p class="paragraph">	<span class="java-keyword">public</span> void setBookStore(BookStore storeInstance) {
		<span class="java-keyword">this</span>.store = storeInstance;
	}	
	…
}</p></pre></div><p class="paragraph">完成了这些，你就可以在<code>grails-app/conf/spring/resources.xml</code>(关于这个的更多信息请参考 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14. Grails和Spring" class="guide">Grails and Spring</a>一章 )中将这个Java类为一个Spring bean了:</p><p class="paragraph"></p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"bookConsumer"</span> class=<span class="xml-quote">"bookstore.BookConsumer"</span>&gt;</span>
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"bookStore"</span> ref=<span class="xml-quote">"bookService"</span> /&gt;</span>
<span class="xml-tag">&lt;/bean&gt;</span></pre></div><p class="paragraph"></p><h1><a name="9. 测试">9. 测试</a></h1>自动化测试是Grails的关键部分之一，它是用<a href="http://groovy.codehaus.org/Testing+Guide" target="blank">Groovy Tests</a>实现的。因此，Grials提供了从低级的单元测试到高级的功能测试的多种方法来使测试更简单。这章详细解释Grails提供的各种测试的不同功能。<p class="paragraph">首先需要知道的是所有的<code>create-*</code>命令结束时Grails都会为你创建集成测试。比如说你运行 <a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/create-controller.html" class="commandLine">create-controller</a> 命令:</p><p class="paragraph"></p><div class="code"><pre>grails create-controller simple</pre></div><p class="paragraph">Grails不仅为你在<code>grails-app/controllers/SimpleController.groovy</code>创建了一个controller,而且在<code>test/integration/SimpleControllerTests.groovy</code>生成了一个集成测试类.Grails不会为你填充测试中的逻辑！这个留给你做.</p><p class="paragraph">一旦你完成了这个，就可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/test-app.html" class="commandLine">test-app</a> 命令执行所有的测试:</p><p class="paragraph"></p><div class="code"><pre>grails test-app</pre></div><p class="paragraph">执行上面的命令将会得到下面这样的输出：</p><p class="paragraph"></p><div class="code"><pre>-------------------------------------------------------
Running Unit Tests…
Running test FooTests...FAILURE
Unit Tests Completed in 464ms …
-------------------------------------------------------<p class="paragraph">Tests failed: 0 errors, 1 failures</p></pre></div><p class="paragraph">同时将会在 <code>test/reports</code> 目录下生成测试报告。你也可以按照指定的名字(不含<code>Tests</code>后缀)运行某个测试:</p><p class="paragraph"></p><div class="code"><pre>grails test-app SimpleController</pre></div><p class="paragraph">另外，把一组测试名用空格分开，你就可以运行一组测试:</p><p class="paragraph"></p><div class="code"><pre>grails test-app SimpleController BookController</pre></div><p class="paragraph"></p><h2><a name="9.1 单元测试">9.1 单元测试</a></h2>单元测试是"单元"级的测试。也就是说，你可以测试单独的方法或者代码块而不用考虑周边基础设施.在Grails中，你需要确切地理解单元测试和集成测试的差别，Grails在集成测试和运行时生成的动态方法，在单元测试中都不可用。<p class="paragraph">因为这个原因，Grails提供了一些工具来模拟这些方法，比如<a href="http://docs.codehaus.org/display/GROOVY/Groovy+Mocks" target="blank">Groovy Mock</a> 或者 <a href="http://groovy.codehaus.org/ExpandoMetaClass" target="blank">ExpandoMetaClass</a>.</p><p class="paragraph">例如,在<code>BookController</code>里你有一个这样的action：</p><p class="paragraph"></p><div class="code"><pre>def show = {
    [ book : Book.get( params.id ) ]
}</pre></div><p class="paragraph">
<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a> 对象和<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/get.html" class="domainClasses">get</a> 方法都是运行时Grails提供的，在单元测试中不能用，但你可以用 <code>ExpandoMetaClass</code>模拟它们:</p><p class="paragraph"></p><div class="code"><pre>void testShow() {
	// mock the <span class="java-keyword">static</span> get method
	Book.metaClass.<span class="java-keyword">static</span>.get = { <span class="java-object">Long</span> id -&gt; 
		assert id == 10
		<span class="java-keyword">new</span> Book(id:id,title:<span class="java-quote">"The Stand"</span>)
    } 
    // mock the params object	
	BookController.metaClass.getParams = {-&gt; [id:10] }
	def controller = <span class="java-keyword">new</span> BookController()
	def model = controller.show()
	assert model
	assert model.book
	assertEquals 10, model.book.id
	assertEquals <span class="java-quote">"The Stand"</span>, model.book.title	
}</pre></div><p class="paragraph">注意上面我们是怎样自定义了一个<code>get</code>方法的实现，让它返回一个模拟的实例，甚至在这个实现中可以使用断言。还要注意我们怎样用map模拟一个<code>params</code> 对象的实例。</p><p class="paragraph"></p><h2><a name="9.2 集成测试">9.2 集成测试</a></h2>集成测试与单元测试的不同在于你在测试中可以完全访问Grails的环境。Grails用一个in-memory HSQLDB 数据库做集成测试,并在每次测试时都清空数据库中所有数据.<p class="paragraph"></p><h4>测试Controller</h4><p class="paragraph">要测试controller你首先要理解Spring Mock库</p><p class="paragraph">实际上，Grails为会每个测试自动配置<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletRequest.html" class="api">MockHttpServletRequest</a>, <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletResponse.html" class="api">MockHttpServletResponse</a>, 和<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpSession.html" class="api">MockHttpSession</a>。你可以用它们运行你的测试。例如下面的controller：</p><p class="paragraph"></p><div class="code"><pre>class FooController {<p class="paragraph">	def text = {
	    render <span class="java-quote">"bar"</span>
	}</p><p class="paragraph">	def someRedirect = {
		redirect(action:<span class="java-quote">"bar"</span>)
	}
}</p></pre></div><p class="paragraph">相应地它的测试将会是:
</p><div class="code"><pre>class FooControllerTests <span class="java-keyword">extends</span> GroovyTestCase {<p class="paragraph">  void testText() {
		def fc = <span class="java-keyword">new</span> FooController()
		fc.text()
		assertEquals <span class="java-quote">"bar"</span>, fc.response.contentAsString
	}</p><p class="paragraph">	void testSomeRedirect() {</p><p class="paragraph">		def fc = <span class="java-keyword">new</span> FooController()
		fc.someRedirect()
		assertEquals <span class="java-quote">"/foo/bar"</span>, fc.response.redirectedUrl
	}
}</p></pre></div><p class="paragraph">在上面例子里，response是<code>MockHttpServletResponse</code> 的一个实例，我们可以用它为这个例子实现<code>contentAsString</code> (当写入到这个response时)或者URL重定向.这些Servlet API的模拟版本不像真实版本，在它们中所有东西都是可变的，所以你可以设置request上的属性，比如<code>contextPath</code>等等。</p><p class="paragraph">在集成测试时，Grails在执行action时 <strong class="bold">不会</strong> 自动调用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.5 控制器拦截器" class="guide">interceptors</a>。你需要在孤立环境中测试拦截器，如果需要可以参考 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#9.3 功能测试" class="guide">functional testing</a> 。</p><p class="paragraph"></p><h4>测试有Service的Controller</h4><p class="paragraph">如果你的控制器引用了一个service,你必须在测试中明确地初始化这个service。</p><p class="paragraph">下面是一个用了service的controller:</p><p class="paragraph"></p><div class="code"><pre>class FilmStarsController {
    def popularityService<p class="paragraph">    def update = {
        // <span class="java-keyword">do</span> something with popularityService
    }
}</p></pre></div><p class="paragraph">它的测试应该是:</p><p class="paragraph"></p><div class="code"><pre>class FilmStarsTests <span class="java-keyword">extends</span> GroovyTestCase {
    def popularityService<p class="paragraph">    <span class="java-keyword">public</span> void testInjectedServiceInController () {
        def fsc = <span class="java-keyword">new</span> FilmStarsController()
        fsc.popularityService = popularityService
        fsc.update()
    }
}</p></pre></div><p class="paragraph"></p><h4>测试controller 命令对象</h4><p class="paragraph">要使用command对象，你只需将参数放入request,然后不带参数执行action方法，它为你自动装配command对象.</p><p class="paragraph">下面是一个使用command对象的controller：</p><p class="paragraph"></p><div class="code"><pre>class AuthenticationController {
  def signup = { SignupForm form -&gt; .. }
}</pre></div><p class="paragraph">
你可以这样测试它:</p><p class="paragraph"></p><div class="code"><pre>def controller = <span class="java-keyword">new</span> AuthenticationController()
controller.params.login = <span class="java-quote">"marcpalmer"</span>
controller.params.password = <span class="java-quote">"secret"</span>
controller.params.passwordConfirm = <span class="java-quote">"secret"</span>
controller.signup()</pre></div><p class="paragraph">Grails会自动把你对<code>signup()</code>的调用看作 作为一个action调用,并将模拟的request参数装配为command对象。在controller测试过程中，Grails提供的模拟request的<code>params</code>是可变的.</p><p class="paragraph"></p><h4>测试controller和render方法</h4><p class="paragraph"><a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a> 方法允许你在action内部任何地方渲染自定义视图。下面看一个示例:</p><p class="paragraph"></p><div class="code"><pre>def save = {
	def book = Book(params)
	<span class="java-keyword">if</span>(book.save()) {
		// handle
	}
	<span class="java-keyword">else</span> {
		render(view:<span class="java-quote">"create"</span>, model:[book:book])
	}
}</pre></div><p class="paragraph">在上面的例子中，action结果中的model不是一个返回值，而是保存在controller的<code>modelAndView</code>属性中。 <code>modelAndView</code> 属性是Spring MVC 的<a href="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/ModelAndView.html" target="blank">ModelAndView</a> 类的一个实例，你可以用它测试action的执行结果:</p><p class="paragraph"></p><div class="code"><pre>def bookController = <span class="java-keyword">new</span> BookController()
bookController.save()
def model = bookController.modelAndView.model.book</pre></div><p class="paragraph"></p><h4>模拟request数据</h4><p class="paragraph">如果你正在测试一个需要request数据的action,比如REST web service,那么你可以用Spring中的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/mock/web/MockHttpServletRequest.html" class="api">MockHttpServletRequest</a> 对象。例如下面这个action它从一个request中获取数据进行绑定:</p><p class="paragraph"></p><div class="code"><pre>def create = {
	[book: <span class="java-keyword">new</span> Book(params['book']) ]	
}</pre></div><p class="paragraph">如果你想把'book'参数模拟为一个XML请求，你可以这么做:</p><p class="paragraph"></p><div class="code"><pre>void testCreateWithXML() {
	def controller = <span class="java-keyword">new</span> BookController()
	controller.request.contentType = 'text/xml'
	controller.request.contents = '''&lt;?xml version=<span class="java-quote">"1.0"</span> encoding=<span class="java-quote">"ISO-8859-1"</span>?&gt;
	&lt;book&gt;
		&lt;title&gt;The Stand&lt;/title&gt;
		…
	&lt;/book&gt;	
	'''.getBytes() // note we need the bytes<p class="paragraph">	def model = controller.create()
	assert model.book
	assertEquals <span class="java-quote">"The Stand"</span>, model.book.title
}</p></pre></div><p class="paragraph">同样的也可以得到一个JSON请求:</p><p class="paragraph"></p><div class="code"><pre>void testCreateWithJSON() {
	def controller = <span class="java-keyword">new</span> BookController()	
 	controller.request.contentType = <span class="java-quote">"text/json"</span>
 	controller.request.content = '{<span class="java-quote">"id"</span>:1,<span class="java-quote">"class"</span>:<span class="java-quote">"Book"</span>,<span class="java-quote">"title"</span>:<span class="java-quote">"The Stand"</span>}'.getBytes()<p class="paragraph">	def model = controller.create()
	assert model.book
	assertEquals <span class="java-quote">"The Stand"</span>, model.book.title</p><p class="paragraph">}</p></pre></div><p class="paragraph"></p><blockquote class="note">
用JSON的话别忘了用 <code>class</code> 指定 要绑定的目标类的名字.在XML中这个隐含地用<code>&lt;book&gt;</code>节点的名字，但是在JSON中你需要把这个属性作为JSON数据包属性的一部分. 
</blockquote><p class="paragraph">关于REST web service主题的更多信息请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#13.1 REST" class="guide">REST</a>这章.</p><p class="paragraph"></p><h4>测试web flow</h4><p class="paragraph">测试<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.5 Web Flow" class="guide">Web Flows</a>要用<code>grails.test.WebFlowTestCase</code>作为基类，这个类是Spring Web Flow中<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/webflow/test/execution/AbstractFlowExecutionTests.html" class="api">AbstractFlowExecutionTests</a>类的一个子类.</p><p class="paragraph"></p><blockquote class="note">
<code>WebFlowTestCase</code> 类的子类必须是集成测试.
</blockquote><p class="paragraph">
比如下面是一个简单流程：</p><p class="paragraph"></p><div class="code"><pre>class ExampleController {
	def exampleFlow = {
		start {
			on(<span class="java-quote">"go"</span>) {
				flow.hello = <span class="java-quote">"world"</span>
			}.to <span class="java-quote">"next"</span>
		}
		next {
			on(<span class="java-quote">"back"</span>).to <span class="java-quote">"start"</span>
			on(<span class="java-quote">"go"</span>).to <span class="java-quote">"end"</span>
		}
		end()
	}	
}</pre></div><p class="paragraph">You need to tell the test harness what to use for the "flow definition". This is done via overriding the abstract <code>getFlow</code>
 你需要重写抽象方法<code>getFlow</code>,指定要用的流程定义。</p><p class="paragraph"></p><div class="code"><pre>class ExampleFlowTests <span class="java-keyword">extends</span> grails.test.WebFlowTestCase {
	def getFlow() { <span class="java-keyword">new</span> ExampleController().exampleFlow }
	…
}</pre></div><p class="paragraph">如果你需要指定流程id,你可以重写getFlowId方法，否则缺省是 <code>test</code>:
</p><div class="code"><pre>class ExampleFlowTests <span class="java-keyword">extends</span> grails.test.WebFlowTestCase {
	<span class="java-object">String</span> getFlowId() { <span class="java-quote">"example"</span> }
	…
}</pre></div><p class="paragraph">一旦上面工作都完成了，你要用<code>startFlow</code>方法开始流程，这个方法返回一个 <code>ViewSelection</code> 对象:</p><p class="paragraph"></p><div class="code"><pre>void testExampleFlow() {
	def viewSelection = startFlow()<p class="paragraph">	assertEquals <span class="java-quote">"start"</span>, viewSelection.viewName
	…
}</p></pre></div><p class="paragraph">正如上面所演示的，你可以用 <code>ViewSelection</code> 对象的<code>viewName</code> 检查你是否在正确的状态。你还需要用<code>signalEvent</code>方法触发事件:</p><p class="paragraph">
</p><div class="code"><pre>void testExampleFlow() {
	…
	viewSelection = signalEvent(<span class="java-quote">"go"</span>)
	assertEquals <span class="java-quote">"next"</span>, viewSelection.viewName
	assertEquals <span class="java-quote">"world"</span>, viewSelection.model.hello
}</pre></div><p class="paragraph">这里我们给流程一个执行事件"go"的信号，这会切换到"next"状态.在这个例子里，这个切换动作将<code>hello</code>变量放入flow范围。我们可以通过检查上面<code>ViewSelection</code>的<code>model</code>属性来测试这个变量的值。</p><p class="paragraph"></p><h4>测试标签库</h4><p class="paragraph">测试标签库实际上非常简单，因为当标签被当作方法调用的时候，它的结果作为字符串返回。所以如果我们有一个这样的标签库:</p><p class="paragraph"></p><div class="code"><pre>class FooTagLib {
   def bar =  { attrs, body -&gt;
   	   out &lt;&lt; <span class="java-quote">"&lt;p&gt;Hello World!&lt;/p&gt;"</span>
   }<p class="paragraph">   def bodyTag =  { attrs, body -&gt;
      out &lt;&lt; <span class="java-quote">"&lt;${attrs.name}&gt;"</span>
           out &lt;&lt; body()
      out &lt;&lt; <span class="java-quote">"&lt;/${attrs.name}&gt;"</span>   	
   }
}</p></pre></div><p class="paragraph">测试是这样的:</p><p class="paragraph"></p><div class="code"><pre>class FooTagLibTests <span class="java-keyword">extends</span> GroovyTestCase {<p class="paragraph">  void testBarTag() {
	   assertEquals <span class="java-quote">"&lt;p&gt;Hello World!&lt;/p&gt;"</span>, <span class="java-keyword">new</span> FooTagLib().bar(<span class="java-keyword">null</span>,<span class="java-keyword">null</span>)
   }</p><p class="paragraph">   void testBodyTag() {
	   assertEquals <span class="java-quote">"&lt;p&gt;Hello World!&lt;/p&gt;"</span>, <span class="java-keyword">new</span> FooTagLib().bodyTag(name:<span class="java-quote">"p"</span>) {
	       <span class="java-quote">"Hello World!"</span> 
       }
    }
}</p></pre></div><p class="paragraph">注意第二个例子，<code>testBodyTag</code>，我们传一个块进去，它返回这个标签的body。这里会方便地将body作为一个字符串.</p><p class="paragraph"></p><h4>用GroovyPagesTestCase测试标签库</h4><p class="paragraph">除了像上面这样简单地测试标签库以外，你也可以用<code>grails.test.GroovyPagesTestCase</code> 来测试标签库.</p><p class="paragraph"><code>GroovyPagesTestCase</code> 是<code>GroovyTestCase</code>类的一个子类，它提供了一些测试GSP输出的工具方法。</p><p class="paragraph"></p><blockquote class="note">
<code>GroovyPagesTestCase</code> 只能用于集成测试.
</blockquote><p class="paragraph">下面是一个日期格式化标签的例子:</p><p class="paragraph"></p><div class="code"><pre>class FormatTagLib {
	def dateFormat = { attrs, body -&gt; 
		out &lt;&lt; <span class="java-keyword">new</span> java.text.SimpleDateFormat(attrs.format) &lt;&lt; attrs.date
	}
}</pre></div><p class="paragraph">可以用下面的方法很容易地测试这个标签:</p><p class="paragraph"></p><div class="code"><pre>class FormatTagLibTests <span class="java-keyword">extends</span> GroovyPagesTestCase {
	void testDateFormat() {
		def template = '&lt;g:dateFormat format=<span class="java-quote">"dd-MM-yyyy"</span> date=<span class="java-quote">"${myDate}"</span> /&gt;'<p class="paragraph">		def testDate = … // create the date
		assertOutputEquals( '01-01-2008', template, [myDate:testDate] )
	}
}</p></pre></div><p class="paragraph">你也可以用<code>GroovyPagesTestCase</code> 类的 <code>applyTemplate</code>方法获得GSP的结果:</p><p class="paragraph"></p><div class="code"><pre>class FormatTagLibTests <span class="java-keyword">extends</span> GroovyPagesTestCase {
	void testDateFormat() {
		def template = '&lt;g:dateFormat format=<span class="java-quote">"dd-MM-yyyy"</span> date=<span class="java-quote">"${myDate}"</span> /&gt;'<p class="paragraph">		def testDate = … // create the date
		def result = applyTemplate( template, [myDate:testDate] )</p><p class="paragraph">		assertEquals '01-01-2008', result
	}
}</p></pre></div><p class="paragraph"></p><h4>测试Domain类</h4><p class="paragraph">测试domain类通常只是简单的测试<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM API</a>的使用，但是有一些事情必须知道。首先，如果你测试查询，你经常需要用"flush"来确保将正确的状态持久化到数据库中。例如下面的例子:</p><p class="paragraph"></p><div class="code"><pre>void testQuery() {
	def books = [ <span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Stand"</span>), <span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Shining"</span>)]
	books*.save()<p class="paragraph">	assertEquals 2, Book.list().size()
}</p></pre></div><p class="paragraph">这个测试将会失败，因为<a href="http://www.kuqin.com/grails-doc-1.0/ref/Domain%20Classes/save.html" class="domainClasses">save</a>调用在被调用后并没有真正持久化 <code>Book</code> 实例。 <code>save</code>调用只是告诉Hibernate在以后某些时候要将这些实例持久化。如果你希望马上提交更改的话你需要"flush"他们:</p><p class="paragraph"></p><div class="code"><pre>void testQuery() {
	def books = [ <span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Stand"</span>), <span class="java-keyword">new</span> Book(title:<span class="java-quote">"The Shining"</span>)]
	books*.save(flush:<span class="java-keyword">true</span>)<p class="paragraph">	assertEquals 2, Book.list().size()
}</p></pre></div><p class="paragraph">这样，因为我们传了一个值为<code>true</code>的<code>flush</code>参数，更新操作立即执行，所以随后的查询是正确的。
</p><h2><a name="9.3 功能测试">9.3 功能测试</a></h2>的支持。<p class="paragraph">用下面的命令开始安装Web Test:</p><p class="paragraph"></p><div class="code"><pre>grails install-plugin webtest</pre></div><p class="paragraph">然后请参考 <a href="http://grails.org/Functional+Testing" target="blank">reference on the wiki</a> ，这里解释了怎样使用Web Test和Grails.
</p><h1><a name="10. 国际化">10. 国际化</a></h1>Grails通过Spring MVC所提供的功能支持国际化（i18n）。在Grails中,你可以根据用户的Locale自定义任意视图中的文本。Java类中<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Locale.html" class="api">Locale</a>的javadoc引用如下：<p class="paragraph"></p><blockquote class="quote">
一个 Locale 对象描述了一个特定地理的、政治的和文化的语言环境。一个要求 Locale 执行的任务操作是 语言环境敏感的 ，它使用 Locale 来为用户裁剪信息。例如，显示一个数字是语言环境敏感的操作--数字应根据用户的国家、地区或文化的风俗/传统来格式化。 
</blockquote><p class="paragraph">Locale是由<a href="http://www.loc.gov/standards/iso639-2/englangn.html" target="blank">语言代码</a> 和 <a href="http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html" target="blank">国家代码</a>组成。例如，"en_US"是美国英语的语言码，而"en_GB"代表英国英语。
</p><h2><a name="10.1 理解信息绑定">10.1 理解信息绑定</a></h2>既然你已经有了Locales的概念，为了在Grails中利用它们，你必须要创建你希望展现的不同语言的信息绑定。Grails的信息绑定是一些简单的Java属性文件,并且位于<code>grails-app/i18n</code>目录下。<p class="paragraph">每一个绑定的名字习惯上都是以 <code>messages</code>开始，并且以locale结束。Grails的 <code>grails-app/i18n</code>目录下自带了很多不同语言的信息绑定。比如：
</p><div class="code"><pre>messages.properties
messages_de.properties
messages_es.properties
etc.</pre></div><p class="paragraph">缺省情况下，Grails将在<code>messages.properties</code>查找信息，除非用户指定了自己的locale。你也可以创建你自己的信息绑定，只需要简单地创建一个属性文件，此文件要以你感兴趣的locale结尾。比如 <code>messages_en_GB.properties</code> 代表的是英国英语。
</p><h2><a name="10.2 改变Locales">10.2 改变Locales</a></h2>缺省情况下，用户的locale是通过HTTP信息头（header）中的 <code>Accept-Language</code>来检测的。但是你也可以简单地在Grails的请求参数中传入 <code>lang</code>参数来切换用户认可的locale，比如：
<div class="code"><pre>/book/list?lang=es</pre></div><p class="paragraph">Grails将自动地切换到用户的locale，并且将其保存在cookie中，因此接下来的请求将使用新的信息头。
</p><h2><a name="10.3 读取信息">10.3 读取信息</a></h2><h4>在视图中读取信息</h4><p class="paragraph">你最需要信息的地方是在视图中，要在视图中读取信息，只需要使用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/message.html" class="tags">message</a>标签：
</p><div class="code"><pre><span class="xml-tag">&lt;g:message code=<span class="xml-quote">"my.localized.content"</span> /&gt;</span></pre></div><p class="paragraph">只要在你的 <code>messages.properties</code> （当然要有适当的locale后缀）中有相应的关键字（如以下所示），Grails将会在其中查找消息：
</p><div class="code"><pre>my.localized.content=Hola, Me llamo John. Hoy es domingo.</pre></div><p class="paragraph">注意，有时候你可能需要传入一些参数给消息，这在 <code>message</code>标签中也是可以做到的，比如：
</p><div class="code"><pre><span class="xml-tag">&lt;g:message code=<span class="xml-quote">"my.localized.content"</span> args=<span class="xml-quote">"${ ['Juan', 'lunes'] }"</span> /&gt;</span></pre></div><p class="paragraph">接下来就可以在消息中使用这些位置参数了：
</p><div class="code"><pre>my.localized.content=Hola, Me llamo {0}. Hoy es {1}.</pre></div><p class="paragraph"></p><h4>在控制器和标签库中读取信息</h4><p class="paragraph">既然你可以在控制器中象调用方法一样调用标签，那也可以很容易的在控制器内读取信息：
</p><div class="code"><pre>def show = {
	def msg = message(code:<span class="java-quote">"my.localized.content"</span>, args:['Juan', 'lunes'])
}</pre></div><p class="paragraph">同理，你也可以在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3 标签库" class="guide">标签库</a>中使用，但是要注意：如果你的标签库有不同的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.3.4 标签命名空间" class="guide">命名空间</a>，你需要加一个前缀 <code>g.</code>：
</p><div class="code"><pre>def myTag = { attrs, body -&gt;
	def msg = g.message(code:<span class="java-quote">"my.localized.content"</span>, args:['Juan', 'lunes'])
}</pre></div>
<h1><a name="11. 安全">11. 安全</a></h1>Grails的安全性既不强于也不弱于Java Servlets的安全性。Java servlets (也即 Grails)对常见的缓存溢出和的非法URL攻击基本上完全免疫，这得益于Java Virtual Machine对Servlet代码在安全性方面的支持。<p class="paragraph">Web的安全性问题通常是由于开发者的幼稚或过失造成的，grails在避免通常的错误方面有少许帮助，从而更容易编写安全的Web应用。</p><p class="paragraph"></p><h4>Grails 自动完成了什么</h4><p class="paragraph">Grails默认的内置安全机制。
</p><ol>
<li>所有通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM</a> 领域对象的数据库访问将自动执行SQL转义来防止SQL注入攻击</li>
<li>默认的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架" class="guide">scaffolding</a>HTML模板在显示的时候将转义所有的数据字段</li>
<li>Grails所有的连接创建标签(<a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/link.html" class="tags">link</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/form.html" class="tags">form</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/createLink.html" class="tags">createLink</a>, <a href="http://www.kuqin.com/grails-doc-1.0/ref/Tags/createLinkTo.html" class="tags">createLinkTo</a> 等等)使用适当的转义机制防止代码注入</li>
<li>Grails提供<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">codecs</a>允许你在渲染HTML，JavaScript和URLs的时候进行简单的数据转义以防止注入攻击</li>
</ol><p class="paragraph"></p><h2><a name="11.1 预防攻击">11.1 预防攻击</a></h2><h4>SQL 注入</h4><p class="paragraph">GORM领域类的底层基于Hibernate技术，在提交数据到数据库时Hibernate会自动执行数据转义，因此SQL注入攻击不是什么问题。然而，使用未检查的请求参数仍然有可能编写出会被SQL注入攻击的动态hql代码。例如，下面的代码很容易受到HQL注入攻击：
</p><div class="code"><pre>def vulnerable = {
	def books = Book.find(<span class="java-quote">"from Book as b where b.title ='"</span> + params.title + <span class="java-quote">"'"</span>)
}</pre></div><p class="paragraph"><strong class="bold">不要</strong>这样做。如果你需要传入参数，请使用命名参数或位置参数作为替代：
</p><div class="code"><pre>def safe = {
	def books = Book.find(<span class="java-quote">"from Book as b where b.title =?"</span>, [params.title])
}</pre></div><p class="paragraph">
</p><h4>网络钓鱼</h4><p class="paragraph">从避免你的品牌和客户被抢走的角度来说，网络钓鱼实际上是一个公共关系问题。客户需要懂得如何识别收到的电子邮件是否合法。</p><p class="paragraph"></p><h4>XSS - 跨网站脚本注入</h4><p class="paragraph">你的应用应该尽可能多的验证请求是来自你自己的Web应用而不是来自另一个网站，这一点非常重要。标签和页面流会对此有所帮助，并且Grails支持的<a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring Web Flow</a> 包括这样的默认安全措施。</p><p class="paragraph">同样重要的是，确保所有的数据被渲染到页面时都能正确的转义。例如，当渲染HTML或者XHTML时，你必须在所有对象上调用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">encodeAsHTML</a>以确保恶意注入Javascript数据或HTML标签不会被执行或显示。为此，Grails提供了几个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">Dynamic Encoding Methods</a> ，假如提供的这些<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">Dynamic Encoding Methods</a> 无法满足你的输出数据的转义格式，你也可以很容易的编写自己的编解码器.</p><p class="paragraph">你还必须避免使用请求参数或数据字段来决定用户的下一个URL重定向。假如，你使用一个<code>successURL</code>参数来决定一个用户成功登陆后将重定向到何处，攻击者可以利用你自己的网站来模仿你的登录程序，之后，一旦用户登陆成功便会重定向到他们的网站，在这个网站上允许潜在的JS代码利用登入进来的帐号。</p><p class="paragraph"></p><h4>HTML/URL 注入</h4><p class="paragraph">这是指在某处提供了非法的数据，导致之后页面上使用该数据创建链接，点击它将不会导致预期的行为，而是可能重定向到另一个网站或者改变请求参数。</p><p class="paragraph">HTML/URL注入问题通过Grails提供的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">codecs</a>很容易被解决掉，并且Grails提供的标签库全部采用了<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#11.2 字符串的编码和解码" class="guide">encodeAsURL</a>。假如创建你自己的标签来产生URLs同样要注意这样来使用它。</p><p class="paragraph"></p><h4>拒绝服务</h4><p class="paragraph">负载平衡器和其他装置在这里可能更有用，但是，也同样涉及到过度查询的问题，例如，攻击者在某处创建一个连接来请求最大结果集合，以至于一个查询造成内存溢出或使系统速度减慢。这里的解决方法是，在把他们传递进动态查询器和其他GORM查询方法之前总是对请求参数做处理。
</p><div class="code"><pre>def safeMax = <span class="java-object">Math</span>.max(params.max?.toInteger(), 100) // never let more than 100 results be returned
<span class="java-keyword">return</span> Book.list(max:safeMax)</pre></div><p class="paragraph"></p><h4>猜测ID</h4><p class="paragraph">许多应用使用URL的最后一部分作为对象的"id"从而通过GORM或者在其它手段查询数据， 。尤其在GORM中，id很容易猜测因为通常情况下他们是有序的整数。</p><p class="paragraph">因此，你必须在响应返回给用户之前，确定请求用户有权限查看带有请求id的对象.</p><p class="paragraph">不要落入"模糊安全性"的陷阱，像有个默认的"letmein"密码等等这样的设置将不可避免的造成"模糊安全性"。</p><p class="paragraph">你必须确保每个不受保护的URL能以这样或那样的方式被公开存取。
</p><h2><a name="11.2 字符串的编码和解码">11.2 字符串的编码和解码</a></h2>Grails支持动态编/解码(dynamic encode/decode)方法的概念。Grails捆绑了一组标准的编解码器（codecs）。Grails还提供了一个简单的机制使得开发人员可以贡献出自己的编解码器，这些编解码器会在运行时被识别。<p class="paragraph"></p><h4>编解码器类</h4><p class="paragraph">一个Grails编解码器类就是一个普通的类，该类可能包含一个编码闭包，一个解码闭包或者两者皆有。当Grails应用启动时，Grails 框架将动态加载来自<code>grails-app/utils/</code>目录中的编解码器。</p><p class="paragraph">Grails框架将在<code>grails-app/utils/</code>中按照规约查找以<code>Codec</code>结尾的类名。例如，Grails标准的编解码器之一<code>HTMLCodec</code>。</p><p class="paragraph">如果一个编解码器包含了一个编码器<code>encode</code>属性，Grails将创建一个动态的编码器方法，然后把该方法加到String类中，该方法的名字将体现编解码器类的名字和编码器闭包的名字，例如 <code>HTMLCodec</code> 类定义了一个编码器<code>encode</code>属性，所以Grails将把编码器对应得闭包关联到String类中，并且使用名字 <code>encodeAsHTML</code> 来表示。</p><p class="paragraph"><code>HTMLCodec</code>和<code>URLCodec</code>类同样定义了 解码器<code>decode</code>，因此Grails也将用名字<code>decodeHTML</code>和<code>decodeURL</code>把这些解码器关联到String类中。动态编解码器方法可以在Grails应用的任何地方调用。考虑这样一个用例，一个report包含一个'description'属性，'description'中可以包含特殊字符，为了在HTML文档中正确的显示，这些特殊字符必须被转义，处理这种情况的一种方法就是在GSP中使用动态编码方法来编码description属性，如下：</p><p class="paragraph"></p><div class="code"><pre>${report.description.encodeAsHTML()}</pre></div><p class="paragraph">解码是通过<code>value.decodeHTML()</code>语法执行的。</p><p class="paragraph"></p><h4>标准编解码器</h4><p class="paragraph"><strong class="bold">HTMLCodec</strong></p><p class="paragraph">这个编解码器执行HTML的转义和反转义，因此数据可以在一个HTML页面中被安全的渲染而无需为此创建任何HTML 标签也不会破坏页面的布局。例如，假定有字符串"Don't you know that 2 &gt; 1?",你不可能安全的在HTML页面中显示它，因为，符号&gt;将被看做是一个关闭标签，当该字符串是在一个属性中时，例如是一个输入字段的值，情况就更加糟糕。</p><p class="paragraph">使用示例：
</p><div class="code"><pre>&lt;input name=<span class="java-quote">"comment.message"</span> value=<span class="java-quote">"${comment.message.encodeAsHTML()}"</span>/&gt;</pre></div><p class="paragraph">
</p><blockquote class="note">
注意，HTML编码不会再编码省略号/单引号，因此，你必须在属性值上使用双引号来避免省略号在页面上干扰你的文本。
</blockquote><p class="paragraph"><strong class="bold">URLCodec</strong></p><p class="paragraph">当创建URL链接或表单动作时，必须进行URL编码。这可以防止URL中包含非法字符，例如，字符串"Apple &amp; Blackberry" 作为GET请求中的参数是会有问题的，因为，字符串中的符号&amp;会破坏参数的解析。</p><p class="paragraph">使用示例：
</p><div class="code"><pre>&lt;a href=<span class="java-quote">"/mycontroller/find?searchKey=${lastSearch.encodeAsURL()}"</span>&gt;Repeat last search&lt;/a&gt;</pre></div><p class="paragraph">
<strong class="bold">Base64Codec</strong></p><p class="paragraph">执行Base64 编/解码功能，使用示例：
</p><div class="code"><pre>Your registration code is: ${user.registrationCode.encodeAsBase64()}</pre></div><p class="paragraph">
<strong class="bold">JavaScript编解码器</strong>
JavaScript编解码器将转义字符串，以便字符串可以作为合法的JavaScript字符串使用。使用示例：
</p><div class="code"><pre>Element.update('${elementId}', '${render(template: <span class="java-quote">"/common/message"</span>).encodeAsJavaScript()}')</pre></div><p class="paragraph">
</p><h4>定制编解码器</h4><p class="paragraph">Web应用可以定义自己的编解码器，Grails会像加载标准的编解码器一样加载他们。一个定制的编解码器类必须定义在 <code>grails-app/utils/</code>目录中，且类名必须以<code>Codec</code>结尾。编解码器可能包含一个静态的编码器属性 <code>static</code> <code>encode</code>，或者一个静态的解码器属性 <code>static</code> <code>decode</code>或者两者皆有。实现编码器或解码器的闭包期望传入一个对象作为参数，编码器或解码器的动态方法将在该对象上调用。例如：
</p><div class="code"><pre>class PigLatinCodec {
  <span class="java-keyword">static</span> encode = { str -&gt;
                                      2） 如果单词以元音开头，则加后缀way。如“apple”变换后为“appleway”。 ）
  }
}</pre></div><p class="paragraph">
当定义好上面的编解码器之后，包含该编解码器的Web应用就可以写下如下的代码：
</p><div class="code"><pre>${lastName.encodeAsPigLatin()}</pre></div><p class="paragraph"></p><h2><a name="11.3 身份验证">11.3 身份验证</a></h2>虽然，当前没有默认的验证机制，因为可能有数以千计的不同方式来实现验证。然而，通过使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.5 控制器拦截器" class="guide">interceptors</a> 或 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.6 过滤器" class="guide">filters</a>可以轻松的实现简单的验证机制。<p class="paragraph">Filters允许你应用一个横跨所有控制器或者横跨一个URI空间的验证。例如。你可以在一个名为<code>grails-app/conf/SecurityFilters.groovy</code>类中创建一组新的filters：
</p><div class="code"><pre>class SecurityFilters {
   def filters = {
       loginCheck(controller:'*', action:'*') {
           before = {
              <span class="java-keyword">if</span>(!session.user &amp;&amp; actionName != <span class="java-quote">"login"</span>) {
                  redirect(controller:<span class="java-quote">"user"</span>,action:<span class="java-quote">"login"</span>)
                  <span class="java-keyword">return</span> <span class="java-keyword">false</span>					
	           }
           }<p class="paragraph">       }
   }
}</p></pre></div><p class="paragraph">这里的<code>loginCheck</code>过滤器在操作（action）被执行之前实施拦截，假如，session中没有用户且操作（action）不是<code>login</code>，则重定向到<code>login</code>操作。</p><p class="paragraph"><code>login</code>操作也很简单：
</p><div class="code"><pre>def login = {
	<span class="java-keyword">if</span>(request.get) render(view:<span class="java-quote">"login"</span>)
	<span class="java-keyword">else</span> {
		def u = User.findByLogin(params.login)
		<span class="java-keyword">if</span>(u) {
			<span class="java-keyword">if</span>(u.password == params.password) {
				session.user = u
				redirect(action:<span class="java-quote">"home"</span>)
			}
			<span class="java-keyword">else</span> {
				render(view:<span class="java-quote">"login"</span>, model:[message:<span class="java-quote">"Password incorrect"</span>])							
			}
		}
		<span class="java-keyword">else</span> {
			render(view:<span class="java-quote">"login"</span>, model:[message:<span class="java-quote">"User not found"</span>])			
		}
	}
}</pre></div>
<h2><a name="11.4 关于安全的插件">11.4 关于安全的插件</a></h2>如果你的需求超出了简单的验证功能，还需要诸如授权，角色等等的高级功能，那么你可能需要考虑使用一个可用的安全性（security）插件.
<h2><a name="11.4.1 Acegi">11.4.1 Acegi</a></h2>Acegi 插件构建在<a href="http://www.acegisecurity.org/" target="blank">Spring Acegi</a> 之上，"Spring Acegi"为各种验证和授权方案提供了灵活，易于扩展的实现框架。<p class="paragraph">Acegi 插件要求你指定URIs和角色之间的映射，该插件提供了一个默认的领域模型来建模用户，授权和请求之间的映射。 查看更多详情请参考<a href="http://grails.org/AcegiSecurity+Plugin" target="blank">wiki文档</a> 
</p><h2><a name="11.4.2 JSecurity">11.4.2 JSecurity</a></h2>然后提供一个<code>accessControl</code>代码块来设置角色，如下例所示：
<div class="code"><pre>class ExampleController <span class="java-keyword">extends</span> JsecAuthBase {
    <span class="java-keyword">static</span> accessControl = {
        // All actions require the 'Observer' role.
        role(name: 'Observer')<p class="paragraph">        // The 'edit' action requires the 'Administrator' role.
        role(name: 'Administrator', action: 'edit')</p><p class="paragraph">        // Alternatively, several actions can be specified.
        role(name: 'Administrator', only: [ 'create', 'edit', 'save', 'update' ])
    }</p><p class="paragraph">    …
}</p></pre></div><p class="paragraph">关于JSecurity插件的更多信息请参考<a href="http://grails.org/JSecurity+Plugin+-+Quick+Start" target="blank">JSecurity Quick Start</a>.
</p><h1><a name="12 插件">12 插件</a></h1>Grails提供了许多扩展点来满足你的扩展，包括从命令行接口到运行时配置引擎。以下章节详细说明了该如何着手来做这些扩展。
<h2><a name="12.1 创建和安装插件">12.1 创建和安装插件</a></h2><h4>创建插件</h4><p class="paragraph">创建一个Grails插件，只需要运行如下命令即可：
</p><div class="code"><pre>grails create-plugin [PLUGIN NAME]</pre></div><p class="paragraph">根据你输入的名字将产生一插件工程。比如你输入<code>grails create-plugin example</code>，系统将创建一个名为<code>example</code>的插件工程。</p><p class="paragraph">除了插件的根目录有一个所谓的“插件描述”的Groovy文件外，其他的跟一般的Grails工程结构完全一样。</p><p class="paragraph">将插件作为一个常规的Grails工程是有好处的，比如你可以马上用以下命令来测试你的插件：
</p><div class="code"><pre>grails run-app</pre></div><p class="paragraph"></p><blockquote class="note">
由于你创建插件默认是没有<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL 映射</a>的，因此控制器并不会马上有效，如果你的插件需要控制器，那要创建<code>grails-app/conf/MyUrlMappings.groovy</code>文件，并且在起始位置增加缺省的映射<code>"/$controller/$action?/$id?"()</code>
</blockquote><p class="paragraph">插件描述文件本身需要符合以<code>GrailsPlugin</code>结尾的惯例，并且将位于插件工程的根目录中。比如：
</p><div class="code"><pre>class ExampleGrailsPlugin {
   def version = 0.1<p class="paragraph">   …
}</p></pre></div><p class="paragraph">所有插件的根目录下边都必须有此类并且还要有效，此类中定义了插件的版本和其他各式各样的可选的插件扩展点的钩子（hooks）--即插件预留的可以扩展的接口。</p><p class="paragraph">通过以下特殊的属性，你还可以提供插件的一些额外的信息：
</p><ul class="star">
<li><code>title</code> - 用一句话来简单描述你的插件</li>
<li><code>author</code> - 插件的作者</li>
<li><code>authorEmail</code> - 插件作者的电子邮箱</li>
<li><code>description</code> - 插件的完整特性描述</li>
<li><code>documentation</code> - 插件文档的URL</li>
</ul><p class="paragraph">以<a href="http://grails.org/Quartz+plugin" target="blank">Quartz Grails 插件</a> 为例：
</p><div class="code"><pre>class QuartzGrailsPlugin {
    def version = <span class="java-quote">"0.1"</span>
    def author = <span class="java-quote">"Sergey Nebolsin"</span>
    def authorEmail = <span class="java-quote">"nebolsin@gmail.com"</span>
    def title = <span class="java-quote">"This plugin adds Quartz job scheduling features to Grails application."</span>
    def description = '''
Quartz plugin allows your Grails application to schedule jobs to be
executed using a specified interval or cron expression. The underlying
system uses the Quartz Enterprise Job Scheduler configured via Spring,
but is made simpler by the coding by convention paradigm.
'''
    def documentation = <span class="java-quote">"http://grails.org/Quartz+plugin"</span><p class="paragraph">   …
}</p></pre></div><p class="paragraph"></p><h4>插件的安装和发布</h4><p class="paragraph">要发布插件，你需要一个命令行窗口，并且进入到插件的根目录，输入：
</p><div class="code"><pre>grails <span class="java-keyword">package</span>-plugin</pre></div><p class="paragraph">这将创建一个<code>grails-</code>+插件名称+版本的zip文件，以先前的example插件为例，这个文件名是<code>grails-example-0.1.zip</code>。<code>package-plugin</code>命令还将生成<code>plugin.xml</code>，在此文件中包含机器可读的插件信息，比如插件的名称、版本、作者等等。</p><p class="paragraph">产生了可以发布的插件文件以后（zip文件），进入到你自己的Grails工程的根目录，输入：
</p><div class="code"><pre>grails install-plugin /path/to/plugin/grails-example-0.1.zip</pre></div><p class="paragraph">如果你的插件放在远程的HTTp服务器上，你也可以这样：
</p><div class="code"><pre>grails install-plugin http://myserver.com/plugins/grails-example-0.1.zip</pre></div><p class="paragraph"></p><h4>在Grails插件的存储仓库（Repository）发布插件</h4><p class="paragraph">更好的发布插件的方式是将其发布到Grails插件的存储仓库，这样通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/list-plugins.html" class="commandLine">list-plugins</a>命令就可以看到你的插件了。
</p><div class="code"><pre>grails list-plugins</pre></div><p class="paragraph">此命令将列出Grails插件存储库的所有插件，当然了也可以用<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/plugin-info.html" class="commandLine">plugin-info</a>来查看指定插件的信息：
</p><div class="code"><pre>grails plugin-info [plugin-name]</pre></div><p class="paragraph">这将输出更多的详细信息，这些信息都是维护在插件描述文件中的。
</p><blockquote class="note">
如果你创建了一个Grails插件并且想发布在官方的存储库中，请联系"G2One 团队"http://www.g2one.com 的成员，他们将为你分配访问的权限。
</blockquote><p class="paragraph">当你有访问Grails插件存储库的权限时，要发行你的插件，只需要简单执行<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/release-plugin.html" class="commandLine">release-plugin</a>即可：
</p><div class="code"><pre>grails release-plugin</pre></div><p class="paragraph">这将自动地将改动提交到SVN和创建标签（svn的tagging），并且通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/list-plugins.html" class="commandLine">list-plugins</a>命令你可以看到这些改动</p><p class="paragraph"></p><h2><a name="12.2 理解插件的结构">12.2 理解插件的结构</a></h2>如前所提到的，一个插件除了包含一个插件描述文件外，几乎就是一个常规的Grails应用。尽管如此，当安装以后，插件的结构还是有些许的差别。比如一个插件目录的结构如下：
<div class="code"><pre>+ grails-app
     + controllers
     + domain
     + taglib
     etc.
 + lib
 + src
     + java
     + groovy
 + web-app
     + js
     + css</pre></div><p class="paragraph">从本质上讲，当一个插件被安装到Grails工程以后，<code>grails-app</code>下边的内容将被拷贝到以<code>plugins/example-1.0/grails-app</code>(以example为例)目录中，这些内容<strong class="bold">不会</strong>被拷贝到工程的源文件主目录，即插件永远不会跟工程的主目录树有任何接口上的关系。</p><p class="paragraph">然而，那些在特定插件目录中<code>web-app</code>目录下的静态资源将会被拷贝到主工程的<code>web-app</code>目录下，比如<code>web-app/plugins/example-1.0/js</code>.</p><p class="paragraph">因此，要从正确的地方引用这些静态资源也就成为插件的责任。比如，你要在GSP中引用一个JavaScript文件，你可以这样：
</p><div class="code"><pre><span class="xml-tag">&lt;g:createLinkTo dir=<span class="xml-quote">"/plugins/example/js"</span> file=<span class="xml-quote">"mycode.js"</span> /&gt;</span></pre></div><p class="paragraph">这样做当然可以，但是当你开发插件并且单独运行插件的时候，将产生相对链接（link）的问题。</p><p class="paragraph">为了应对这种变化即不管插件是单独运行还是在Grails应用中运行，特地新增一个特别的<code>pluginContextPath</code>变量，用法如下：
</p><div class="code"><pre><span class="xml-tag">&lt;g:createLinkTo dir=<span class="xml-quote">"${pluginContextPath}/js"</span> file=<span class="xml-quote">"mycode.js"</span> /&gt;</span></pre></div><p class="paragraph">这样在运行期间<code>pluginContextPath</code>变量将会等价于<code>/</code> 或 <code>/plugins/example</code>，这取决于插件是单独运行还是被安装在Grails应用中。</p><p class="paragraph">在lib和<code>src/java</code>以及<code>src/groovy</code>下的Java、Groovy代码将被编译到当前工程的<code>web-app/WEB-INF/classes</code>下边，因此在运行时也不会出现类找不到的问题。
</p><h2><a name="12.3 提供基础的工件">12.3 提供基础的工件</a></h2><h4>增加新的脚本</h4><p class="paragraph">在插件的scripts目录下可以增加新的Gant相关的脚本：
</p><div class="code"><pre>+ MyPlugin.groovy
   + scripts     &lt;-- additional scripts here
   + grails-app
        + controllers
        + services
        + etc.
    + lib</pre></div><p class="paragraph"></p><h4>增加新的控制器，标签库或者服务</h4><p class="paragraph">在<code>grails-app</code>相关的目录树下，可以增加新的控制器、标签库、服务等，不过要注意：当插件被安装后，将从其被安装的地方加载，而不是被拷贝到当前主应用工程的相应目录。
</p><div class="code"><pre>+ ExamplePlugin.groovy
   + scripts
   + grails-app
        + controllers  &lt;-- additional controllers here
        + services &lt;-- additional services here
        + etc.  &lt;-- additional XXX here
    + lib</pre></div><p class="paragraph"></p><h2><a name="12.4 评估规约">12.4 评估规约</a></h2>在得以继续查看基于规约所能提供的运行时配置以前，有必要了解一下怎样来评估插件的这些基本规约。本质上，每一个插件都有一个隐含的<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a>接口的实例变量：<code>application</code>。<p class="paragraph"><code>GrailsApplication</code>提供了在工程内评估这些规约的方法并且保存着所有类的相互引用，这些类都实现了<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">GrailsClass</a>接口。</p><p class="paragraph">一个<code>GrailsClass</code>代表着一个物理的Grails资源，比如一个控制器或者一个标签库。如果要获取所有<code>GrailsClass</code>实例，你可以这样：
</p><div class="code"><pre>application.allClasses.each { println it.name }</pre></div><p class="paragraph">在<code>GrailsApplication</code>实例中有一些特殊的属性可以方便的操作你感兴趣的人工制品（artefact）类型，比如你要获取所有控制器的类，可以如此：
</p><div class="code"><pre>application.controllerClasses.each { println it.name }</pre></div><p class="paragraph">这些动态方法的规约如下：
</p><ul class="star">
<li><code>*Classes</code> - 获取特定人工制品名称的所有类，比如<code>application.controllerClasses</code>。</li>
<li><code>get*Class</code> - 获取特定人工制品的特定类，比如<code>application.getControllerClass("ExampleController")</code>。</li>
<li><code>is*Class</code> - 如果给定的类是指定的人工制品类型，那么返回true， 比如<code>application.isControllerClass(ExampleController.class)</code>。</li>
<li><code>add*Class</code> - 为给定的人工制品类型新增一个类并且返回新增的<code>GrailsClass</code>实例-比如<code>application.addControllerClass(ExampleController.class)</code></li>
</ul><p class="paragraph"><code>GrailsClass</code>接口本身也提供了很多有用的方法以允许你进一步的评估和了解这些规约，他们包括：
</p><ul class="star">
<li><code>getPropertyValue</code> - 获取给定属性的初始值</li>
<li><code>hasProperty</code> - 如果类含有指定的属性，那么返回true</li>
<li><code>newInstance</code> - 创建一个类的新实例</li>
<li><code>getName</code> - 如果可以的话，返回应用类的逻辑名称，此名称不含后缀部分</li>
<li><code>getShortName</code> - 返回类的简称，不包含包前缀</li>
<li><code>getFullName</code> - 返回应用类的完整名称，包含后缀部分和包的名称</li>
<li><code>getPropertyName</code> - 将类的名称返回为属性名称</li>
<li><code>getLogicalPropertyName</code> - 如果可以的话，返回应用类的逻辑属性名称，此名称不包含后缀部分</li>
<li><code>getNaturalName</code> - 返回属性名称的自然语言的术语（比如将'lastName' 变为 'Last Name'）</li>
<li><code>getPackageName</code> - 返回包的名称</li>
</ul><p class="paragraph">完整的索引请参考 <a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">javadoc API</a>.
</p><h2><a name="12.5 参与构建事件">12.5 参与构建事件</a></h2><h4>安装后进行配置和参与升级操作</h4><p class="paragraph">Grails插件可以在安装完后进行配置并且可以参与应用的升级过程（通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/upgrade.html" class="commandLine">upgrade</a>命令），这是由<code>scripts</code>目录下两个特定名称的脚本来完成的：<code>_Install.groovy</code> 和 <code>_Upgrade.groovy</code>。</p><p class="paragraph"><code>_Install.groovy</code>是在插件安装完成后被执行的，而<code>_Upgrade.groovy</code>是用户每次通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Command%20Line/upgrade.html" class="commandLine">upgrade</a>命令来升级他的应用时被执行的。</p><p class="paragraph">这些是一个普通的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4. 命令行" class="guide">Gant</a>脚本，因此你完全可以使用Gant的强大特性。另外<code>pluginBasedir</code>被加入到Gant的标准变量中，其指向安装插件的根目录。</p><p class="paragraph">以下的<code>_Install.groovy</code>示例脚本将在<code>grails-app</code>目录下创建一个新的目录，并且安装一个配置模板，如下：
</p><div class="code"><pre>Ant.mkdir(dir:<span class="java-quote">"${basedir}/grails-app/jobs"</span>)
Ant.copy(file:<span class="java-quote">"${pluginBasedir}/src/samples/SamplePluginConfiguration.groovy"</span>,
         todir:<span class="java-quote">"${basedir}/grails-app/conf"</span>)<p class="paragraph">// To access Grails home you can use following code:
// Ant.property(environment:<span class="java-quote">"env"</span>)
// grailsHome = Ant.antProject.properties.<span class="java-quote">"env.GRAILS_HOME"</span></p></pre></div><p class="paragraph">
</p><h4>脚本事件</h4><p class="paragraph">将插件和命令行的脚本事件关联起来还是有可能的，这些事件在执行Grails的任务和插件事件的时候被触发。</p><p class="paragraph">比如你希望在更新的时候，显示更新状态（如"Tests passed", "Server running"），并且创建文件或者人工制品。</p><p class="paragraph">一个插件只能通过<code>Events.groovy</code>脚本来监听那些必要的事件。更多详细信息请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#4.3 脚本中的事件" class="guide">脚本中的事件</a>
</p><h2><a name="12.6 参与运行时配置">12.6 参与运行时配置</a></h2>Grails提供了很多的钩子函数来处理系统的不同部分，并且通过惯例的形式来执行运行时配置。<p class="paragraph"></p><h4>跟Grails的Spring配置进行交互</h4><p class="paragraph">首先你可以使用<code>doWithSpring</code>闭包来跟Grails运行时的配置进行交互，例如下面的代码片段是取自于Grails核心插件<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#10. 国际化" class="guide">i18n</a>的一部分：
</p><div class="code"><pre><span class="java-keyword">import</span> org.springframework.web.servlet.i18n.CookieLocaleResolver;
<span class="java-keyword">import</span> org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
<span class="java-keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;<p class="paragraph">class I18nGrailsPlugin {</p><p class="paragraph">	def version = 0.1</p><p class="paragraph">	def doWithSpring = {
		messageSource(ReloadableResourceBundleMessageSource) {
			basename = <span class="java-quote">"WEB-INF/grails-app/i18n/messages"</span>
		}
		localeChangeInterceptor(LocaleChangeInterceptor) {
			paramName = <span class="java-quote">"lang"</span>
		}
		localeResolver(CookieLocaleResolver)
	}
}</p></pre></div><p class="paragraph">)的解析和切换，它是通过<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14. Grails和Spring" class="guide">Spring Bean Builder</a>语法来完成的。</p><p class="paragraph"></p><h4>参与web.xml的生成</h4><p class="paragraph">Grails是在加载的时候生成<code>WEB-INF/web.xml</code>文件，因此插件不能直接修改此文件，但他们可以参与此文件的生成。本质上一个插件可以通过<code>doWithWebDescriptor</code>闭包来完成此功能，此闭包的参数是<code>web.xml</code>，是作为<code>XmlSlurper</code> <code>GPathResult</code>类型传入的。</p><p class="paragraph">考虑如下来自<code>ControllersPlugin</code>的示例：
</p><div class="code"><pre>def doWithWebDescriptor = { webXml -&gt;
	def mappingElement = webXml.'servlet-mapping'
	mappingElement + {
		'servlet-mapping' {
			'servlet-name'(<span class="java-quote">"grails"</span>)
			'url-pattern'(<span class="java-quote">"*.dispatch"</span>)
		}
	}
}</pre></div><p class="paragraph">此处插件得到最后一个 <code>&lt;servlet-mapping&gt;</code>元素的引用，并且在其后添加Grails' servlet，这得益于XmlSlurper可以通过闭包以编程的方式修改XML的能力。</p><p class="paragraph"></p><h4>在初始化完毕后进行配置</h4><p class="paragraph">有时候在Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>被创建以后做一些运行时配置是有意义的，这种情况下，你可以定义<code>doWithApplicationContext</code>闭包，如下例：
</p><div class="code"><pre>class SimplePlugin {
     def name=<span class="java-quote">"simple"</span>
     def version = 1.1<p class="paragraph">	 def doWithApplicationContext = { appCtx -&gt;
          SessionFactory sf = appCtx.getBean(<span class="java-quote">"sessionFactory"</span>)
          // <span class="java-keyword">do</span> something here with session factory
	 }
}</p></pre></div><p class="paragraph"></p><h2><a name="12.7 运行时添加动态方法">12.7 运行时添加动态方法</a></h2><h4>基础知识</h4><p class="paragraph">Grails插件允许你在运行时注册Grails管辖类或者其他类的动态方法，但新的方法只能通过<code>doWithDynamicMethods</code>闭包来增加。</p><p class="paragraph">对Grails管辖类来说，比如controllers、tag libraries等等，你可以增加方法，构造函数等，这是通过<a href="http://groovy.codehaus.org/ExpandoMetaClass" target="blank">ExpandoMetaClass</a> 机制做到的，比如访问每个控制器的<a href="api:http://groovy.codehaus.org/api/groovy/lang/MetaObjectProtocol.html" target="blank">MetaClass</a>的代码如下所示：
</p><div class="code"><pre>class ExamplePlugin {
  def doWithDynamicMethods = { applicationContext -&gt;
        application.controllerClasses.metaClass.each { metaClass -&gt;
             metaClass.myNewMethod = {-&gt; println <span class="java-quote">"hello world"</span> }
        }
  }
}</pre></div><p class="paragraph">此处我们通过隐含的application对象来获取所有控制器类的MetaClass实例，并且为每一个控制器增加一个<code>myNewMethod</code>的方法。</p><p class="paragraph">或者，你已经知道要处理的类的类型了，那你只需要在此类的<code>metaClass</code>属性上增加一个方法即可，代码如下：
</p><div class="code"><pre>class ExamplePlugin {<p class="paragraph">  def doWithDynamicMethods = { applicationContext -&gt;
      <span class="java-object">String</span>.metaClass.swapCase = {-&gt;
           def sb = <span class="java-keyword">new</span> <span class="java-object">StringBuffer</span>()
           delegate.each {
               sb &lt;&lt; (<span class="java-object">Character</span>.isUpperCase(it as <span class="java-object">char</span>) ? 
                      <span class="java-object">Character</span>.toLowerCase(it as <span class="java-object">char</span>) : 
                      <span class="java-object">Character</span>.toUpperCase(it as <span class="java-object">char</span>))
           }
           sb.toString()
      }</p><p class="paragraph">      assert <span class="java-quote">"UpAndDown"</span> == <span class="java-quote">"uPaNDdOWN"</span>.swapCase()       
  }
}</p></pre></div><p class="paragraph">此例中，我们直接在<code>java.lang.String</code>的<code>metaClass</code>上增加一个新的<code>swapCase</code>方法</p><p class="paragraph"></p><h4>跟ApplicationContext交互</h4><p class="paragraph"><code>doWithDynamicMethods</code>闭包的参数是Spring的<code>ApplicationContext</code>实例，这点非常有用，因为这允许你和该应用上下文实例中的对象进行交互。比如你打算实现一个跟Hibernate交互的方法，那你可以联合着<code>HibernateTemplate</code>来使用<code>SessionFactory</code>实例，代码如下：
</p><div class="code"><pre><span class="java-keyword">import</span> org.springframework.orm.hibernate3.HibernateTemplate<p class="paragraph">class ExampleHibernatePlugin {</p><p class="paragraph">   def doWithDynamicMethods = { applicationContext -&gt;</p><p class="paragraph">       application.domainClasses.metaClass.each { metaClass -&gt;</p><p class="paragraph">           metaClass.<span class="java-keyword">static</span>.load = { <span class="java-object">Long</span> id-&gt; 
                def sf = applicationContext.sessionFactory
                def template = <span class="java-keyword">new</span> HibernateTemplate(sf)
				template.load(delegate, id)
           }
       }
   }
}</p></pre></div><p class="paragraph">另外因为Spring容器具有自动装配和依赖注入的能力，你可以在运行时实现更强大的动态构造器，此构造器使用applicationContext来装配你的对象及其依赖：
</p><div class="code"><pre>class MyConstructorPlugin {<p class="paragraph">    def doWithDynamicMethods = { applicationContext -&gt;
         application.domainClasses.each { domainClass -&gt;
              domainClass.metaClass.constructor = {-&gt;
                  <span class="java-keyword">return</span> applicationContext.getBean(domainClass.name)
              }
         }</p><p class="paragraph">    }
}</p></pre></div><p class="paragraph">这里我们实际做的是通过查找Spring的原型beans（prototyped beans）来替代缺省的构造器。
</p><h2><a name="12.8 参与自动重载">12.8 参与自动重载</a></h2><h4>监控资源的改变</h4><p class="paragraph">通常来讲，当资源发生改变的时候，监控并且重新加载这些变化是非常有意义的。这也是Grails为什么要在运行时实现复杂的应用程序重新加载。查看如下Grails的<code>ServicesPlugin</code>的一段简单的代码片段：
</p><div class="code"><pre>class ServicesGrailsPlugin {
    …
    def watchedResources = <span class="java-quote">"file:./grails-app/services/*Service.groovy"</span><p class="paragraph">    …
  def onChange = { event -&gt;
    <span class="java-keyword">if</span>(event.source) {
      def serviceClass = application.addServiceClass(event.source)
      def serviceName = <span class="java-quote">"${serviceClass.propertyName}"</span>
      def beans = beans {
           <span class="java-quote">"$serviceName"</span>(serviceClass.getClazz()) { bean -&gt;
               bean.autowire =  <span class="java-keyword">true</span>
      }
      <span class="java-keyword">if</span>(event.ctx) {
        event.ctx.registerBeanDefinition(serviceName,
                                       beans.getBeanDefinition(serviceName))
      }
    }
  }
}</p></pre></div><p class="paragraph">首先定义了<code>watchedResources</code>集合，此集合可能是String或者String的List，包含着要监控的资源的引用或者模式。如果要监控的资源是Groovy文件，那当它被改变的时候，此文件将会自动被重新加载，而且被传给 <code>onChange</code>闭包的参数 <code>event</code>。</p><p class="paragraph"><code>event</code>对象定义了一些有益的属性：
</p><ul class="star">
<li><code>event.source</code> - The source of the event which is either the reloaded class or a Spring Resource</li>
<li><code>event.ctx</code> - The Spring <code>ApplicationContext</code> instance</li>
<li><code>event.plugin</code> - The plugin object that manages the resource (Usually this)</li>
<li><code>event.application</code> - The <code>GrailsApplication</code> instance</li>
<li><code>event.application</code> - <code>GrailsApplication</code>实例</li>
</ul><p class="paragraph">通过这些对象，你可以评估这些惯例,而且基于这些惯例你可以将这些变化适当的应用到<code>ApplicationContext</code>中。在上述的"Services"示例中，当一个service类变化时，一个新的service类被重新注册到 <code>ApplicationContext</code>中。</p><p class="paragraph"></p><h4>影响其他插件</h4><p class="paragraph">当一个插件变化时，插件不但要有相应地反应，而且有时还会“影响”另外的插件。</p><p class="paragraph">以Services 和 Controllers插件为例，当一个service被重新加载的时候，除非你也重新加载controllers，否则你将加载过的service自动装配到旧的controller类的时候，将会发生问题。</p><p class="paragraph">为了避免这种情况发生，你可以指定将要受到“影响”的另外一个插件，这意味着当一个插件监测到改变的时候，它将先重新加载自身，然后重新加载它所影响到的所有插件。看<code>ServicesGrailsPlugin</code>的代码片段：
</p><div class="code"><pre>def influences = ['controllers']</pre></div><p class="paragraph"></p><h4>观察其他插件</h4><p class="paragraph">如果你想观察一个特殊的插件的变化但又不需要监视插件的资源，那你可以使用"observe"属性：
</p><div class="code"><pre>def observe = [<span class="java-quote">"hibernate"</span>]</pre></div><p class="paragraph">在此示例中，当一个Hibernate的领域类变化的时候，你将收到从hibernate插件传递过来的事件。
</p><h2><a name="12.9 理解插件加载的顺序">12.9 理解插件加载的顺序</a></h2>插件经常依赖于其他已经存在的插件，并且也能调整这种依赖。为了做到这点，一个插件可以定义两个属性，首先是dependsOn。让我们看看Grails Hibernate插件的代码片段：
<div class="code"><pre>class HibernateGrailsPlugin {
	def version = 1.0
	def dependsOn = [dataSource:1.0,
	                 domainClass:1.0,
	                 i18n:1.0,
	                 core: 1.0]<p class="paragraph">}</p></pre></div><p class="paragraph">如上述示例所演示的，Hibernate插件依赖于4个插件：<code>dataSource</code>,<code>domainClass</code>, <code>i18n</code>,以及 <code>core</code>。</p><p class="paragraph">根本上讲，这些被依赖的插件将先被加载，接着才是Hibernate插件，如果这些被依赖的插件没有加载，那么Hibernate也不会加载。</p><p class="paragraph">如果所依赖的插件不能被解析的话，则依赖于此的插件将被放弃并且不会被加载，这就是所谓的“强”依赖。然而我们可以通过使用 <code>loadAfter</code>来定义一个“弱”依赖，示例如下：
</p><div class="code"><pre>def loadAfter = ['controllers']</pre></div><p class="paragraph">此处如果<code>controllers</code>插件存在的话，插件将在<code>controllers</code>之后被加载，否则的话将被单独加载。插件也可以适应于其他已存在的插件，以Hibernate插件的 <code>doWithSpring</code>闭包代码为例：
</p><div class="code"><pre><span class="java-keyword">if</span>(manager?.hasGrailsPlugin(<span class="java-quote">"controllers"</span>)) {
	openSessionInViewInterceptor(OpenSessionInViewInterceptor) {
        	flushMode = HibernateAccessor.FLUSH_MANUAL
	        sessionFactory = sessionFactory
	}
        grailsUrlHandlerMapping.interceptors &lt;&lt; openSessionInViewInterceptor
  }</pre></div><p class="paragraph">这里，<code>controllers</code>插件如果被加载的话，Hibernate插件仅仅注册一个 <code>OpenSessionInViewInterceptor。变量manager是<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/plugins/GrailsPluginManager.html" class="api">GrailsPluginManager</a>接口的一个实例，并且提供同其他插件交互的方法，而且 </code>GrailsPluginManager@本身存在与任何一个插件中。
</p><h1><a name="13. Web服务">13. Web服务</a></h1>Web服务可以让你的Web应用提供web API，一般来说是通过<a href="http://en.wikipedia.org/wiki/SOAP" target="blank">SOAP</a> 或者 <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="blank">REST</a> 实现的。
<h2><a name="13.1 REST">13.1 REST</a></h2>REST与其说是一种技术还不如说是一个构架模式。REST是极其简单的，使用普通的XML或者JSON来作为通信媒介，使表现底层系统的URL模式和HTTP方法（ GET, PUT, POST和DELETE）结合在一起。<p class="paragraph">每一种HTTP方法对应于一个动作（action），比如GET用来获取数据，PUT用来创建数据，POST用来更新数据等等，从这种意义上来说，REST跟<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架" class="guide">CRUD</a>正好般配。</p><p class="paragraph"></p><h4>URL模式</h4><p class="paragraph">用Grails实现REST的第一步是提供一个RESTful的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4 URL映射" class="guide">URL映射</a>，如下：
</p><div class="code"><pre><span class="java-keyword">static</span> mappings = {
   <span class="java-quote">"/product/$id?"</span>(controller:<span class="java-quote">"product"</span>){
       action = [GET:<span class="java-quote">"show"</span>, PUT:<span class="java-quote">"update"</span>, DELETE:<span class="java-quote">"delete"</span>, POST:<span class="java-quote">"save"</span>]
   }	
}</pre></div><p class="paragraph">此处为了给控制器提供RESTful API，我们利用了URL映射（Mapping）的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.4.5 映射到HTTP方法" class="guide">映射到HTTP方法</a>，每个HTTP方法比如GET，PUT，POST和DELETE都映射到控制器的唯一动作（action）。</p><p class="paragraph"></p><h4>XML列集 - 读取</h4><p class="paragraph">控制器本身就可以通过Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.7 XML和JSON响应" class="guide">XML列集</a> 来支持GET方法，代码如下：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.converters.*
class ProductController {
	def show = {
		<span class="java-keyword">if</span>(params.id &amp;&amp; Product.exists(params.id)) {
			def p = Product.findByName(params.id)
			render p as XML
		}
		<span class="java-keyword">else</span> {
			def all = Product.list()
			render all as XML
		}
	}
	..
}</pre></div><p class="paragraph">此处我们所做的是：如果params中有<code>id</code>，那我们将根据name来查找<code>Product</code>，并将其返回；否则我们将返回所有的<code>Product</code>。这样如果我们访问<code>/products</code>将会得到所有的产品，而通过<code>/product/MacBook</code>访问，我们将得到MacBook</p><p class="paragraph"></p><h4>XML列集 - 更新</h4><p class="paragraph">Grails是通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象来支持象<code>PUT</code>和<code>POST</code>这样的REST更新的，params对象能够读取传入的XML信息包。一个传入的XML信息包可以如下所示：
</p><div class="code"><pre><span class="xml-tag">&lt;?xml version=<span class="xml-quote">"1.0"</span> encoding=<span class="xml-quote">"ISO-8859-1"</span>?&gt;</span>
<span class="xml-tag">&lt;product&gt;</span>
	<span class="xml-tag">&lt;name&gt;</span>MacBook<span class="xml-tag">&lt;/name&gt;</span>
	<span class="xml-tag">&lt;vendor id=<span class="xml-quote">"12"</span>&gt;</span>
		<span class="xml-tag">&lt;name&gt;</span>Apple<span class="xml-tag">&lt;/name&gt;</span>
     <span class="xml-tag">&lt;/vender&gt;</span>
<span class="xml-tag">&lt;/product&gt;</span></pre></div><p class="paragraph">你可以通过<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/params.html" class="controllers">params</a>对象来读取XML信息包，相关的技术描述请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.6 数据绑定" class="guide">数据绑定</a>一节
</p><div class="code"><pre>def save = {
	def p = <span class="java-keyword">new</span> Product(params['product'])<p class="paragraph">	<span class="java-keyword">if</span>(p.save()) {
		render p as XML
	}
	<span class="java-keyword">else</span> {
		def errors = p.errors.allErrors.collect { g.message(error:it) }
		render(contentType:<span class="java-quote">"text/xml"</span>) {
			error {
				<span class="java-keyword">for</span>(err in errors) {
					message(error:err)
				}
			}
		}
	}
}</p></pre></div><p class="paragraph">此例中，通过检索<code>params</code>对象的关键字<code>'product'</code>，我们可以创建并将XML绑定到<code>Product</code>。关注一下这行：
</p><div class="code"><pre>def p = <span class="java-keyword">new</span> Product(params['product'])</pre></div>
看起来处理XML请求的代码跟处理提交表格（submits form）的数据没有什么变化，类似的技术也可以应用在JSON请求中。
<blockquote class="note">
如果你需要不同的响应来满足不同的客户端（REST, HTML等），那你可以使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.8 内容协商" class="guide">内容协商</a>
</blockquote><p class="paragraph">最后<code>Product</code>对象被成功保存后被render为XML，否则将产生一个被Grails校验的错误信息。
</p><div class="code"><pre><span class="xml-tag">&lt;error&gt;</span>
   <span class="xml-tag">&lt;message&gt;</span>The property 'title' of class 'Person' must be specified<span class="xml-tag">&lt;/message&gt;</span>
<span class="xml-tag">&lt;/error&gt;</span></pre></div> 
<h2><a name="13.2 SOAP">13.2 SOAP</a></h2>Grails是通过<a href="http://xfire.codehaus.org/" target="blank">XFire</a> 插件来支持SOAP的，此插件基于非常流行的XFire SOAP协议栈。XFire插件通过一个特殊的 <code>expose</code> 属性，可以将Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#8. 服务层" class="guide">服务</a>导出为SOAP服务，代码如下：
<div class="code"><pre>class BookService {<p class="paragraph">  <span class="java-keyword">static</span> expose=['xfire']</p><p class="paragraph">  Book[] getBooks(){
    Book.list() as Book[]
  }
}</p></pre></div><p class="paragraph">可以通过ULR <code>http://127.0.0.1:8080/your_grails_app/services/book?wsdl</code> 来访问其WSDL。</p><p class="paragraph">更多XFire插件的信息请参考知识库（wiki）的<a href="http://grails.org/XFire+plugin" target="blank">XFire插件文档</a>。
</p><h2><a name="13.3 RSS和Atom">13.3 RSS和Atom</a></h2>Grails并没有对RSS或者Atom提供直接支持。你可以通过控制器<a href="http://www.kuqin.com/grails-doc-1.0/ref/Controllers/render.html" class="controllers">render</a>方法的XML能力来构造RSS或者ATOM。尽管如此，还是有一个<a href="http://docs.codehaus.org/display/GRAILS/Feeds+Plugin" target="blank">Feeds 插件</a> (基于流行的 <a href="https://rome.dev.java.net/">ROME</a> 开发库)来为Grails提供RSS和Atom的生成器
<div class="code"><pre>def feed = {
    render(feedType:<span class="java-quote">"rss"</span>, feedVersion:<span class="java-quote">"2.0"</span>) {
        title = <span class="java-quote">"My test feed"</span>
        link = <span class="java-quote">"http://your.test.server/yourController/feed"</span><p class="paragraph">        Article.list().each() {
            entry(it.title) {
                link = <span class="java-quote">"http://your.test.server/article/${it.id}"</span>
                it.content // <span class="java-keyword">return</span> the content
            }
        }
    }
}</p></pre></div>
<h1><a name="14. Grails和Spring">14. Grails和Spring</a></h1>此章节是为Grails的高级用户准备的，此类用户对Grails如何与 <a href="http://www.springframework.org/" target="blank">Spring Framework</a> 集成和构建很感兴趣，另外对于考虑在运行期间(runtime)配置Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12 插件" class="guide">插件开发者</a>也很有裨益。
<h2><a name="14.1 Grails的支柱">14.1 Grails的支柱</a></h2>Grails实际上是<a href="http://www.springframework.org/docs/MVC-step-by-step/Spring-MVC-step-by-step.html" target="blank">Spring MVC</a>应用的包装，而Spring MVC又是建在Spring之上的基于MVC的Web应用框架。虽然Spring MVC跟Structs等框架在易用性方面都不尽如人意，但Spring MVC有着极好的设计架构，对Grails来说，Spring MVC是一个可以基于其上进行开发的完美框架。<p class="paragraph">Grails在以下领域对Spring MVC进行取舍：
</p><ul class="star">
<li>基本的控制器逻辑 - Grails继承了Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/DispatcherServlet.html" class="api">DispatcherServlet</a>类并且将请求转给Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1 控制器" class="guide">控制器</a>。</li>
<li>数据的绑定和验证 - Grails的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7. 验证" class="guide">验证</a>和<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.1.6 数据绑定" class="guide">数据绑定</a>都是Spring所提供的。</li>
<li>运行时配置 - Grails的全部基于系统的运行时约定都是通过Spring的<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a>整合起来的。</li>
<li>事务 - Grails在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM</a>中使用Spring的事务管理。</li>
</ul><p class="paragraph">换句话说，Grails自始至终使用内嵌的Spring来处理</p><p class="paragraph"></p><h4>Grails的ApplicationContext</h4><p class="paragraph">Spring的开发者往往很热切地想了解Grails的 <code>ApplicationContext</code> 是如何构造的，下面就介绍一下基础知识。
</p><ul class="star">
<li>Grails的父 <code>ApplicationContext</code> 是从 <code>web-app/WEB-INF/applicationContext.xml</code> 中构造的。 <code>ApplicationContext</code> 创建了<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a>实例和<a href="http://www.kuqin.com/grails-doc-1.0/api/org/codehaus/groovy/grails/plugins/GrailsPluginManager.html" class="api">GrailsPluginManager</a>。</li>
<li>将上述的 <code>ApplicationContext</code> 作为Grails的父bean，不仅可以用 <code>GrailsApplication</code> 实例来分析Grails的约定，而且还可以创建子 <code>ApplicationContext</code> 作为web应用的根 <code>ApplicationContext</code> 。</li>
</ul><p class="paragraph"></p><h4>配置的Spring Beans</h4><p class="paragraph">大多数的Grails配置是发生在运行时的。每一个<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12 插件" class="guide">插件</a>都可以将配置好的Spring beans注册到 <code>ApplicationContext</code>中。一个引用需要配置哪些beans，请参考引用指南，在那里有每个Grails插件的描述和哪些beans需要配置。
</p><h2><a name="14.2 配置其他Bean">14.2 配置其他Bean</a></h2><h4>使用XML</h4><p class="paragraph">可以将Bean配置在你Grails工程的 <code>grails-app/conf/spring/resources.xml</code> 文件中，此文件是一典型的Spring XML文件，具体描述详见<a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-basics" target="blank">最佳参考</a>，作为一个入门级示例，你可以象下面示例那样进行配置：
</p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"myBean"</span> class=<span class="xml-quote">"my.company.MyBeanImpl"</span>&gt;</span><span class="xml-tag">&lt;/bean&gt;</span></pre></div><p class="paragraph">一旦配置好bean，比如此处的 <code>myBean</code>，此bean将会自动装配在Grails应用的大多数类型中，比如控制器（controlers），标签库（tag libraris），服务（services）等等，在控制器中用法如下：
</p><div class="code"><pre>class ExampleController {<p class="paragraph">     def myBean
}</p></pre></div><p class="paragraph"></p><h4>引用已经存在的Beans</h4><p class="paragraph">
声明在 <code>resources.xml</code> 里的Beans也可以引用Grails的约定类。比如你需要在bean中引用一个 <code>BookService</code> 这样的服务，你只需要用一个属性名来表达相应的类名就可以了，此示例中 <code>BookService</code> 的名称是 <code>bookService</code>，代码如下：
</p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"myBean"</span> class=<span class="xml-quote">"my.company.MyBeanImpl"</span>&gt;</span>
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"bookService"</span> ref=<span class="xml-quote">"bookService"</span> /&gt;</span>	
<span class="xml-tag">&lt;/bean&gt;</span></pre></div><p class="paragraph">bean本身当然需要一个公共的setter方法，在Groovy中可以这样定义：
</p><div class="code"><pre><span class="java-keyword">package</span> my.company
class MyBeanImpl {
	BookService bookService
}</pre></div><p class="paragraph">或者在Java这样定义：
</p><div class="code"><pre><span class="java-keyword">package</span> my.company;
class MyBeanImpl {
	<span class="java-keyword">private</span> BookService bookService;
	<span class="java-keyword">public</span> void setBookService(BookService theBookService) {
		<span class="java-keyword">this</span>.bookService = theBookService;
	}
}</pre></div><p class="paragraph">因为Grails的许多配置是在运行时通过约定进行的，因此很多的beans不需要到处声明定义，而且这样也不影响在你的Spring配置中引用它们。例如你需要引用Grails的 <code>DataSource</code> ，你可以这样做：
</p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"myBean"</span> class=<span class="xml-quote">"my.company.MyBeanImpl"</span>&gt;</span>
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"bookService"</span> ref=<span class="xml-quote">"bookService"</span> /&gt;</span>	
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"dataSource"</span> ref=<span class="xml-quote">"dataSource"</span> /&gt;</span>
<span class="xml-tag">&lt;/bean&gt;</span></pre></div><p class="paragraph">或者你需要Hibernate的<code>SessionFactory</code>，下面代码将适合你：
</p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"myBean"</span> class=<span class="xml-quote">"my.company.MyBeanImpl"</span>&gt;</span>
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"bookService"</span> ref=<span class="xml-quote">"bookService"</span> /&gt;</span>	
	<span class="xml-tag">&lt;property name=<span class="xml-quote">"sessionFactory"</span> ref=<span class="xml-quote">"sessionFactory"</span> /&gt;</span>
<span class="xml-tag">&lt;/bean&gt;</span></pre></div><p class="paragraph">关于有效的完整的beans引用，请看本参考指南的插件部分。</p><p class="paragraph"></p><h4>使用Spring DSL</h4><p class="paragraph">如果你想使用Grails提供的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.3 通过Beans DSL运行Spring" class="guide">Spring DSL</a>，那你需要创建<code>grails-app/conf/spring/resources.groovy</code>文件并且定义一个称之为 <code>beans</code> 的方法，其代码块如下：
</p><div class="code"><pre>beans {
	// beans here
}</pre></div><p class="paragraph">上述XML示例配置用DSL表示如下：
</p><div class="code"><pre>beans {
	myBean(my.company.MyBeanImpl) {
		bookService = ref(<span class="java-quote">"bookService"</span>)
	}	
}</pre></div><p class="paragraph">用这种方式的主要优点是你可以在bean的定义中混入业务逻辑，比如基于<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.2 环境" class="guide">environment</a>的示例如下：
</p><div class="code"><pre><span class="java-keyword">import</span> grails.util.*
beans {
	<span class="java-keyword">switch</span>(GrailsUtil.environment) {
		<span class="java-keyword">case</span> <span class="java-quote">"production"</span>:
			myBean(my.company.MyBeanImpl) {
				bookService = ref(<span class="java-quote">"bookService"</span>)
			}<p class="paragraph">		<span class="java-keyword">break</span>
		<span class="java-keyword">case</span> <span class="java-quote">"development"</span>:
			myBean(my.company.mock.MockImpl) {
				bookService = ref(<span class="java-quote">"bookService"</span>)
			}	
		<span class="java-keyword">break</span>
	}	
}</p></pre></div><p class="paragraph"></p><h2><a name="14.3 通过Beans DSL运行Spring">14.3 通过Beans DSL运行Spring</a></h2>Spring非常强大，但是基于XML的语法却是非常的繁琐而且直接违反了DRY（不要重复自己）原则，这种状况在Spring2.0中也没有好转。Grails的Bean生成器就是为了简化那些以Spring为核心的bean的组装。<p class="paragraph">此外，Spring的常规配置（使用XML）是静态的因此很难在运行时修改和配置，而通过程序创建XML则繁琐且容易出错。Grails的<a href="http://www.kuqin.com/grails-doc-1.0/api/grails/spring/BeanBuilder.html" class="api">BeanBuilder</a>使得通过程序在运行时组装组件成为可能，而且还可以让你的逻辑能根据系统属性或者环境变量做相应的调整。</p><p class="paragraph">这将使代码随环境而变成为可能，同时避免了不必要的重复（对于测试、开发和上线产品等不同环境来说，就要有不同的Spring配置）。</p><p class="paragraph"></p><h4>BeanBuilder类</h4><p class="paragraph">Grails通过<a href="http://www.kuqin.com/grails-doc-1.0/api/grails/spring/BeanBuilder.html" class="api">grails.spring.BeanBuilder</a>类和Groovy动态语言来定义bean。其基本用法如下：
</p><div class="code"><pre><span class="java-keyword">import</span> org.apache.commons.dbcp.BasicDataSource
<span class="java-keyword">import</span> org.codehaus.groovy.grails.orm.hibernate.ConfigurableLocalSessionFactoryBean;
<span class="java-keyword">import</span> org.springframework.context.ApplicationContext;<p class="paragraph">def bb = <span class="java-keyword">new</span> grails.spring.BeanBuilder()</p><p class="paragraph">bb.beans {
	dataSource(BasicDataSource) {
		driverClassName = <span class="java-quote">"org.hsqldb.jdbcDriver"</span>
		url = <span class="java-quote">"jdbc:hsqldb:mem:grailsDB"</span>
		username = <span class="java-quote">"sa"</span>
		password = <span class="java-quote">""</span>
	}
        sessionFactory(ConfigurableLocalSessionFactoryBean) {
              dataSource = dataSource
              hibernateProperties = [ <span class="java-quote">"hibernate.hbm2ddl.auto"</span>:<span class="java-quote">"create-drop"</span>,
                                      <span class="java-quote">"hibernate.show_sql"</span>:<span class="java-keyword">true</span>  ]
        }</p><p class="paragraph">}</p><p class="paragraph">ApplicationContext appContext = bb.createApplicationContext()</p></pre></div><p class="paragraph"></p><blockquote class="note">
在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#12 插件" class="guide">插件</a>和 <a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#14.2 配置其他Bean" class="guide">grails-app/conf/spring/resources.groovy</a>中，你不需要创建一个 <code>BeanBuilder</code> 实例，因为该实例已经在各自的 <code>doWithSpring</code> 和 <code>beans</code> 代码块中创建了。
</blockquote><p class="paragraph">上述的示例展示了如何通过 <code>BeanBuilder</code> 类来配置合适的数据源。</p><p class="paragraph">本质上，每一个方法调用（如上例中的 <code>dataSource</code> 和 <code>sessionFactory</code>）将映射到Srping的bean名称，而且方法的第一个参数是bean所对应的类，而最后一个参数是代码块。在代码块中，你可以用标准的Groovy语法来设置bean的属性。</p><p class="paragraph">Bean的引用是通过bean的名称来自动解析的。上面代码中的 <code>sessionFactory</code> 解析 <code>dataSource</code> 就是一个很好的例子。</p><p class="paragraph">某些特定的跟bean管理相关的属性也可以通过生成器构造，比如以下代码：
</p><div class="code"><pre>sessionFactory(ConfigurableLocalSessionFactoryBean) { bean -&gt;
    bean.autowire = 'byName'       // Autowiring behaviour. The other option is 'byType'. [autowire]
    bean.initMethod = 'init'       // Sets the initialisation method to 'init'. [init-method]
    bean.destroyMethod = 'destroy' // Sets the destruction method to 'destroy'. [destroy-method]
    dataSource = dataSource
    hibernateProperties = [ <span class="java-quote">"hibernate.hbm2ddl.auto"</span>:<span class="java-quote">"create-drop"</span>,
                            <span class="java-quote">"hibernate.show_sql"</span>:<span class="java-keyword">true</span>  ]
}</pre></div><p class="paragraph">中括号中的字符串跟Spring的XML配置中定义的bean属性名称是一致的。</p><p class="paragraph"></p><h4>使用构造参数</h4><p class="paragraph">构造参数可以被定义在方法的bean类（第一个参数）和最后闭包（代码块）之间，如下所示：
</p><div class="code"><pre>bb.beans {
   exampleBean(MyExampleBean, <span class="java-quote">"firstArgument"</span>, 2) {
       someProperty = [1,2,3]
   }
}</pre></div><p class="paragraph"></p><h4>配置BeanDefinition（使用工厂方法）</h4><p class="paragraph">闭包的第一个参数是bean实例的一个引用，因此你可以在此配置工厂方法，并且可以调用 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/support/AbstractBeanDefinition.html" class="api">AbstractBeanDefinition</a>类的任何方法。
</p><div class="code"><pre>bb.beans {
   exampleBean(MyExampleBean) { bean -&gt;
       bean.factoryMethod = <span class="java-quote">"getInstance"</span>
       bean.singleton = <span class="java-keyword">false</span>
       someProperty = [1,2,3]
   }
}</pre></div><p class="paragraph">另一种选择是，你可以利用bean定义方法的返回值来配置这个bean，如下：
</p><div class="code"><pre>bb.beans {
   def example = exampleBean(MyExampleBean) {
       someProperty = [1,2,3]
   }
   example.factoryMethod = <span class="java-quote">"getInstance"</span>
}</pre></div><p class="paragraph"></p><h4>使用工厂bean</h4><p class="paragraph">Spring中定义了工厂bean的概念，通常一个bean不是直接从class创建的，而是通过这些工厂bean。在这种情况下，bean是没有类的，相反你必须传递一个工厂bean的名称给要创建的bean，如下：
</p><div class="code"><pre>bb.beans {
   myFactory(ExampleFactoryBean) {
       someProperty = [1,2,3]
   }
   myBean(myFactory) {
        name = <span class="java-quote">"blah"</span>
   }
}</pre></div><p class="paragraph">注意在上述的例子中，我们在bean的构造方法中使用 <code>myFactory</code> bean的引用而不是一个类。另一个常用的方法是提供工厂方法的名字供工厂bean调用，这是通过Groovy的命名参数语法来实现的，如下：
</p><div class="code"><pre>bb.beans {
   myFactory(ExampleFactoryBean) {
       someProperty = [1,2,3]
   }
   myBean(myFactory:<span class="java-quote">"getInstance"</span>) {
        name = <span class="java-quote">"blah"</span>
   }
}</pre></div><p class="paragraph">此处 <code>ExampleFactoryBean</code> bean的 <code>getInstance</code> 方法将被用来创建 <code>myBean</code> bean。</p><p class="paragraph"></p><h4>运行期间创建Bean引用</h4><p class="paragraph">有时候，你直到运行的时候才知道要创建的bean名称，此时你可以通过字符串内插（string interpolation）的方式来动态的定义一个bean，如下：
</p><div class="code"><pre>def beanName = <span class="java-quote">"example"</span>
bb.beans {
   <span class="java-quote">"${beanName}Bean"</span>(MyExampleBean) {
       someProperty = [1,2,3]
   }
}</pre></div><p class="paragraph">在这个例子中，当要定义一个bean的时候，先前定义的 <code>beanName</code> 变量将被使用。</p><p class="paragraph">此外，当跟其他的beans一起组装的时候，有时你要引用的bean名字直到运行时才知道，在这种情况下，需要用到 <code>ref</code> 方法，如下：
</p><div class="code"><pre>def beanName = <span class="java-quote">"example"</span>
bb.beans {
   <span class="java-quote">"${beanName}Bean"</span>(MyExampleBean) {
       someProperty = [1,2,3]
   }
   anotherBean(AnotherBean) {
       example = ref(<span class="java-quote">"${beanName}Bean"</span>)
   }
}</pre></div><p class="paragraph">
在这个示例中， <code>AnotherBean</code> 的example属性就是在运行时被设置为 <code>exampleBean</code>。 <code>ref</code> 方法也可以被用来引用父 <code>ApplicationContext</code> 中的beans，前提是父 <code>ApplicationContext</code> 要通过 <code>BeanBuilder</code> 构造函数传递进来，如下：
</p><div class="code"><pre>ApplicationContext parent = ...//
der bb = <span class="java-keyword">new</span> BeanBuilder(parent)
bb.beans {
   anotherBean(AnotherBean) {
       example = ref(<span class="java-quote">"${beanName}Bean"</span>, <span class="java-keyword">true</span>)
   }
}</pre></div><p class="paragraph">这里的第二个参数被置为true用来指定要引用的bean将在父上下文（parent context）中寻找。</p><p class="paragraph"></p><h4>使用匿名（内部）Beans</h4><p class="paragraph">你可以通过使用匿名内部类的方式来设置bean的一个属性，此匿名代码块将此bean的类型作为其参数，代码如下：
</p><div class="code"><pre>bb.beans {
  marge(Person.class) {
      name = <span class="java-quote">"marge"</span>
      husband =  { Person p -&gt;
 	              name = <span class="java-quote">"homer"</span>
		      age = 45
                      props = [overweight:<span class="java-keyword">true</span>, height:<span class="java-quote">"1.8m"</span>] }
      children = [bart, lisa]
  }
  bart(Person) {
      name = <span class="java-quote">"Bart"</span>
      age = 11
  }
  lisa(Person) {
      name = <span class="java-quote">"Lisa"</span>
      age = 9
  }
}</pre></div><p class="paragraph">在上述示例中，我们设置bean <code>marge</code> 的husband属性为一个代码块（其实就是一个闭包--译者），在此代码块中创建了内部的bean应用。作为另外一种选择，如果你有一个工厂bean，那你就可以忽略此bean类型，只需要传入一个bean定义来设置相应的工厂，代码如下：
</p><div class="code"><pre>bb.beans {
  personFactory(PersonFactory.class)
  marge(Person.class) {
      name = <span class="java-quote">"marge"</span>
      husband =  { bean -&gt;
                     bean.factoryBean = <span class="java-quote">"personFactory"</span>
                     bean.factoryMethod = <span class="java-quote">"newInstance"</span>
 	              name = <span class="java-quote">"homer"</span>
		      age = 45
                      props = [overweight:<span class="java-keyword">true</span>, height:<span class="java-quote">"1.8m"</span>] }
      children = [bart, lisa]
  }
}</pre></div><p class="paragraph"></p><h4>定义抽象Beans和父Bean</h4><p class="paragraph">创建一个抽象的bean，只需要定义一个没有类的bean就可以了，如下所示：
</p><div class="code"><pre>class HolyGrailQuest {
	   def start() { println <span class="java-quote">"lets begin"</span> }
}
class KnightOfTheRoundTable {
   <span class="java-object">String</span> name
   <span class="java-object">String</span> leader
   KnightOfTheRoundTable(<span class="java-object">String</span> n) {
      <span class="java-keyword">this</span>.name = n
   }
   HolyGrailQuest quest<p class="paragraph">   def embarkOnQuest() {
       quest.start()
   }
}</p><p class="paragraph">def bb = <span class="java-keyword">new</span> grails.spring.BeanBuilder()
bb.beans {
  abstractBean {
      leader = <span class="java-quote">"Lancelot"</span>
  }
  …
}</p></pre></div><p class="paragraph">在此我们定义了一个抽象的bean，其 <code>leader</code> 被设置为 <code>"Lancelot"</code>，现在为了使用这个抽象bean，只需将此抽象bean设置为子bean的父就好了，如下bean.parent所示：
</p><div class="code"><pre>bb.beans {
  …
  quest(HolyGrailQuest)
  knights(KnightOfTheRoundTable, <span class="java-quote">"Camelot"</span>) { bean -&gt;
      bean.parent = abstractBean
      quest = quest
  }
}</pre></div><p class="paragraph"></p><blockquote class="note">
当你使用父bean的时候，parent一定要设置在其他属性之前！
</blockquote><p class="paragraph">如果你希望抽象bean带一个类参数，那你可以象下边这么做：
</p><div class="code"><pre>def bb = <span class="java-keyword">new</span> grails.spring.BeanBuilder()
bb.beans {                                          
  abstractBean(KnightOfTheRoundTable) { bean -&gt;
      bean.'<span class="java-keyword">abstract</span>' = <span class="java-keyword">true</span>                  
      leader = <span class="java-quote">"Lancelot"</span>
  }
  quest(HolyGrailQuest)
  knights(<span class="java-quote">"Camelot"</span>) { bean -&gt;
      bean.parent = abstractBean
      quest = quest
  }
}</pre></div><p class="paragraph">在上述的示例中，我们创建了一个 <code>KnightOfTheRoundTable</code> 类型的抽象bean，并且使用bean参数变量来设置其属性，随后我们定义了一个bean：knights，此bean没有类参数，但其继承了父类bean。</p><p class="paragraph"></p><h4>在绑定（Binding）/上下文（Context）中增加变量</h4><p class="paragraph">如果你是使用脚本来加载bean的话，那你可以使用Groovy的Binding对象的binding属性的方式来加载。代码如下：
</p><div class="code"><pre>def bb = <span class="java-keyword">new</span> BeanBuilder(<span class="java-quote">"classpath:*SpringBeans.groovy"</span>)
def binding = <span class="java-keyword">new</span> Binding()
binding.foo = <span class="java-quote">"bar"</span><p class="paragraph">bb.binding = binding</p><p class="paragraph">def ctx = bb.createApplicationContext()</p></pre></div><p class="paragraph"></p><h4>从文件系统中加载Bean定义</h4><p class="paragraph">你也可以通过 <code>BeanBuilder</code> 来加载相同ClassPath路径下的定义在外部的Groovy脚本中的bean（当然要符合BeanBuilder语法），示例如下：
</p><div class="code"><pre>def bb = <span class="java-keyword">new</span> BeanBuilder(<span class="java-quote">"classpath:*SpringBeans.groovy"</span>)<p class="paragraph">def applicationContext = bb.createApplicationContext()</p></pre></div><p class="paragraph">此处 <code>BeanBuilder</code> 将加载ClassPath下边所有以 <code>SpringBeans.groovy</code> 结尾的Groovy文件中的bean,示例脚本如下：
</p><div class="code"><pre>beans = {
	dataSource(BasicDataSource) {
		driverClassName = <span class="java-quote">"org.hsqldb.jdbcDriver"</span>
		url = <span class="java-quote">"jdbc:hsqldb:mem:grailsDB"</span>
		username = <span class="java-quote">"sa"</span>
		password = <span class="java-quote">""</span>
	}
        sessionFactory(ConfigurableLocalSessionFactoryBean) {
              dataSource = dataSource
              hibernateProperties = [ <span class="java-quote">"hibernate.hbm2ddl.auto"</span>:<span class="java-quote">"create-drop"</span>,
                                      <span class="java-quote">"hibernate.show_sql"</span>:<span class="java-keyword">true</span>  ]
        }<p class="paragraph">}</p></pre></div><p class="paragraph"></p><h2><a name="14.4 配置属性占位">14.4 配置属性占位</a></h2>通过扩展Spring的 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html" class="api">PropertyPlaceholderConfigurer</a>，Grails支持属性占位符的概念，这一般结合着<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.4 外部配置" class="guide">外置的配置</a>来使用。<p class="paragraph">对Spring的配置文件 <code>grails-app/conf/spring/resources.xml</code>来说，占位符值的设置既可以是<a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 脚本，也可以是Java属性文件，如下例所示，相应的配置存放在 <code>grails-app/conf/Config.groovy</code> （或者一个外置的配置文件中）中：
</p><div class="code"><pre>database.driver=<span class="java-quote">"com.mysql.jdbc.Driver"</span>
database.dbname=<span class="java-quote">"mysql:mydb"</span></pre></div><p class="paragraph">这样你就可以在 <code>resources.xml</code> 使用 ${..} 语法来使用占位符了。
</p><div class="code"><pre><span class="xml-tag">&lt;bean id=<span class="xml-quote">"dataSource"</span> class=<span class="xml-quote">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>
   <span class="xml-tag">&lt;property name=<span class="xml-quote">"driverClassName"</span>&gt;</span><span class="xml-tag">&lt;value&gt;</span>${database.driver}<span class="xml-tag">&lt;/value&gt;</span><span class="xml-tag">&lt;/property&gt;</span>
   <span class="xml-tag">&lt;property name=<span class="xml-quote">"url"</span>&gt;</span><span class="xml-tag">&lt;value&gt;</span>jdbc:${database.dbname}<span class="xml-tag">&lt;/value&gt;</span><span class="xml-tag">&lt;/property&gt;</span>
 <span class="xml-tag">&lt;/bean&gt;</span></pre></div>
<h2><a name="14.5 配置属性重载">14.5 配置属性重载</a></h2>通过扩展Spring的 <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/PropertyOverrideConfigurer.html" class="api">PropertyOverrideConfigurer</a>，Grails支持属性重写的概念，这一般结合着<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.4 外部配置" class="guide">外置的配置</a>来使用。<p class="paragraph">本质上，你可以通过 <a href="http://groovy.codehaus.org/ConfigSlurper" target="blank">ConfigSlurper</a> 脚本中的 <code>beans</code> 代码块来重写一个bean的配置，如下所示：
</p><div class="code"><pre>beans {
   bookService.webServiceURL = <span class="java-quote">"http://www.amazon.com"</span>
}</pre></div><p class="paragraph">这样的重写被应用在Spring的 <code>ApplicationContext</code> 被构造之前，其格式是：
</p><div class="code"><pre>[bean name].[property name] = [value]</pre></div><p class="paragraph">当然了，你也可以提供常规Java属性文件的配置，只不过需要每次都要带一个前缀 <code>beans</code>
</p><div class="code"><pre>beans.bookService.webServiceURL=http://www.amazon.com</pre></div>
<h1><a name="15. Grails和Hibernate">15. Grails和Hibernate</a></h1>如果<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM （Grails对象关系映射）</a>对你来说还不够灵活，那你依然可以使用Hibernate来映射你的领域类。为此你只需在工程目录的 <code>grails-app/conf/hibernate</code> 中创建 <code>hibernate.cfg.xml</code> 文件和相应的HBM映射文件。
<blockquote class="note">
更多Hibernate映射信息请参考Hibernate官方网站的<a href="http://www.hibernate.org/" target="blank">关于映射的文档</a>
</blockquote><p class="paragraph">这允许你将Grails的领域类映射到范围更广的遗留系统而且也使你的数据库（database schema）创建更灵活。</p><p class="paragraph">Grails也允许你用Java来实现你的领域模型或者重用Hibernate映射过的领域模型，你所需要做的仅仅是将必要的 <code>hibernate.cfg.xml</code> 和相应的映射文件放到 <code>grails-app/conf/hibernate</code> 目录下。</p><p class="paragraph">另外一个好处是：你依然可以调用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#5. 对象关系映射(GORM)" class="guide">GORM</a>中的所有动态持久化和查询的方法。
</p><h2><a name="15.1 通过Hibernate注释进行映射">15.1 通过Hibernate注释进行映射</a></h2>Grails也支持基于Java5注解创建的Hibernate领域类。为了让Grails知道你正在使用注解，你需要在<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#3.3 数据源" class="guide">数据源</a>配置中设置 <code>configClass</code> 属性，如下所示：
<div class="code"><pre><span class="java-keyword">import</span> org.codehaus.groovy.grails.orm.hibernate.cfg.GrailsAnnotationConfiguration
dataSource {
	configClass = GrailsAnnotationConfiguration.class
   … // remaining properties
}</pre></div><p class="paragraph">配置就是这么简单！不过因为注解需要，请确认你已经安装了Java5。现在为了创建一个基于注解的类，只需要在 <code>src/java</code> 简单的创建一个新的Java类就可以了，当然了，要使用EJB3规范的注解（更多信息请参考<a href="http://annotations.hibernate.org/" target="blank">Hibernate注解文档</a>）
</p><div class="code"><pre><span class="java-keyword">package</span> com.books;
@Entity
<span class="java-keyword">public</span> class Book {
    <span class="java-keyword">private</span> <span class="java-object">Long</span> id;
    <span class="java-keyword">private</span> <span class="java-object">String</span> title;
    <span class="java-keyword">private</span> <span class="java-object">String</span> description;
    <span class="java-keyword">private</span> Date date;<p class="paragraph">    @Id
    @GeneratedValue
    <span class="java-keyword">public</span> <span class="java-object">Long</span> getId() {
        <span class="java-keyword">return</span> id;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void setId(<span class="java-object">Long</span> id) {
        <span class="java-keyword">this</span>.id = id;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-object">String</span> getTitle() {
        <span class="java-keyword">return</span> title;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void setTitle(<span class="java-object">String</span> title) {
        <span class="java-keyword">this</span>.title = title;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-object">String</span> getDescription() {
        <span class="java-keyword">return</span> description;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void setDescription(<span class="java-object">String</span> description) {
        <span class="java-keyword">this</span>.description = description;
    }
}</p></pre></div><p class="paragraph">一旦定义完毕，别忘了在Hibernate的 <code>sessionFactory</code> 中注册相应的类，在Grails中，你需要将相应的实体加到 <code>grails-app/conf/hibernate/hibernate.cfg.xml</code> 配置文件中，如下代码所示：
</p><div class="code"><pre>&lt;!DOCTYPE hibernate-configuration SYSTEM
  <span class="xml-quote">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;
<span class="xml-tag">&lt;hibernate-configuration&gt;</span>
    <span class="xml-tag">&lt;session-factory&gt;</span>
        <span class="xml-tag">&lt;mapping package=<span class="xml-quote">"com.books"</span> /&gt;</span>
        <span class="xml-tag">&lt;mapping class=<span class="xml-quote">"com.books.Book"</span> /&gt;</span>
    <span class="xml-tag">&lt;/session-factory&gt;</span>
<span class="xml-tag">&lt;/hibernate-configuration&gt;</span></pre></div><p class="paragraph">当Grails加载的时候，将会为这些领域类注册必要的动态方法。要了解Hibernate领域类还能做哪些，请参考<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#16.脚手架" class="guide">脚手架</a>相关章节。
</p><h2><a name="15.2 深入了解">15.2 深入了解</a></h2>Jason Rudolph作为Grails的提交者，花时间写了许多关于Grails和自定义Hibernate映射的文章，如下所示：
<ul class="star">
<li><a href="http://jasonrudolph.com/blog/2006/06/20/hoisting-grails-to-your-legacy-db/" target="blank">在遗留数据库中使用Grails</a> - 一篇关于如何在Grails使用Hibernate XML的很精彩的文章。</li>
<li><a href="http://www.infoq.com/articles/grails-ejb-tutorial" target="blank">Grails和EJB3领域模型</a> - 另一篇关于在Grails中使用EJB3风格注释的领域模型的非常好的文章。</li>
</ul><p class="paragraph"></p><h1><a name="16.脚手架">16.脚手架</a></h1>根据指定的领域类，脚手架为你自动生成一个领域相关的完整应用，包括：
<ul class="star">
<li>必要的<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#6.2 Groovy Server Pages" class="guide">视图</a></li>
<li>控制器的创建/读取/更新/删除（CRUD）操作</li>
</ul><p class="paragraph"></p><h4>让脚手架生效</h4><p class="paragraph">让脚手架生效的最简单方法是通过设置 <code>scaffold</code> 属性。以领域类 <code>Book</code> 为例,你需要在其控制器中设置 <code>scaffold</code> 属性为true就可以了，如以下代码所示：
</p><div class="code"><pre>class BookController {
   def scaffold = <span class="java-keyword">true</span>
}</pre></div><p class="paragraph">上述代码可以正常工作是因为控制器 <code>BookController</code> 命名跟领域类 <code>Book</code> 相一致，那如果想要让脚手架对特定的领域类也有效，该怎么办呢？很简单，直接将特定的领域类赋值给scaffold属性就好了，如下代码所示：
</p><div class="code"><pre>def scaffold = Author</pre></div><p class="paragraph">设置完毕后，如果你运行grails应用，那么那些必要的动作和视图都将在运行期间自动生成。根据脚手架的动态机制，以下一些动作将被动态实现：
</p><ul class="star">
<li>list</li>
<li>show</li>
<li>edit</li>
<li>delete</li>
<li>create</li>
<li>save</li>
<li>update</li>
</ul><p class="paragraph">即基本的CRUD接口将被自动生成。为了访问以上示例生成的接口，只需在浏览器地址栏简单输入<code>http://localhost:8080/app/book</code></p><p class="paragraph">如果你倾向于使用<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#15. Grails和Hibernate" class="guide">基于Hibernate映射</a>的Java领域模型，你依然可以使用脚手架，只需简单的导入必要的类，并且将此类赋值给scaffold属性即可。</p><p class="paragraph"></p><h4>动态脚手架</h4><p class="paragraph">注意当使用scaffold属性的时候，Grails并不是通过代码模板或者代码生成来实现脚手架功能，因此你照样可以在被脚手架过的控制器中增加自己的动作，来跟脚手架过的动作进行交互。比如，在下面的示例中， <code>changeAuthor</code> 可以重新定向到一个并不存在的 <code>show</code> 的动作。
</p><div class="code"><pre>class BookController {
   def scaffold = Book<p class="paragraph">   def changeAuthor = {
        def b = Book.get( params[<span class="java-quote">"id"</span>] )
        b.author = Author.get( params[<span class="java-quote">"author.id"</span>] )
        b.save()</p><p class="paragraph">        // redirect to a scaffolded action
        redirect(action:show)
   }
}</p></pre></div><p class="paragraph">当然必要的时候，你也可以使用自己的动作来重写被脚手架过的动作，代码如下：
</p><div class="code"><pre>class BookController {
   def scaffold = Book<p class="paragraph">   // overrides scaffolded action to <span class="java-keyword">return</span> both authors and books
   def list = {
         [ <span class="java-quote">"books"</span> : Book.list(), <span class="java-quote">"authors"</span>: Author.list() ]
   }
}</p></pre></div><p class="paragraph">所有这些就是所谓的“动态脚手架”，在这里CRUD接口将在运行期间动态生成。不过Grails同样也支持所谓的“静态”脚手架，这将在接下来的章节中讨论。</p><p class="paragraph"></p><h4>自定义生成的视图</h4><p class="paragraph">Grails生成的视图中，有些表单能智能地适应<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#7.1 声明约束" class="guide">验证约束</a>。如下面代码所示，只需要简单地重新排列生成器（builder）中约束的顺序，就可以改变其在视图中出现的顺序。
</p><div class="code"><pre>def constraints = {
      title()
      releaseDate()
}</pre></div><p class="paragraph">你也可以通过使用 <code>inList</code> 约束来生成一个列表（list）而不是简单的文本输入框（text input），
</p><div class="code"><pre>def constraints = {
      title()
      category(inList:[<span class="java-quote">"Fiction"</span>, <span class="java-quote">"Non-fiction"</span>, <span class="java-quote">"Biography"</span>])
      releaseDate()
}</pre></div><p class="paragraph">或者通过基于数字的 <code>range</code> 约束来生成列表
</p><div class="code"><pre>def constraints = {
        age(range:18..65)
}</pre></div><p class="paragraph">通过约束来限制大小（size）也可以影响生成的视图中可以输入的字符数。
</p><div class="code"><pre>def constraints = {
        name(size:0..30)
}</pre></div><p class="paragraph"></p><h4>生成控制器和视图</h4><p class="paragraph">以上的脚手架特性虽然很有用，但是在现实世界中有可能需要自定义逻辑和视图。Grails允许你通过使用命令行的方式，来生成一个控制器和相关视图（跟脚手架所做的事情差不多）。为了生成控制器，只需要输入：
</p><div class="code"><pre>grails generate-controller Book</pre></div><p class="paragraph">或者为了生成视图，只需输入：
</p><div class="code"><pre>grails generate-views Book</pre></div><p class="paragraph">或者生成控制器和视图，只需输入：
</p><div class="code"><pre>grails generate-all Book</pre></div><p class="paragraph">如果你的领域类有包名或者从<a href="http://www.kuqin.com/grails-doc-1.0/guide/single.html#15. Grails和Hibernate" class="guide">Hibernate映射的类</a>来生成，那需要记住一定要用类的全名（包名+类名），如下：
</p><div class="code"><pre>grails generate-all com.bookstore.Book</pre></div><p class="paragraph">
         			
		</p></div>
		<div id="footer">
			  赞助商：<a href="http://g2one.com/">G2One Inc</a>，官方翻译网站：<a href="http://wiki.redsaga.com/confluence/pages/viewpage.action?pageId=2458">Grails中文参考手册</a>，意见反馈：<a href="http://www.chinagroovy.org/forum/index.php?board=20.0">Groovy中国社区的文档翻译</a>
		</div>	
<div style="display:none"><script language="JavaScript" src="./Grails开源框架 1.0 - 使用指南_files/tongjidoc.js" type="text/JavaScript"></script><script src="./Grails开源框架 1.0 - 使用指南_files/stat.php" language="JavaScript"></script><script src="./Grails开源框架 1.0 - 使用指南_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=3349935" target="_blank" title="站长统计">站长统计</a>
</div>


</body></html>