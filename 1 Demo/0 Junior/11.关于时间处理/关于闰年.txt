参见：

     http://www.jb51.net/article/28034.htm

平年：

年份可统一写作：(?!0000)[0-9]{4}
包括平年在内的所有年份的月份都包含1-28日：(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])
包括平年在内的所有年份除2月外都包含29和30日：(0[13-9]|1[0-2])-(29|30)
包括平年在内的所有年份1、3、5、7、8、10、12月都包含31日：(0[13578]|1[02])-31)
合起来就是除闰年的2月29日外的其它所有日期：(?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)
润年

能被4整除但不能被100整除的年份：([0-9]{2}(0[48]|[2468][048]|[13579][26])
能被400整除的年份。能被400整除的数肯定能被100整除，因此后两位肯定是00：(0[48]|[2468][048]|[13579][26])00
合起来就是所有闰年的2月29日：([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)
四条规则都已实现，且互相间没有影响，合起来就是所有符合DateTime范围的日期的正则
^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$

考虑到这个正则表达式仅仅是用作验证，所以捕获组没有意义，只会占用资源，影响匹配效率，所以可以使用非捕获组来进行优化。
^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 


对应的JavaScript 方法


function checkDate(fname){
var sc = $("#"+fname);
var s = sc.val();
if (sc==null){
alert("Element is null");
return true;
}
var reg=/^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
if(!s.match(reg)){
alert("false");
}else{
alert("true"); }

} 


<body>
<input type="date" name="textfield" id="text1" >
<input type="button" value="按钮" onClick="checkDate('text1')">
</body> 


测试代码


var str = '2009-12-33';
if(str.match(/^((?:19|20)\d\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/)) {
alert('是日期');
} else {
alert('不是日期');
} 